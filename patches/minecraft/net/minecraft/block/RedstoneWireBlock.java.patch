--- a/net/minecraft/block/RedstoneWireBlock.java
+++ b/net/minecraft/block/RedstoneWireBlock.java
@@ -1,5 +_,6 @@
 package net.minecraft.block;
 
+import com.destroystokyo.paper.util.RedstoneWireTurbo;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -33,6 +_,7 @@
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
+import org.bukkit.event.block.BlockRedstoneEvent;
 
 public class RedstoneWireBlock extends Block {
    public static final EnumProperty<RedstoneSide> field_176348_a = BlockStateProperties.field_208160_M;
@@ -184,7 +_,7 @@
       BlockState blockstate = p_235545_1_.func_180495_p(blockpos);
       if (p_235545_4_) {
          boolean flag = this.func_235552_b_(p_235545_1_, blockpos, blockstate);
-         if (flag && func_176346_d(p_235545_1_.func_180495_p(blockpos.func_177984_a()))) {
+         if (flag && canConnectTo(p_235545_1_.func_180495_p(blockpos.func_177984_a()), p_235545_1_, blockpos.func_177984_a(), null) ) {
             if (blockstate.func_224755_d(p_235545_1_, blockpos, p_235545_3_.func_176734_d())) {
                return RedstoneSide.UP;
             }
@@ -193,7 +_,7 @@
          }
       }
 
-      return !func_176343_a(blockstate, p_235545_3_) && (blockstate.func_215686_e(p_235545_1_, blockpos) || !func_176346_d(p_235545_1_.func_180495_p(blockpos.func_177977_b()))) ? RedstoneSide.NONE : RedstoneSide.SIDE;
+      return !canConnectTo(blockstate, p_235545_1_, blockpos, p_235545_3_) && (blockstate.func_215686_e(p_235545_1_, blockpos) || !canConnectTo(p_235545_1_.func_180495_p(blockpos.func_177977_b()), p_235545_1_, blockpos.func_177977_b(), null)) ? RedstoneSide.NONE : RedstoneSide.SIDE;
    }
 
    public boolean func_196260_a(BlockState p_196260_1_, IWorldReader p_196260_2_, BlockPos p_196260_3_) {
@@ -206,9 +_,132 @@
       return p_235552_3_.func_224755_d(p_235552_1_, p_235552_2_, Direction.UP) || p_235552_3_.func_203425_a(Blocks.field_150438_bZ);
    }
 
+   // Paper start - Optimize redstone
+   // The bulk of the new functionality is found in RedstoneWireTurbo.java
+   RedstoneWireTurbo turbo = new RedstoneWireTurbo(this);
+
+   /*
+    * Modified version of pre-existing updateSurroundingRedstone, which is called from
+    * this.neighborChanged and a few other methods in this class.
+    * Note: Added 'source' argument so as to help determine direction of information flow
+    */
+   private void updateSurroundingRedstone(World worldIn, BlockPos pos, BlockState state, BlockPos source) {
+      if (worldIn.paperConfig.useEigencraftRedstone) {
+         turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+         return;
+      }
+      func_235547_a_(worldIn, pos, state);
+   }
+
+   /*
+    * Slightly modified method to compute redstone wire power levels from neighboring blocks.
+    * Modifications cut the number of power level changes by about 45% from vanilla, and this
+    * optimization synergizes well with the breadth-first search implemented in
+    * RedstoneWireTurbo.
+    * Note:  RedstoneWireTurbo contains a faster version of this code.
+    * Note:  Made this public so that RedstoneWireTurbo can access it.
+    */
+   public BlockState calculateCurrentChanges(World worldIn, BlockPos pos1, BlockPos pos2, BlockState state) {
+      BlockState iblockstate = state;
+      int i = state.get(field_176351_O);
+      int j = 0;
+      j = this.getPower(j, worldIn.getType(pos2));
+      this.setCanProvidePower(false);
+      int k = worldIn.isBlockIndirectlyGettingPowered(pos1);
+      this.setCanProvidePower(true);
+
+      if (!worldIn.paperConfig.useEigencraftRedstone) {
+         // This code is totally redundant to if statements just below the loop.
+         if (k > 0 && k > j - 1) {
+            j = k;
+         }
+      }
+
+      int l = 0;
+
+      // The variable 'k' holds the maximum redstone power value of any adjacent blocks.
+      // If 'k' has the highest level of all neighbors, then the power level of this
+      // redstone wire will be set to 'k'.  If 'k' is already 15, then nothing inside the
+      // following loop can affect the power level of the wire.  Therefore, the loop is
+      // skipped if k is already 15.
+      if (!worldIn.paperConfig.useEigencraftRedstone || k < 15) {
+         for (Direction enumfacing : Direction.Plane.HORIZONTAL) {
+            BlockPos blockpos = pos1.shift(enumfacing);
+            boolean flag = blockpos.func_177958_n() != pos2.func_177958_n() || blockpos.func_177952_p() != pos2.func_177952_p();
+
+            if (flag) {
+               l = this.getPower(l, worldIn.getType(blockpos));
+            }
+
+            if (worldIn.getType(blockpos).isOccluding(worldIn, blockpos) && !worldIn.getType(pos1.up()).isOccluding(worldIn, pos1)) {
+               if (flag && pos1.func_177956_o() >= pos2.func_177956_o()) {
+                  l = this.getPower(l, worldIn.getType(blockpos.up()));
+               }
+            } else if (!worldIn.getType(blockpos).isOccluding(worldIn, blockpos) && flag && pos1.func_177956_o() <= pos2.func_177956_o()) {
+               l = this.getPower(l, worldIn.getType(blockpos.down()));
+            }
+         }
+      }
+
+      if (!worldIn.paperConfig.useEigencraftRedstone) {
+         // The old code would decrement the wire value only by 1 at a time.
+         if (l > j) {
+            j = l - 1;
+         } else if (j > 0) {
+            --j;
+         } else {
+            j = 0;
+         }
+
+         if (k > j - 1) {
+            j = k;
+         }
+      } else {
+         // The new code sets this RedstoneWire block's power level to the highest neighbor
+         // minus 1.  This usually results in wire power levels dropping by 2 at a time.
+         // This optimization alone has no impact on update order, only the number of updates.
+         j = l - 1;
+
+         // If 'l' turns out to be zero, then j will be set to -1, but then since 'k' will
+         // always be in the range of 0 to 15, the following if will correct that.
+         if (k > j) j = k;
+      }
+
+      if (i != j) {
+         state = state.func_206870_a(field_176351_O, j);
+
+         if (worldIn.getType(pos1) == iblockstate) {
+            worldIn.setTypeAndData(pos1, state, 2);
+         }
+
+         // 1.16(.1?) dropped the need for blocks needing updates.
+         // Whether this is necessary after all is to be seen.
+//            if (!worldIn.paperConfig.useEigencraftRedstone) {
+//                // The new search algorithm keeps track of blocks needing updates in its own data structures,
+//                // so only add anything to blocksNeedingUpdate if we're using the vanilla update algorithm.
+//                this.getBlocksNeedingUpdate().add(pos1);
+//
+//                for (EnumDirection enumfacing1 : EnumDirection.values()) {
+//                    this.getBlocksNeedingUpdate().add(pos1.shift(enumfacing1));
+//                }
+//            }
+      }
+
+      return state;
+   }
+   // Paper end
+
    private void func_235547_a_(World p_235547_1_, BlockPos p_235547_2_, BlockState p_235547_3_) {
       int i = this.func_235546_a_(p_235547_1_, p_235547_2_);
-      if (p_235547_3_.func_177229_b(field_176351_O) != i) {
+      // CraftBukkit start
+      int oldPower = p_235547_3_.func_177229_b(field_176351_O).intValue();
+      if (oldPower != i) {
+         BlockRedstoneEvent event = new BlockRedstoneEvent(p_235547_1_.getWorld().getBlockAt(p_235547_2_.func_177958_n(), p_235547_2_.func_177956_o(), p_235547_2_.func_177952_p()), oldPower, i);
+         p_235547_1_.getCBServer().getPluginManager().callEvent(event);
+         i = event.getNewCurrent();
+         // CraftBukkit end
+      }
+      if (oldPower != i) {
          if (p_235547_1_.func_180495_p(p_235547_2_) == p_235547_3_) {
             p_235547_1_.func_180501_a(p_235547_2_, p_235547_3_.func_206870_a(field_176351_O, Integer.valueOf(i)), 2);
          }
@@ -216,11 +_,11 @@
          Set<BlockPos> set = Sets.newHashSet();
          set.add(p_235547_2_);
 
-         for(Direction direction : Direction.values()) {
+         for (Direction direction : Direction.values()) {
             set.add(p_235547_2_.func_177972_a(direction));
          }
 
-         for(BlockPos blockpos : set) {
+         for (BlockPos blockpos : set) {
             p_235547_1_.func_195593_d(blockpos, this);
          }
       }
@@ -249,6 +_,9 @@
       return Math.max(i, j - 1);
    }
 
+   private int getPower(int min, BlockState iblockdata) { return Math.max(min, getPower(iblockdata)); } // Paper - Optimize redstone
+   private int getPower(BlockState iblockdata) { return this.func_235557_o_(iblockdata); } // Paper - OBFHELPER
+
    private int func_235557_o_(BlockState p_235557_1_) {
       return p_235557_1_.func_203425_a(this) ? p_235557_1_.func_177229_b(field_176351_O) : 0;
    }
@@ -266,7 +_,8 @@
 
    public void func_220082_b(BlockState p_220082_1_, World p_220082_2_, BlockPos p_220082_3_, BlockState p_220082_4_, boolean p_220082_5_) {
       if (!p_220082_4_.func_203425_a(p_220082_1_.func_177230_c()) && !p_220082_2_.field_72995_K) {
-         this.func_235547_a_(p_220082_2_, p_220082_3_, p_220082_1_);
+         //this.updatePowerStrength(p_220082_2_, p_220082_3_, p_220082_1_);
+         this.updateSurroundingRedstone(p_220082_2_, p_220082_3_, p_220082_4_, null); // Paper - Optimize redstone
 
          for(Direction direction : Direction.Plane.VERTICAL) {
             p_220082_2_.func_195593_d(p_220082_3_.func_177972_a(direction), this);
@@ -284,7 +_,8 @@
                p_196243_2_.func_195593_d(p_196243_3_.func_177972_a(direction), this);
             }
 
-            this.func_235547_a_(p_196243_2_, p_196243_3_, p_196243_1_);
+            //this.updatePowerStrength(p_196243_2_, p_196243_3_, p_196243_1_);
+            this.updateSurroundingRedstone(p_196243_2_, p_196243_3_, p_196243_1_, null); // Paper - Optimize redstone
             this.func_235553_d_(p_196243_2_, p_196243_3_);
          }
       }
@@ -309,7 +_,8 @@
    public void func_220069_a(BlockState p_220069_1_, World p_220069_2_, BlockPos p_220069_3_, Block p_220069_4_, BlockPos p_220069_5_, boolean p_220069_6_) {
       if (!p_220069_2_.field_72995_K) {
          if (p_220069_1_.func_196955_c(p_220069_2_, p_220069_3_)) {
-            this.func_235547_a_(p_220069_2_, p_220069_3_, p_220069_1_);
+            //this.updatePowerStrength(p_220069_2_, p_220069_3_, p_220069_1_);
+            this.updateSurroundingRedstone(p_220069_2_, p_220069_3_, p_220069_1_, p_220069_5_); // Paper - Optimize redstone
          } else {
             func_220075_c(p_220069_1_, p_220069_2_, p_220069_3_);
             p_220069_2_.func_217377_a(p_220069_3_, false);
@@ -335,11 +_,7 @@
       }
    }
 
-   protected static boolean func_176346_d(BlockState p_176346_0_) {
-      return func_176343_a(p_176346_0_, (Direction)null);
-   }
-
-   protected static boolean func_176343_a(BlockState p_176343_0_, @Nullable Direction p_176343_1_) {
+   protected static boolean canConnectTo(BlockState p_176343_0_, IBlockReader world, BlockPos pos, @Nullable Direction p_176343_1_) {
       if (p_176343_0_.func_203425_a(Blocks.field_150488_af)) {
          return true;
       } else if (p_176343_0_.func_203425_a(Blocks.field_196633_cV)) {
@@ -348,7 +_,7 @@
       } else if (p_176343_0_.func_203425_a(Blocks.field_190976_dk)) {
          return p_176343_1_ == p_176343_0_.func_177229_b(ObserverBlock.field_176387_N);
       } else {
-         return p_176343_0_.func_185897_m() && p_176343_1_ != null;
+         return p_176343_0_.canConnectRedstone(world, pos, p_176343_1_) && p_176343_1_ != null;
       }
    }
 
@@ -463,4 +_,7 @@
       }
 
    }
+
+   public final boolean canProvidePower() { return this.field_150181_a; } // Paper - OBFHELPER
+   public final void setCanProvidePower(boolean shouldSignal) { this.field_150181_a = shouldSignal; } // Paper - OBFHELPER
 }
