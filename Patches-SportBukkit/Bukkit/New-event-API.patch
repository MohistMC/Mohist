From: Jedediah Smith <jedediah@silencegreys.com>
Date: Sat, 9 Jul 2016 05:27:03 -0400
Subject: [PATCH] New event API


diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -24,6 +24,7 @@ import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
+import org.bukkit.event.EventBus;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.server.ServerListPingEvent;
 import org.bukkit.help.HelpMap;
@@ -523,6 +524,10 @@ public final class Bukkit {
         return server.getServicesManager();
     }
 
+    public static EventBus eventBus() {
+        return server.eventBus();
+    }
+
     /**
      * Gets a list of all worlds on this server.
      *
@@ -1113,6 +1118,10 @@ public final class Bukkit {
         return server.getWarningState();
     }
 
+    public static boolean pluginProfiling() {
+        return server.pluginProfiling();
+    }
+
     /**
      * Gets the instance of the item factory (for {@link ItemMeta}).
      *
diff --git a/src/main/java/org/bukkit/BukkitModule.java b/src/main/java/org/bukkit/BukkitModule.java
new file mode 100644
index 0000000..2cb3a71
--- /dev/null
+++ b/src/main/java/org/bukkit/BukkitModule.java
@@ -0,0 +1,44 @@
+package org.bukkit;
+
+import com.google.inject.Provides;
+import org.bukkit.block.BlockFactory;
+import org.bukkit.geometry.VectorFactory;
+import org.bukkit.inventory.ItemFactory;
+import org.bukkit.potion.PotionBrewRegistry;
+import org.bukkit.potion.PotionEffectRegistry;
+import tc.oc.inject.SingletonModule;
+
+/**
+ * Bindings for global things that would be shared between servers,
+ * if there were multiple servers.
+ */
+public class BukkitModule extends SingletonModule {
+
+    @Override
+    protected void configure() {}
+
+    @Provides
+    VectorFactory vectorFactory(BukkitRuntime bukkit) {
+        return bukkit.vectors();
+    }
+
+    @Provides
+    BlockFactory blockFactory(BukkitRuntime bukkit) {
+        return bukkit.blocks();
+    }
+
+    @Provides
+    ItemFactory itemFactory(BukkitRuntime bukkit) {
+        return bukkit.getItemFactory();
+    }
+
+    @Provides
+    PotionEffectRegistry potionEffectRegistry(BukkitRuntime bukkit) {
+        return bukkit.potionEffectRegistry();
+    }
+
+    @Provides
+    PotionBrewRegistry potionBrewRegistry(BukkitRuntime bukkit) {
+        return bukkit.potionRegistry();
+    }
+}
diff --git a/src/main/java/org/bukkit/BukkitRuntime.java b/src/main/java/org/bukkit/BukkitRuntime.java
--- a/src/main/java/org/bukkit/BukkitRuntime.java
+++ b/src/main/java/org/bukkit/BukkitRuntime.java
@@ -1,5 +1,6 @@
 package org.bukkit;
 
+import com.google.inject.Injector;
 import org.bukkit.block.BlockFactory;
 import org.bukkit.inventory.ItemFactory;
 import org.bukkit.inventory.meta.ItemMeta;
@@ -10,6 +11,15 @@ import org.bukkit.geometry.VectorFactory;
 
 public interface BukkitRuntime {
 
+    /**
+     * Return the global {@link Injector}.
+     *
+     * Note that direct injector use is considered bad form,
+     * and is only provided to assist in migrating legacy code.
+     * Nice code should @Inject its dependencies.
+     */
+    Injector injector();
+
     Key key(String prefix, String id);
 
     Key key(String key);
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -24,6 +24,7 @@ import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
+import org.bukkit.event.EventBus;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.server.ServerListPingEvent;
 import org.bukkit.help.HelpMap;
@@ -134,6 +135,8 @@ public interface Server extends PluginMessageRecipient, BukkitRuntime, tc.oc.min
      */
     public Collection<? extends Player> getOnlinePlayers();
 
+    Map<UUID, Player> playersById();
+
     /**
      * Get the maximum amount of players which can login to this server.
      *
@@ -410,12 +413,21 @@ public interface Server extends PluginMessageRecipient, BukkitRuntime, tc.oc.min
     public ServicesManager getServicesManager();
 
     /**
+     * Get the server event bus
+     */
+    EventBus eventBus();
+
+    /**
      * Gets a list of all worlds on this server.
      *
      * @return a list of worlds
      */
     public List<World> getWorlds();
 
+    Map<String, World> worldsByName();
+
+    Map<UUID, World> worldsById();
+
     /**
      * Check for a level.dat file belonging to a world with the given name.
      * If found, return a {@link WorldCreator} configured to match the settings
@@ -900,6 +912,8 @@ public interface Server extends PluginMessageRecipient, BukkitRuntime, tc.oc.min
      */
     public WarningState getWarningState();
 
+    boolean pluginProfiling();
+
     /**
      * Gets the instance of the item factory (for {@link ItemMeta}).
      *
diff --git a/src/main/java/org/bukkit/ServerInstanceModule.java b/src/main/java/org/bukkit/ServerInstanceModule.java
new file mode 100644
index 0000000..4c82a5f
--- /dev/null
+++ b/src/main/java/org/bukkit/ServerInstanceModule.java
@@ -0,0 +1,35 @@
+package org.bukkit;
+
+import java.util.Collection;
+
+import com.google.inject.AbstractModule;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginInstanceModule;
+import tc.oc.inject.KeyedModule;
+import tc.oc.inject.ProtectedBinder;
+
+/**
+ * Configures a {@link Server} instance and a collection of {@link Plugin}s.
+ */
+public class ServerInstanceModule extends KeyedModule {
+
+    private final Server server;
+    private final Collection<Plugin> plugins;
+
+    public ServerInstanceModule(Server server, Collection<Plugin> plugins) {
+        super(server);
+        this.server = server;
+        this.plugins = plugins;
+    }
+
+    @Override
+    protected void configure() {
+        install(new ServerModule());
+        bind(Server.class).toInstance(server);
+
+        for(Plugin plugin : plugins) {
+            ProtectedBinder.newProtectedBinder(binder())
+                           .install(new PluginInstanceModule(plugin));
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/ServerModule.java b/src/main/java/org/bukkit/ServerModule.java
new file mode 100644
index 0000000..373967b
--- /dev/null
+++ b/src/main/java/org/bukkit/ServerModule.java
@@ -0,0 +1,111 @@
+package org.bukkit;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.UUID;
+
+import com.google.inject.Provides;
+import org.bukkit.command.CommandMap;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventBus;
+import org.bukkit.help.HelpMap;
+import org.bukkit.plugin.PluginManager;
+import org.bukkit.plugin.ServicesManager;
+import org.bukkit.plugin.messaging.Messenger;
+import org.bukkit.scheduler.BukkitScheduler;
+import org.bukkit.scoreboard.ScoreboardManager;
+import tc.oc.inject.SingletonModule;
+import tc.oc.minecraft.api.plugin.PluginFinder;
+import tc.oc.minecraft.api.server.LocalServer;
+
+/**
+ * Bindings for things that belong to a {@link Server}.
+ *
+ * Does not bind {@link Server} itself.
+ *
+ * @see ServerInstanceModule
+ */
+public class ServerModule extends SingletonModule {
+
+    @Override
+    protected void configure() {
+        install(new BukkitModule());
+
+        bind(tc.oc.minecraft.api.server.Server.class).to(LocalServer.class);
+        bind(LocalServer.class).to(Server.class);
+        bind(BukkitRuntime.class).to(Server.class);
+        bind(tc.oc.minecraft.api.command.ConsoleCommandSender.class).to(ConsoleCommandSender.class);
+        bind(PluginFinder.class).to(PluginManager.class);
+    }
+
+    @Provides
+    PluginManager pluginManager(Server server) {
+        return server.getPluginManager();
+    }
+
+    @Provides
+    EventBus eventBus(Server server) {
+        return server.eventBus();
+    }
+
+    @Provides
+    BukkitScheduler bukkitScheduler(Server server) {
+        return server.getScheduler();
+    }
+
+    @Provides
+    CommandMap commandMap(Server server) {
+        return server.getCommandMap();
+    }
+
+    @Provides
+    HelpMap helpMap(Server server) {
+        return server.getHelpMap();
+    }
+
+    @Provides
+    ConsoleCommandSender consoleCommandSender(Server server) {
+        return server.getConsoleSender();
+    }
+
+    @Provides
+    Messenger messenger(Server server) {
+        return server.getMessenger();
+    }
+
+    @Provides
+    ScoreboardManager scoreboardManager(Server server) {
+        return server.getScoreboardManager();
+    }
+
+    @Provides
+    ServicesManager servicesManager(Server server) {
+        return server.getServicesManager();
+    }
+
+    @Provides
+    Collection<World> worlds(Server server) {
+        return server.worldsById().values();
+    }
+
+    @Provides
+    Map<UUID, World> worldsById(Server server) {
+        return server.worldsById();
+    }
+
+    @Provides
+    Map<String, World> worldsByName(Server server) {
+        return server.worldsByName();
+    }
+
+    @Provides
+    Collection<Player> onlinePlayers(Server server) {
+        return (Collection<Player>) server.getOnlinePlayers();
+    }
+
+    @Provides
+    Map<UUID, Player> playersById(Server server) {
+        return server.playersById();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
--- a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
@@ -12,6 +12,7 @@ import org.bukkit.ChatColor;
 import org.bukkit.command.CommandSender;
 import org.bukkit.event.Event;
 import org.bukkit.event.HandlerList;
+import org.bukkit.event.RegisteredHandler;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.RegisteredListener;
 import org.bukkit.plugin.TimedRegisteredListener;
@@ -36,7 +37,7 @@ public class TimingsCommand extends BukkitCommand {
             sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
             return false;
         }
-        if (!sender.getServer().getPluginManager().useTimings()) {
+        if (!sender.getServer().pluginProfiling()) {
             sender.sendMessage("Please enable timings by setting \"settings.plugin-profiling\" to true in bukkit.yml");
             return true;
         }
@@ -44,7 +45,7 @@ public class TimingsCommand extends BukkitCommand {
         boolean separate = "separate".equalsIgnoreCase(args[0]);
         if ("reset".equalsIgnoreCase(args[0])) {
             for (HandlerList handlerList : HandlerList.getHandlerLists()) {
-                for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
+                for (RegisteredHandler listener : handlerList.getRegisteredListeners()) {
                     if (listener instanceof TimedRegisteredListener) {
                         ((TimedRegisteredListener)listener).reset();
                     }
diff --git a/src/main/java/org/bukkit/event/BoundEventHandler.java b/src/main/java/org/bukkit/event/BoundEventHandler.java
new file mode 100644
index 0000000..0fd01db
--- /dev/null
+++ b/src/main/java/org/bukkit/event/BoundEventHandler.java
@@ -0,0 +1,74 @@
+package org.bukkit.event;
+
+import java.util.Objects;
+
+import tc.oc.minecraft.api.event.Listener;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A {@link RegisteredHandler} associated with a {@link Listener}, that passes events
+ * to an {@link EventMethodExecutor}, along with that listener.
+ */
+public class BoundEventHandler<T extends Event> implements RegisteredHandler<T> {
+
+    private final EventHandlerMeta<T> meta;
+    private final EventExecutor<T> executor;
+    private final Listener listener;
+
+    public BoundEventHandler(EventMethodExecutor<T> executor, Listener listener) {
+        this(executor.meta(), executor, listener);
+
+        if(!executor.method().getDeclaringClass().isInstance(listener)) {
+            throw new IllegalArgumentException(
+                "Cannot bind event handler method " + executor +
+                " to listener of type " + listener.getClass().getName() +
+                " because it is not assignable to " + executor.method().getDeclaringClass().getName()
+            );
+        }
+    }
+
+    public BoundEventHandler(EventHandlerMeta<T> meta, EventExecutor<T> executor, Listener listener) {
+        this.meta = checkNotNull(meta);
+        this.executor = checkNotNull(executor);
+        this.listener = checkNotNull(listener);
+    }
+
+    @Override
+    public EventHandlerMeta<T> meta() {
+        return meta;
+    }
+
+    public Listener listener() {
+        return listener;
+    }
+
+    @Override
+    public void callEvent(T event) throws EventException {
+        executor.execute(listener, event);
+    }
+
+    @Override
+    final public int hashCode() {
+        return Objects.hash(meta, executor, listener);
+    }
+
+    @Override
+    final public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof BoundEventHandler)) return false;
+        final BoundEventHandler that = (BoundEventHandler) obj;
+        return this.meta.equals(that.meta) &&
+               this.executor.equals(that.executor) &&
+               this.listener == that.listener;
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{meta=" + meta +
+               " executor=" + executor +
+               " listener=" + listener +
+               "}";
+    }
+}
diff --git a/src/main/java/org/bukkit/event/CallableEventHandler.java b/src/main/java/org/bukkit/event/CallableEventHandler.java
new file mode 100644
index 0000000..fa77ef1
--- /dev/null
+++ b/src/main/java/org/bukkit/event/CallableEventHandler.java
@@ -0,0 +1,101 @@
+package org.bukkit.event;
+
+import tc.oc.exception.ExceptionHandler;
+import tc.oc.exception.LoggingExceptionHandler;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A general {@link RegisteredHandler} that passes events to a {@link EventCallable},
+ * and reports uncaught exceptions to a {@link ExceptionHandler}.
+ */
+public class CallableEventHandler<T extends Event> implements RegisteredHandler<T> {
+
+    private final EventHandlerMeta<T> meta;
+    private final EventCallable<? super T> callable;
+    private final ExceptionHandler exceptionHandler;
+
+    public CallableEventHandler(EventHandlerMeta<T> meta, EventCallable<? super T> callable, ExceptionHandler exceptionHandler) {
+        this.meta = checkNotNull(meta);
+        this.callable = checkNotNull(callable);
+        this.exceptionHandler = checkNotNull(exceptionHandler);
+    }
+
+    @Override
+    public EventHandlerMeta<T> meta() {
+        return meta;
+    }
+
+    @Override
+    public void callEvent(T event) throws EventException {
+        try {
+            callable.callEvent(event);
+        } catch(EventException ex) {
+            throw ex;
+        } catch(Throwable ex) {
+            exceptionHandler.handleException(
+                ex,
+                "Exception dispatching " + event.getEventName() +
+                " to " + callable.getClass().getSimpleName()
+            );
+        }
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{meta=" + meta +
+               " callable=" + callable +
+               "}";
+    }
+
+    public static <T extends Event> CallableEventHandler<T> create(Class<T> eventClass, EventPriority priority, boolean ignoreCancelled, EventCallable<? super T> handler, ExceptionHandler exceptionHandler) {
+        return new CallableEventHandler<>(new EventHandlerMeta<>(eventClass, priority, ignoreCancelled), handler, exceptionHandler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> create(Class<T> eventClass, EventPriority priority, EventCallable<? super T> handler, ExceptionHandler exceptionHandler) {
+        return create(eventClass, priority, false, handler, exceptionHandler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> create(Class<T> eventClass, EventCallable<? super T> handler, ExceptionHandler exceptionHandler) {
+        return create(eventClass, EventPriority.NORMAL, handler, exceptionHandler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> create(Class<T> eventClass, EventPriority priority, boolean ignoreCancelled, EventCallable<? super T> handler) {
+        return create(eventClass, priority, ignoreCancelled, handler, LoggingExceptionHandler.forGlobalLogger());
+    }
+
+    public static <T extends Event> CallableEventHandler<T> create(Class<T> eventClass, EventPriority priority, EventCallable<? super T> handler) {
+        return create(eventClass, priority, false, handler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> create(Class<T> eventClass, EventCallable<? super T> handler) {
+        return create(eventClass, EventPriority.NORMAL, handler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> register(Class<T> eventClass, EventPriority priority, boolean ignoreCancelled, EventCallable<? super T> handler, ExceptionHandler exceptionHandler) {
+        final CallableEventHandler<T> registeredHandler = create(eventClass, priority, ignoreCancelled, handler, exceptionHandler);
+        Event.register(eventClass, registeredHandler);
+        return registeredHandler;
+    }
+
+    public static <T extends Event> CallableEventHandler<T> register(Class<T> eventClass, EventPriority priority, EventCallable<? super T> handler, ExceptionHandler exceptionHandler) {
+        return register(eventClass, priority, false, handler, exceptionHandler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> register(Class<T> eventClass, EventCallable<? super T> handler, ExceptionHandler exceptionHandler) {
+        return register(eventClass, EventPriority.NORMAL, handler, exceptionHandler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> register(Class<T> eventClass, EventPriority priority, boolean ignoreCancelled, EventCallable<? super T> handler) {
+        return register(eventClass, priority, ignoreCancelled, handler, LoggingExceptionHandler.forGlobalLogger());
+    }
+
+    public static <T extends Event> CallableEventHandler<T> register(Class<T> eventClass, EventPriority priority, EventCallable<? super T> handler) {
+        return register(eventClass, priority, false, handler);
+    }
+
+    public static <T extends Event> CallableEventHandler<T> register(Class<T> eventClass, EventCallable<? super T> handler) {
+        return register(eventClass, EventPriority.NORMAL, handler);
+    }
+}
diff --git a/src/main/java/org/bukkit/event/Event.java b/src/main/java/org/bukkit/event/Event.java
--- a/src/main/java/org/bukkit/event/Event.java
+++ b/src/main/java/org/bukkit/event/Event.java
@@ -1,5 +1,17 @@
 package org.bukkit.event;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.concurrent.ExecutionException;
+import javax.annotation.Nullable;
+
+import com.google.common.base.Throwables;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.util.concurrent.UncheckedExecutionException;
+import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.PluginManager;
 
 /**
@@ -47,7 +59,132 @@ public abstract class Event {
         return name;
     }
 
-    public abstract HandlerList getHandlers();
+    public boolean isCancelled() {
+        return false;
+    }
+
+    @Nullable EventCallable yielder = null;
+
+    /**
+     * Can this event be yielded to right now?
+     */
+    public boolean canYield() {
+        return yielder != null;
+    }
+
+    /**
+     * Continue dispatch of this event, returning after higher priority handlers,
+     * and the "body" (primary functionality) of the event, have executed.
+     *
+     * This method can only be called from within a handler for this event, and no
+     * more than once per handler. If a handler does not yield, dispatch will
+     * continue when the handler returns.
+     *
+     * @throws EventException if any exception is thrown from the event body.
+     *                        Handlers must NOT prevent the propagation of this
+     *                        exception, as it is used to propagate the causing
+     *                        exception to the event call site.
+     *
+     * @throws IllegalStateException if this event is not currently being dispatched,
+     *                               or if the current handler has already yielded to
+     *                               this event.
+     */
+    public void yield() throws EventException {
+        if(!canYield()) {
+            throw new IllegalStateException(
+                "This event has already been yielded to, or is not currently being dispatched"
+            );
+        }
+
+        try {
+            final EventCallable yielder = this.yielder;
+            this.yielder = null;
+            yielder.callEvent(this);
+        } catch(EventException e) {
+            throw e;
+        } catch(Throwable e) {
+            throw new EventException(e, this);
+        }
+    }
+
+    public static <T extends Event> void register(RegisteredHandler<T> handler) {
+        getHandlerList(handler.meta().event()).register(handler);
+    }
+
+    public static <T extends Event> void register(Class<T> eventClass, RegisteredHandler<? super T> handler) {
+        getHandlerList(eventClass).register(handler);
+    }
+
+    public static <T extends Event> void unregister(RegisteredHandler<T> handler) {
+        getHandlerList(handler.meta().event()).unregister(handler);
+    }
+
+    /**
+     * Return the {@link HandlerList} for the given {@link Event} subtype
+     *
+     * This will search for an ancestor class containing a static method with this name and signature:
+     *
+     *     HandlerList getHandlerList();
+     *
+     * Or a static field with this name and type:
+     *
+     *     HandlerList handlers;
+     *
+     * The accessibility of the method/field does not matter.
+     *
+     * Results are cached per event type, so searches after the first are fairly quick
+     * and do not perform any reflective operations.
+     *
+     * @throws IllegalArgumentException if no HandlerList can be found for the event class
+     */
+    public static <T extends Event> HandlerList<T> getHandlerList(Class<T> type) {
+        try {
+            return HANDLER_LISTS.get(type);
+        } catch(ExecutionException | UncheckedExecutionException e) {
+            throw Throwables.propagate(e.getCause());
+        }
+    }
+
+    private static final LoadingCache<Class<? extends Event>, HandlerList> HANDLER_LISTS = CacheBuilder.newBuilder().build(new CacheLoader<Class<? extends Event>, HandlerList>() {
+        @Override
+        public HandlerList load(Class<? extends Event> clazz) throws Exception {
+            Method method = null;
+            try {
+                method = clazz.getDeclaredMethod("getHandlerList");
+            } catch(NoSuchMethodException ignored) {}
+            if(method != null && Modifier.isStatic(method.getModifiers()) && HandlerList.class.isAssignableFrom(method.getReturnType())) {
+                method.setAccessible(true);
+                return (HandlerList) method.invoke(null);
+            }
+
+            Field field = null;
+            try {
+                field = clazz.getDeclaredField("handlers");
+            } catch(NoSuchFieldException ignored) {}
+            if(field != null && Modifier.isStatic(field.getModifiers()) && HandlerList.class.isAssignableFrom(field.getType())) {
+                field.setAccessible(true);
+                return (HandlerList) field.get(null);
+            }
+
+            final Class<?> up = clazz.getSuperclass();
+            if(up != null && !up.equals(Event.class) && Event.class.isAssignableFrom(up)) {
+                return HANDLER_LISTS.get(up.asSubclass(Event.class));
+            }
+
+            throw new IllegalArgumentException("Unable to find HandlerList for event type " + clazz.getName());
+        }
+    });
+
+    /**
+     * Return the {@link HandlerList} for this event.
+     *
+     * By default, this calls {@link #getHandlerList(Class)} with this object's class.
+     * Since this method is called every time the event is dispatched, it may be a
+     * worthwhile optimization to override it and return the list directly.
+     */
+    public HandlerList getHandlers() {
+        return getHandlerList(getClass());
+    }
 
     /**
      * Any custom event that should not by synchronized with other events must
diff --git a/src/main/java/org/bukkit/event/EventBody.java b/src/main/java/org/bukkit/event/EventBody.java
new file mode 100644
index 0000000..7abbbbb
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventBody.java
@@ -0,0 +1,11 @@
+package org.bukkit.event;
+
+/**
+ * Encapsulates the primary functionality of an event.
+ *
+ * @see EventBus#callEvent
+ */
+public interface EventBody<T extends Event, X extends Throwable> extends EventCallable<T> {
+    @Override
+    void callEvent(T event) throws X;
+}
diff --git a/src/main/java/org/bukkit/event/EventBus.java b/src/main/java/org/bukkit/event/EventBus.java
new file mode 100644
index 0000000..7fac014
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventBus.java
@@ -0,0 +1,55 @@
+package org.bukkit.event;
+
+import javax.annotation.Nullable;
+
+import tc.oc.exception.ExceptionHandler;
+
+public interface EventBus {
+
+    void callEvent(Event event) throws IllegalStateException;
+
+    void callEvent(Event event, @Nullable EventPriority priority);
+
+    <T extends Event, X extends Throwable> void callEvent(T event, @Nullable EventBody<? super T, X> body) throws X;
+
+    /**
+     * Dispatch the given event to all applicable {@link RegisteredHandler}s,
+     * then (optionally) to the given {@link EventBody}.
+     *
+     * Event handlers are usually created from an {@link EventRegistry}, and registered with a {@link HandlerList}.
+     *
+     * Event handlers are called in order of their {@link EventPriority}, from lowest to highest,
+     * before the body of the event is executed. If an event handler calls {@link Event#yield()},
+     * the following handlers, and the event body, will run before it returns. If a handler does
+     * not yield, dispatch of the event will continue after the handler returns.
+     *
+     * Exceptions thrown from event handlers are reported to an {@link ExceptionHandler}.
+     * The exception does NOT prevent other handlers, or the event body, from running.
+     *
+     * Exceptions thrown from the event body are propagated out of this method
+     * (provided that yielding handlers propagate the {@link EventException} wrapping it).
+     *
+     * @param event         Event object passed to handlers
+     * @param priority      If non-null, only call handlers at this priority level
+     * @param body          Body of the actual event, or null for a no-op event
+     *
+     * @throws IllegalStateException Thrown when an asynchronous event is
+     *     fired from synchronous code.
+     *     <p>
+     *     <i>Note: This is best-effort basis, and should not be used to test
+     *     synchronized state. This is an indicator for flawed flow logic.</i>
+     */
+    <T extends Event, X extends Throwable> void callEvent(T event, @Nullable EventPriority priority, @Nullable EventBody<? super T, X> body) throws X;
+
+    /**
+     * Dispatch the given event to a single {@link RegisteredHandler}.
+     *
+     * If the handler yields, the given body is called (if it's non-null), and this method returns true.
+     * If the handler does not yield, the body is NOT called, and this method returns false.
+     * If the handler returns false from {@link RegisteredHandler#canHandle}, then it is not called, and the method returns false.
+     *
+     * Exceptions thrown from the event body are propagated out of this method
+     * (provided that yielding handlers propagate the {@link EventException} wrapping it).
+     */
+    <T extends Event, X extends Throwable> boolean callEventHandler(T event, @Nullable EventPriority priority, RegisteredHandler<? super T> handler, @Nullable EventBody<? super T, X> body) throws X;
+}
diff --git a/src/main/java/org/bukkit/event/EventCallable.java b/src/main/java/org/bukkit/event/EventCallable.java
new file mode 100644
index 0000000..e56fcf6
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventCallable.java
@@ -0,0 +1,11 @@
+package org.bukkit.event;
+
+/**
+ * Something that is called with an {@link Event}, has several uses.
+ */
+public interface EventCallable<T extends Event> {
+
+    void callEvent(T event) throws Throwable;
+
+    EventCallable<?> EMPTY = event -> {};
+}
diff --git a/src/main/java/org/bukkit/event/EventException.java b/src/main/java/org/bukkit/event/EventException.java
--- a/src/main/java/org/bukkit/event/EventException.java
+++ b/src/main/java/org/bukkit/event/EventException.java
@@ -1,5 +1,8 @@
 package org.bukkit.event;
 
+/**
+ * A wrapper used to propagate exceptions thrown from {@link EventBody}s
+ */
 public class EventException extends Exception {
     private static final long serialVersionUID = 3532808232324183999L;
     private final Event event;
diff --git a/src/main/java/org/bukkit/event/EventExecutor.java b/src/main/java/org/bukkit/event/EventExecutor.java
new file mode 100644
index 0000000..7bfa1c9
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventExecutor.java
@@ -0,0 +1,7 @@
+package org.bukkit.event;
+
+import tc.oc.minecraft.api.event.Listener;
+
+public interface EventExecutor<T extends Event> {
+    void execute(Listener listener, T event) throws EventException;
+}
diff --git a/src/main/java/org/bukkit/event/EventHandlerMeta.java b/src/main/java/org/bukkit/event/EventHandlerMeta.java
new file mode 100644
index 0000000..54f89ac
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventHandlerMeta.java
@@ -0,0 +1,120 @@
+package org.bukkit.event;
+
+import java.lang.reflect.Method;
+import java.util.Objects;
+import javax.annotation.Nullable;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Parameters for event handler registration
+ */
+public class EventHandlerMeta<T extends Event> {
+
+    private final Class<T> event;
+    private final EventPriority priority;
+    private final boolean ignoreCancelled;
+
+    public EventHandlerMeta(Class<T> event, EventPriority priority, boolean ignoreCancelled) {
+        this.event = checkNotNull(event);
+        this.priority = checkNotNull(priority);
+        this.ignoreCancelled = ignoreCancelled;
+    }
+
+    /**
+     * Base {@link Event} type that this handler can handle
+     */
+    public Class<T> event() {
+        return event;
+    }
+
+    /**
+     * Priority level at which this handler should be called
+     */
+    public EventPriority priority() {
+        return priority;
+    }
+
+    /**
+    * Whether this handler accepts cancelled events
+    */
+    public boolean ignoreCancelled() {
+        return ignoreCancelled;
+    }
+
+    public boolean canHandle(Event event, @Nullable EventPriority priority) {
+        return this.event.isInstance(event) &&
+               (priority == null || priority.equals(this.priority)) &&
+               !(event.isCancelled() && this.ignoreCancelled);
+    }
+
+    public boolean canCall(Method method) {
+        return method.getParameterTypes().length == 1 &&
+               method.getParameterTypes()[0].isAssignableFrom(event());
+    }
+
+    public void assertCanCall(Method method) {
+        if(!canCall(method)) {
+            throw new IllegalArgumentException(
+                "Invalid event handler method signature " + method.toGenericString() +
+                " in " + method.getDeclaringClass().getName()
+            );
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(event, priority, ignoreCancelled);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof EventHandlerMeta)) return false;
+        final EventHandlerMeta that = (EventHandlerMeta) obj;
+        return this.event.equals(that.event()) &&
+               this.priority.equals(that.priority()) &&
+               this.ignoreCancelled == that.ignoreCancelled();
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{event=" + event.getSimpleName() +
+               " priority=" + priority.name() +
+               " ignoreCancelled=" + ignoreCancelled +
+               "}";
+    }
+
+    /**
+     * Create an {@link EventHandlerMeta} for the given event class, copying other
+     * parameters from the given {@link EventHandler} annotation.
+     */
+    public static <T extends Event> EventHandlerMeta<T> forAnnotation(Class<T> event, EventHandler annotation) {
+        return new EventHandlerMeta<>(event, annotation.priority(), annotation.ignoreCancelled());
+    }
+
+    /**
+     * Reflect on the given {@link Method} and create a {@link EventHandlerMeta} for it,
+     * using the method's signature and annotations.
+     *
+     * If the method is not annotated as an {@link EventHandler}, return null.
+     */
+    public static @Nullable EventHandlerMeta<?> forMethod(Method method) {
+        if(method.isBridge() || method.isSynthetic()) return null;
+
+        final EventHandler annotation = method.getAnnotation(EventHandler.class);
+        if(annotation == null) return null;
+
+        final Class<?> eventClass;
+        if (method.getParameterTypes().length != 1 || !Event.class.isAssignableFrom(eventClass = method.getParameterTypes()[0])) {
+            throw new IllegalArgumentException("Invalid @EventHandler method " + method.toGenericString() +
+                                               " in " + method.getDeclaringClass().getName());
+        }
+
+        // Make sure the event has a HandlerList
+        Event.getHandlerList((Class<? extends Event>) eventClass);
+
+        return forAnnotation(eventClass.asSubclass(Event.class), annotation);
+    }
+}
diff --git a/src/main/java/org/bukkit/event/EventMethodExecutor.java b/src/main/java/org/bukkit/event/EventMethodExecutor.java
new file mode 100644
index 0000000..ac3afad
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventMethodExecutor.java
@@ -0,0 +1,119 @@
+package org.bukkit.event;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Objects;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+
+import tc.oc.exception.ExceptionHandler;
+import tc.oc.minecraft.api.event.Listener;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * An {@link EventExecutor} that reflectively calls an instance {@link Method}
+ * on the {@link Listener} passed to it with the event.
+ *
+ * Events that do not match the provided {@link EventHandlerMeta} are silently ignored.
+ *
+ * Exceptions thrown by the method are passed to the provided {@link ExceptionHandler},
+ * except for {@link EventException}, which is propagated.
+ */
+public class EventMethodExecutor<T extends Event> implements EventExecutor<T> {
+
+    private final EventHandlerMeta<T> meta;
+    private final Method method;
+    private final ExceptionHandler exceptionHandler;
+
+    public EventMethodExecutor(EventHandlerMeta<T> meta, Method method, ExceptionHandler exceptionHandler) {
+        this.meta = checkNotNull(meta);
+        this.method = checkNotNull(method);
+        this.exceptionHandler = checkNotNull(exceptionHandler);
+
+        this.meta.assertCanCall(this.method);
+        this.method.setAccessible(true);
+    }
+
+    public EventHandlerMeta<T> meta() {
+        return meta;
+    }
+
+    public Method method() {
+        return method;
+    }
+
+    public BoundEventHandler<T> bind(Listener listener) {
+        return new BoundEventHandler<>(meta, this, listener);
+    }
+
+    public void execute(Listener listener, T event) throws EventException {
+        if(meta.canHandle(event, null)) {
+            try {
+                method.invoke(listener, event);
+            } catch(InvocationTargetException ex) {
+                if(ex.getCause() instanceof EventException) {
+                    throw (EventException) ex.getCause();
+                }
+                handleException(listener, event, ex.getCause());
+            } catch(Throwable ex) {
+                handleException(listener, event, ex);
+            }
+        }
+    }
+
+    protected void handleException(Listener listener, T event, Throwable ex) {
+        exceptionHandler.handleException(ex, "Exception dispatching event " + event.getEventName() + " to " + listener);
+    }
+
+    @Override
+    final public int hashCode() {
+        return Objects.hash(meta, method);
+    }
+
+    @Override
+    final public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof EventMethodExecutor)) return false;
+        final EventMethodExecutor that = (EventMethodExecutor) obj;
+        return this.meta.equals(that.meta) &&
+               this.method.equals(that.method);
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{meta=" + meta +
+               " method=" + method +
+               "}";
+    }
+
+    /**
+     * Reflect on the given {@link Method} and create a {@link EventMethodExecutor} for it,
+     * using the method's signature and annotations.
+     *
+     * If the method is not annotated as an {@link EventHandler}, return null.
+     */
+    public static @Nullable EventMethodExecutor forMethod(Method method, ExceptionHandler exceptionHandler) {
+        final EventHandlerMeta<?> meta = EventHandlerMeta.forMethod(method);
+        if(meta == null) return null;
+        return new EventMethodExecutor<>(meta, method, exceptionHandler);
+    }
+
+    /**
+     * Create {@link EventMethodExecutor}s for all event handler methods found in the given {@link Listener} class.
+     *
+     * This includes any methods inherited from superclasses or interfaces.
+     */
+    public static Stream<EventMethodExecutor<?>> forMethods(Class<? extends Listener> listener, ExceptionHandler exceptionHandler) {
+        return Stream.concat(
+            Stream.of(listener.getDeclaredMethods())
+                  .map(method -> forMethod(method, exceptionHandler))
+                  .filter(Objects::nonNull),
+            Stream.concat(Stream.of(listener.getSuperclass()),
+                          Stream.of(listener.getInterfaces()))
+                  .filter(ancestor -> ancestor != null && Listener.class.isAssignableFrom(ancestor))
+                  .flatMap(ancestor -> forMethods((Class<? extends Listener>) ancestor, exceptionHandler))
+        );
+    }
+}
diff --git a/src/main/java/org/bukkit/event/EventRegistry.java b/src/main/java/org/bukkit/event/EventRegistry.java
new file mode 100644
index 0000000..dcf4a37
--- /dev/null
+++ b/src/main/java/org/bukkit/event/EventRegistry.java
@@ -0,0 +1,80 @@
+package org.bukkit.event;
+
+import java.lang.reflect.Method;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+
+import tc.oc.exception.ExceptionHandler;
+import tc.oc.minecraft.api.event.Listener;
+
+/**
+ * Service used to reflectively create and register {@link RegisteredHandler}s for {@link Listener}s.
+ *
+ * Handlers created through an {@link EventRegistry} retain a reference to that registry,
+ * allowing them to be unregistered all at once.
+ *
+ * An {@link EventRegistry} has an implicit {@link ExceptionHandler} that it uses to
+ * construct handlers, though this is not exposed in the base API.
+ */
+public interface EventRegistry extends tc.oc.minecraft.api.event.EventRegistry {
+
+    /**
+     * Create a {@link EventMethodExecutor} wrapping the given method.
+     *
+     * The method is not checked for annotations. The handler parameters
+     * are derived exclusively from the given {@link EventHandlerMeta}.
+     *
+     * @throws IllegalArgumentException if the method signature is not
+     *         compatible with the event parameters.
+     */
+    <T extends Event> EventMethodExecutor<T> createHandler(EventHandlerMeta<T> meta, Method method);
+
+    /**
+     * Reflect on the given {@link Method} and create a {@link EventMethodExecutor} for it,
+     * using the method's signature and annotations.
+     *
+     * If the method is not annotated as an {@link EventHandler}, return null.
+     *
+     * @throws IllegalArgumentException if the method signature is not
+     *         compatible with the event parameters.
+     */
+    @Nullable EventMethodExecutor<?> createHandler(Method method);
+
+    /**
+     * Create a {@link BoundEventHandler} binding the given {@link EventExecutor} to the given {@link Listener}.
+     *
+     * This only creates the handler, it does not register it to receive any events.
+     *
+     * TODO: The executor could be created from a different registry.
+     * It's hard to prevent this while still supporting the old API.
+     */
+    <T extends Event> BoundEventHandler<T> bindHandler(EventHandlerMeta<T> meta, Listener listener, EventExecutor<T> executor);
+
+    /**
+     * Create a {@link BoundEventHandler} binding the given {@link EventMethodExecutor} to the given {@link Listener}.
+     *
+     * This only creates the handler, it does not register it to receive any events.
+     *
+     * @throws IllegalArgumentException if the method does not belong to the listener
+     *
+     * TODO: The executor could be created from a different registry.
+     * It's hard to prevent this while still supporting the old API.
+     */
+    <T extends Event> BoundEventHandler<T> bindHandler(Listener listener, EventMethodExecutor<T> executor);
+
+    /**
+     * Create {@link EventMethodExecutor}s for all event handler methods found in the given {@link Listener} class.
+     *
+     * This includes any methods inherited from superclasses or interfaces.
+     */
+    Stream<EventMethodExecutor<?>> createHandlers(Class<? extends Listener> listener);
+
+    /**
+     * Create {@link BoundEventHandler}s for all event handler methods found in the given {@link Listener}.
+     *
+     * This includes any methods inherited from superclasses or interfaces.
+     *
+     * @see #createHandlers
+     */
+    Stream<BoundEventHandler<?>> bindHandlers(Listener listener);
+}
diff --git a/src/main/java/org/bukkit/event/HandlerList.java b/src/main/java/org/bukkit/event/HandlerList.java
--- a/src/main/java/org/bukkit/event/HandlerList.java
+++ b/src/main/java/org/bukkit/event/HandlerList.java
@@ -1,33 +1,33 @@
 package org.bukkit.event;
 
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.*;
 
 import java.util.*;
 import java.util.Map.Entry;
+import java.util.function.Predicate;
 
 /**
  * A list of event handlers, stored per-event. Based on lahwran's fevents.
  */
-public class HandlerList {
+public class HandlerList<T extends Event> {
 
     /**
      * Handler array. This field being an array is the key to this system's
      * speed.
      */
-    private volatile RegisteredListener[] handlers = null;
+    private volatile RegisteredHandler<? super T>[] handlers = null;
 
     /**
      * Dynamic handler lists. These are changed using register() and
      * unregister() and are automatically baked to the handlers array any time
      * they have changed.
      */
-    private final EnumMap<EventPriority, ArrayList<RegisteredListener>> handlerslots;
+    private final EnumMap<EventPriority, List<RegisteredHandler<? super T>>> handlerslots;
 
     /**
      * List of all HandlerLists which have been created, for use in bakeAll()
      */
-    private static ArrayList<HandlerList> allLists = new ArrayList<HandlerList>();
+    private static final ArrayList<HandlerList<?>> allLists = new ArrayList<>();
 
     /**
      * Bake all handler lists. Best used just after all normal event
@@ -47,11 +47,9 @@ public class HandlerList {
      */
     public static void unregisterAll() {
         synchronized (allLists) {
-            for (HandlerList h : allLists) {
+            for (HandlerList<?> h : allLists) {
                 synchronized (h) {
-                    for (List<RegisteredListener> list : h.handlerslots.values()) {
-                        list.clear();
-                    }
+                    h.handlerslots.values().forEach(List::clear);
                     h.handlers = null;
                 }
             }
@@ -64,11 +62,8 @@ public class HandlerList {
      * @param plugin plugin to unregister
      */
     public static void unregisterAll(Plugin plugin) {
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                h.unregister(plugin);
-            }
-        }
+        unregisterAll(handler -> handler instanceof RegisteredListener &&
+                                 plugin == ((RegisteredListener) handler).getPlugin());
     }
 
     /**
@@ -77,9 +72,14 @@ public class HandlerList {
      * @param listener listener to unregister
      */
     public static void unregisterAll(Listener listener) {
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                h.unregister(listener);
+        unregisterAll(handler -> handler instanceof BoundEventHandler &&
+                                 listener == ((BoundEventHandler) handler).listener());
+    }
+
+    public static void unregisterAll(Predicate<RegisteredHandler<?>> filter) {
+        synchronized(allLists) {
+            for(HandlerList<?> list : allLists) {
+                list.unregister(filter);
             }
         }
     }
@@ -90,9 +90,9 @@ public class HandlerList {
      * The HandlerList is then added to meta-list for use in bakeAll()
      */
     public HandlerList() {
-        handlerslots = new EnumMap<EventPriority, ArrayList<RegisteredListener>>(EventPriority.class);
+        handlerslots = new EnumMap<>(EventPriority.class);
         for (EventPriority o : EventPriority.values()) {
-            handlerslots.put(o, new ArrayList<RegisteredListener>());
+            handlerslots.put(o, new ArrayList<>());
         }
         synchronized (allLists) {
             allLists.add(this);
@@ -102,22 +102,30 @@ public class HandlerList {
     /**
      * Register a new listener in this handler list
      *
-     * @param listener listener to register
+     * @param handler listener to register
      */
-    public synchronized void register(RegisteredListener listener) {
-        if (handlerslots.get(listener.getPriority()).contains(listener))
-            throw new IllegalStateException("This listener is already registered to priority " + listener.getPriority().toString());
+    public synchronized void register(RegisteredHandler<? super T> handler) {
+        final EventPriority priority = handler.meta().priority();
+        if(handlerslots.get(priority).contains(handler)) {
+            throw new IllegalStateException("Event handler " + handler +
+                                            " is already registered at priority " + priority);
+        }
         handlers = null;
-        handlerslots.get(listener.getPriority()).add(listener);
+        handlerslots.get(priority).add(handler);
+    }
+
+    // For legacy binary compatibility
+    public synchronized void register(RegisteredListener listener) {
+        register((RegisteredHandler) listener);
     }
 
     /**
      * Register a collection of new listeners in this handler list
      *
-     * @param listeners listeners to register
+     * @param handlers listeners to register
      */
-    public void registerAll(Collection<RegisteredListener> listeners) {
-        for (RegisteredListener listener : listeners) {
+    public void registerAll(Collection<RegisteredHandler<? super T>> handlers) {
+        for(RegisteredHandler<? super T> listener : handlers) {
             register(listener);
         }
     }
@@ -125,10 +133,10 @@ public class HandlerList {
     /**
      * Remove a listener from a specific order slot
      *
-     * @param listener listener to remove
+     * @param handler listener to remove
      */
-    public synchronized void unregister(RegisteredListener listener) {
-        if (handlerslots.get(listener.getPriority()).remove(listener)) {
+    public synchronized void unregister(RegisteredHandler<? super T> handler) {
+        if(handlerslots.get(handler.meta().priority()).remove(handler)) {
             handlers = null;
         }
     }
@@ -139,16 +147,20 @@ public class HandlerList {
      * @param plugin plugin to remove
      */
     public synchronized void unregister(Plugin plugin) {
+        unregister(el -> el instanceof RegisteredListener && ((RegisteredListener) el).getPlugin().equals(plugin));
+    }
+
+    public synchronized void unregister(Predicate<? super RegisteredHandler<? super T>> filter) {
         boolean changed = false;
-        for (List<RegisteredListener> list : handlerslots.values()) {
-            for (ListIterator<RegisteredListener> i = list.listIterator(); i.hasNext();) {
-                if (i.next().getPlugin().equals(plugin)) {
+        for(List<RegisteredHandler<? super T>> list : handlerslots.values()) {
+            for(ListIterator<RegisteredHandler<? super T>> i = list.listIterator(); i.hasNext();) {
+                if (filter.test(i.next())) {
                     i.remove();
                     changed = true;
                 }
             }
         }
-        if (changed) handlers = null;
+        if(changed) handlers = null;
     }
 
     /**
@@ -157,28 +169,15 @@ public class HandlerList {
      * @param listener listener to remove
      */
     public synchronized void unregister(Listener listener) {
-        boolean changed = false;
-        for (List<RegisteredListener> list : handlerslots.values()) {
-            for (ListIterator<RegisteredListener> i = list.listIterator(); i.hasNext();) {
-                if (i.next().getListener().equals(listener)) {
-                    i.remove();
-                    changed = true;
-                }
-            }
-        }
-        if (changed) handlers = null;
+        unregister(handler -> handler instanceof BoundEventHandler &&
+                              listener == ((BoundEventHandler) handler).listener());
     }
 
     /**
      * Bake HashMap and ArrayLists to 2d array - does nothing if not necessary
      */
-    public synchronized void bake() {
-        if (handlers != null) return; // don't re-bake when still valid
-        List<RegisteredListener> entries = new ArrayList<RegisteredListener>();
-        for (Entry<EventPriority, ArrayList<RegisteredListener>> entry : handlerslots.entrySet()) {
-            entries.addAll(entry.getValue());
-        }
-        handlers = entries.toArray(new RegisteredListener[entries.size()]);
+    public void bake() {
+        getRegisteredListeners();
     }
 
     /**
@@ -186,10 +185,25 @@ public class HandlerList {
      *
      * @return the array of registered listeners
      */
-    public RegisteredListener[] getRegisteredListeners() {
-        RegisteredListener[] handlers;
-        while ((handlers = this.handlers) == null) bake(); // This prevents fringe cases of returning null
-        return handlers;
+    public RegisteredHandler<? super T>[] getRegisteredListeners() {
+        // Try without locking first
+        RegisteredHandler<? super T>[] handlers = this.handlers;
+        if(handlers != null) return handlers;
+
+        synchronized(this) {
+            handlers = this.handlers;
+            if(handlers != null) return handlers;
+
+            handlers = new RegisteredHandler[handlerslots.values().stream().mapToInt(List::size).sum()];
+            int i = 0;
+            for (Entry<EventPriority, List<RegisteredHandler<? super T>>> entry : handlerslots.entrySet()) {
+                for(RegisteredHandler<? super T> handler : entry.getValue()) {
+                    handlers[i++] = handler;
+                }
+            }
+            this.handlers = handlers;
+            return handlers;
+        }
     }
 
     /**
@@ -200,21 +214,26 @@ public class HandlerList {
      * @return the list of registered listeners
      */
     public static ArrayList<RegisteredListener> getRegisteredListeners(Plugin plugin) {
-        ArrayList<RegisteredListener> listeners = new ArrayList<RegisteredListener>();
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                synchronized (h) {
-                    for (List<RegisteredListener> list : h.handlerslots.values()) {
-                        for (RegisteredListener listener : list) {
-                            if (listener.getPlugin().equals(plugin)) {
-                                listeners.add(listener);
-                            }
-                        }
+        final ArrayList<RegisteredListener> results = new ArrayList<RegisteredListener>();
+        synchronized(allLists) {
+            for(HandlerList<?> list : allLists) {
+                list.collectRegisteredListeners(plugin, results);
+            }
+        }
+        return results;
+    }
+
+    private synchronized void collectRegisteredListeners(Plugin plugin, List<RegisteredListener> results) {
+        for(List<RegisteredHandler<? super T>> handlers : handlerslots.values()) {
+            for(RegisteredHandler<? super T> handler : handlers) {
+                if(handler instanceof RegisteredListener) {
+                    final RegisteredListener rl = (RegisteredListener) handler;
+                    if(plugin.equals(rl.getPlugin())) {
+                        results.add(rl);
                     }
                 }
             }
         }
-        return listeners;
     }
 
     /**
diff --git a/src/main/java/org/bukkit/event/RegisteredHandler.java b/src/main/java/org/bukkit/event/RegisteredHandler.java
new file mode 100644
index 0000000..bd0a7be
--- /dev/null
+++ b/src/main/java/org/bukkit/event/RegisteredHandler.java
@@ -0,0 +1,22 @@
+package org.bukkit.event;
+
+import javax.annotation.Nullable;
+
+/**
+ * An event handler, i.e. an {@link EventCallable} that intercepts {@link Event}s.
+ */
+public interface RegisteredHandler<T extends Event> extends EventCallable<T> {
+
+    EventHandlerMeta<T> meta();
+
+    @Override
+    void callEvent(T event) throws EventException;
+
+    default boolean isEnabled() {
+        return true;
+    }
+
+    default boolean canHandle(Event event, @Nullable EventPriority priority) {
+        return isEnabled() && meta().canHandle(event, priority);
+    }
+}
diff --git a/src/main/java/org/bukkit/event/SimpleEventBus.java b/src/main/java/org/bukkit/event/SimpleEventBus.java
new file mode 100644
index 0000000..96dec8a
--- /dev/null
+++ b/src/main/java/org/bukkit/event/SimpleEventBus.java
@@ -0,0 +1,115 @@
+package org.bukkit.event;
+
+import javax.annotation.Nullable;
+
+public class SimpleEventBus implements EventBus {
+
+    private final Thread primaryThread;
+    private final Object lock;
+
+    public SimpleEventBus() {
+        this(null, null);
+    }
+
+    public SimpleEventBus(@Nullable Thread primaryThread, @Nullable Object lock) {
+        this.primaryThread = primaryThread != null ? primaryThread : Thread.currentThread();
+        this.lock = lock != null ? lock : new Object();
+    }
+
+    @Override
+    public void callEvent(Event event) {
+        callEvent(event, null, null);
+    }
+
+    @Override
+    public void callEvent(Event event, @Nullable EventPriority priority) {
+        callEvent(event, priority, null);
+    }
+
+    @Override
+    public <T extends Event, X extends Throwable> void callEvent(T event, @Nullable EventBody<? super T, X> body) throws X {
+        callEvent(event, null, body);
+    }
+
+    @Override
+    public <T extends Event, X extends Throwable> void callEvent(T event, @Nullable EventPriority priority, @Nullable EventBody<? super T, X> body) throws X {
+        if(event.isAsynchronous()) {
+            if(Thread.holdsLock(lock)) {
+                throw new IllegalStateException(event.getEventName() + " cannot be called asynchronously from inside synchronized code.");
+            }
+            if(Thread.currentThread().equals(primaryThread)) {
+                throw new IllegalStateException(event.getEventName() + " cannot be called asynchronously from primary thread.");
+            }
+            callEvent0(event, priority, body);
+        } else {
+            synchronized(lock) {
+                callEvent0(event, priority, body);
+            }
+        }
+    }
+
+    public <T extends Event, X extends Throwable> void callEvent0(T event, @Nullable EventPriority priority, @Nullable EventBody<? super T, X> body) throws X {
+        try {
+            callEvent0(event, priority, event.getHandlers().getRegisteredListeners(), 0, body);
+        } catch(EventException e) {
+            throw (X) e.getCause();
+        }
+    }
+
+    private <T extends Event, X extends Throwable> void callEvent0(T event, @Nullable EventPriority priority, RegisteredHandler<? super T>[] handlers, int index, @Nullable EventBody<? super T, X> body) throws EventException {
+        for(int i = index; i < handlers.length; i++) {
+            final RegisteredHandler<? super T> handler = handlers[i];
+            if(handler.canHandle(event, priority)) {
+                // When calling a handler, pass a continuation that recurses into this method
+                // with the current index, which will continue the loop. If the handler yields
+                // (which makes callEventHandler0 return true), then return immediately, since
+                // the nested call will have already finished the entire dispatch process.
+
+                // By only recursing when the handler yields, we avoid unnecessary stack growth,
+                // which can be appreciated when reading stack traces.
+
+                final int nextIndex = i + 1;
+                if(callEventHandler0(event, handler, ev -> callEvent0(event, priority, handlers, nextIndex, body))) return;
+            }
+        }
+
+        // If we get here, it means we got to the end of the handler array without any handler yielding.
+        // This will happen exactly once per event, in the inner-most call to this method. Any outer calls
+        // will return early in the loop above.
+        if(body != null) {
+            try {
+                body.callEvent(event);
+            } catch(Throwable ex) {
+                // Exceptions from the event body are wrapped and thrown all the way back
+                // to the start of the dispatch, where they are unwrapped and rethrown.
+                // For this to work, any yielding handlers need to let the EventException
+                // propagate from the yield() method.
+                throw new EventException(ex, event);
+            }
+        }
+    }
+
+    @Override
+    public <T extends Event, X extends Throwable> boolean callEventHandler(T event, @Nullable EventPriority priority, RegisteredHandler<? super T> handler, @Nullable EventBody<? super T, X> body) throws X {
+        if(handler.canHandle(event, priority)) {
+            try {
+                return callEventHandler0(event, handler, body);
+            } catch(EventException e) {
+                throw (X) e.getCause();
+            }
+        }
+        return false;
+    }
+
+    private <T extends Event> boolean callEventHandler0(T event, RegisteredHandler<? super T> handler, @Nullable EventCallable yielder) throws EventException {
+        final EventCallable oldYielder = event.yielder;
+        if(yielder == null) yielder = EventCallable.EMPTY;
+        event.yielder = yielder;
+        try {
+            handler.callEvent(event);
+            return event.yielder != yielder;
+        } finally {
+            event.yielder = oldYielder;
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/event/SimpleEventRegistry.java b/src/main/java/org/bukkit/event/SimpleEventRegistry.java
new file mode 100644
index 0000000..2b37b7a
--- /dev/null
+++ b/src/main/java/org/bukkit/event/SimpleEventRegistry.java
@@ -0,0 +1,88 @@
+package org.bukkit.event;
+
+import java.lang.reflect.Method;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import javax.inject.Inject;
+
+import tc.oc.exception.ExceptionHandler;
+import tc.oc.exception.LoggingExceptionHandler;
+import tc.oc.minecraft.api.event.Listener;
+
+public class SimpleEventRegistry implements EventRegistry {
+
+    private final ExceptionHandler exceptionHandler;
+
+    public SimpleEventRegistry() {
+        this(null);
+    }
+
+    @Inject public SimpleEventRegistry(@Nullable ExceptionHandler exceptionHandler) {
+        this.exceptionHandler = exceptionHandler != null ? exceptionHandler
+                                                         : LoggingExceptionHandler.forGlobalLogger();
+    }
+
+    @Override
+    public <T extends Event> BoundEventHandler<T> bindHandler(EventHandlerMeta<T> meta, Listener listener, EventExecutor<T> executor) {
+        return new OwnedEventHandler<>(meta, executor, listener);
+    }
+
+    @Override
+    public <T extends Event> BoundEventHandler<T> bindHandler(Listener listener, EventMethodExecutor<T> executor) {
+        return new OwnedEventHandler<>(executor, listener);
+    }
+
+    @Override
+    public <T extends Event> EventMethodExecutor<T> createHandler(EventHandlerMeta<T> meta, Method method) {
+        return new EventMethodExecutor<>(meta, method, exceptionHandler);
+    }
+
+    @Override
+    public EventMethodExecutor<?> createHandler(Method method) {
+        return EventMethodExecutor.forMethod(method, exceptionHandler);
+    }
+
+    @Override
+    public Stream<EventMethodExecutor<?>> createHandlers(Class<? extends Listener> listener) {
+        return EventMethodExecutor.forMethods(listener, exceptionHandler);
+    }
+
+    @Override
+    public Stream<BoundEventHandler<?>> bindHandlers(Listener listener) {
+        return createHandlers(listener.getClass())
+            .map(unbound -> bindHandler(listener, unbound));
+    }
+
+    @Override
+    public void registerListener(Listener listener) {
+        bindHandlers(listener).forEach(handler -> Event.register(handler));
+    }
+
+    @Override
+    public void unregisterListener(Listener listener) {
+        HandlerList.unregisterAll(handler -> handler instanceof OwnedEventHandler &&
+                                             this == ((OwnedEventHandler) handler).registry() &&
+                                             listener == ((OwnedEventHandler) handler).listener());
+    }
+
+    @Override
+    public void unregisterAll() {
+        HandlerList.unregisterAll(handler -> handler instanceof OwnedEventHandler &&
+                                             this == ((OwnedEventHandler) handler).registry());
+    }
+
+    private class OwnedEventHandler<T extends Event> extends BoundEventHandler<T> {
+
+        public OwnedEventHandler(EventMethodExecutor<T> executor, Listener listener) {
+            super(executor, listener);
+        }
+
+        public OwnedEventHandler(EventHandlerMeta<T> meta, EventExecutor<T> executor, Listener listener) {
+            super(meta, executor, listener);
+        }
+
+        SimpleEventRegistry registry() {
+            return SimpleEventRegistry.this;
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/permissions/PermissionBinder.java b/src/main/java/org/bukkit/permissions/PermissionBinder.java
new file mode 100644
index 0000000..bb0172e
--- /dev/null
+++ b/src/main/java/org/bukkit/permissions/PermissionBinder.java
@@ -0,0 +1,18 @@
+package org.bukkit.permissions;
+
+import com.google.inject.Binder;
+import com.google.inject.binder.LinkedBindingBuilder;
+import com.google.inject.multibindings.Multibinder;
+
+public class PermissionBinder {
+
+    private final Multibinder<Permission> permissions;
+
+    public PermissionBinder(Binder binder) {
+        this.permissions = Multibinder.newSetBinder(binder, Permission.class);
+    }
+
+    public LinkedBindingBuilder<Permission> bindPermission() {
+        return permissions.addBinding();
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ b/src/main/java/org/bukkit/plugin/EventExecutor.java
@@ -5,8 +5,9 @@ import org.bukkit.event.EventException;
 import org.bukkit.event.Listener;
 
 /**
- * Interface which defines the class for event call backs to plugins
+ * An event handler that belongs to a {@link Listener}, and must be passed an
+ * instance of the listener when handling an event.
  */
 public interface EventExecutor {
-    public void execute(Listener listener, Event event) throws EventException;
+    void execute(Listener listener, Event event) throws EventException;
 }
diff --git a/src/main/java/org/bukkit/plugin/EventExecutorAdapter.java b/src/main/java/org/bukkit/plugin/EventExecutorAdapter.java
new file mode 100644
index 0000000..5b03f17
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/EventExecutorAdapter.java
@@ -0,0 +1,18 @@
+package org.bukkit.plugin;
+
+import org.bukkit.event.*;
+import tc.oc.minecraft.api.event.Listener;
+
+class EventExecutorAdapter<T extends Event> implements org.bukkit.event.EventExecutor<T> {
+
+    private final EventExecutor legacy;
+
+    EventExecutorAdapter(EventExecutor legacy) {
+        this.legacy = legacy;
+    }
+
+    @Override
+    public void execute(Listener listener, T event) throws EventException {
+        legacy.execute((org.bukkit.event.Listener) listener, event);
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/Plugin.java b/src/main/java/org/bukkit/plugin/Plugin.java
--- a/src/main/java/org/bukkit/plugin/Plugin.java
+++ b/src/main/java/org/bukkit/plugin/Plugin.java
@@ -7,6 +7,7 @@ import java.util.logging.Logger;
 import org.bukkit.Server;
 import org.bukkit.command.TabExecutor;
 import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.event.EventRegistry;
 import org.bukkit.generator.ChunkGenerator;
 
 import com.avaje.ebean.EbeanServer;
@@ -93,6 +94,11 @@ public interface Plugin extends TabExecutor, tc.oc.minecraft.api.plugin.Plugin,
     public PluginLoader getPluginLoader();
 
     /**
+     * @return The {@link EventRegistry} belonging to this plugin.
+     */
+    EventRegistry eventRegistry();
+
+    /**
      * Returns the Server instance currently running this plugin
      *
      * @return Server running this plugin
diff --git a/src/main/java/org/bukkit/plugin/PluginBase.java b/src/main/java/org/bukkit/plugin/PluginBase.java
--- a/src/main/java/org/bukkit/plugin/PluginBase.java
+++ b/src/main/java/org/bukkit/plugin/PluginBase.java
@@ -1,5 +1,15 @@
 package org.bukkit.plugin;
 
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+import com.google.inject.Injector;
+import org.bukkit.event.EventRegistry;
+import org.bukkit.permissions.Permission;
+import tc.oc.minecraft.api.event.ListenerContext;
+import tc.oc.exception.ExceptionHandler;
+
 /**
  * Represents a base {@link Plugin}
  * <p>
@@ -7,6 +17,49 @@ package org.bukkit.plugin;
  * org.bukkit.plugin.java.JavaPlugin}
  */
 public abstract class PluginBase implements Plugin {
+
+    @Inject private Injector injector;
+    @Inject private PluginManager pluginManager;
+    @Inject private ExceptionHandler exceptionHandler;
+    @Inject private EventRegistry eventRegistry;
+
+    @Inject private Set<Permission> permissions;
+    @Inject private Provider<ListenerContext> listenerContext;
+
+    protected void assertInjected() {
+        if(injector == null) {
+            throw new IllegalStateException("Not available until plugin has been injected");
+        }
+    }
+
+    @Override
+    public Injector injector() {
+        assertInjected();
+        return injector;
+    }
+
+    @Override
+    public EventRegistry eventRegistry() {
+        assertInjected();
+        return eventRegistry;
+    }
+
+    @Override
+    public ExceptionHandler exceptionHandler() {
+        assertInjected();
+        return exceptionHandler;
+    }
+
+    protected final void preEnable() {
+        permissions.forEach(pluginManager::addPermission);
+        listenerContext.get().enable();
+    }
+
+    protected final void postDisable() {
+        listenerContext.get().disable();
+        permissions.forEach(pluginManager::removePermission);
+    }
+
     @Override
     public final int hashCode() {
         return getName().hashCode();
diff --git a/src/main/java/org/bukkit/plugin/PluginEventRegistry.java b/src/main/java/org/bukkit/plugin/PluginEventRegistry.java
new file mode 100644
index 0000000..bc06595
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/PluginEventRegistry.java
@@ -0,0 +1,57 @@
+package org.bukkit.plugin;
+
+import javax.inject.Inject;
+
+import tc.oc.minecraft.api.event.Listener;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventExecutor;
+import org.bukkit.event.EventHandlerMeta;
+import org.bukkit.event.EventMethodExecutor;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.SimpleEventRegistry;
+
+public class PluginEventRegistry extends SimpleEventRegistry {
+
+    private final Plugin plugin;
+
+    @Inject public PluginEventRegistry(Plugin plugin) {
+        super(plugin.exceptionHandler());
+        this.plugin = plugin;
+    }
+
+    @Override
+    public void registerListener(Listener listener) {
+        if(!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException(
+                "Plugin " + plugin.getDescription().getFullName() +
+                " attempted to register event listener while not enabled"
+            );
+        }
+        super.registerListener(listener);
+    }
+
+    @Override
+    public <T extends Event> RegisteredListener bindHandler(EventHandlerMeta<T> meta, Listener listener, EventExecutor<T> executor) {
+        return plugin.getServer().pluginProfiling()
+               ? new TimedRegisteredListener(meta, executor, listener, plugin, this)
+               : new RegisteredListener(meta, executor, listener, plugin, this);
+    }
+
+    @Override
+    public <T extends Event> RegisteredListener bindHandler(Listener listener, EventMethodExecutor<T> executor) {
+        return bindHandler(executor.meta(), listener, executor);
+    }
+
+    @Override
+    public void unregisterListener(Listener listener) {
+        HandlerList.unregisterAll(handler -> handler instanceof RegisteredListener &&
+                                             this == ((RegisteredListener) handler).registry &&
+                                             listener == ((RegisteredListener) handler).listener());
+    }
+
+    @Override
+    public void unregisterAll() {
+        HandlerList.unregisterAll(handler -> handler instanceof RegisteredListener &&
+                                             this == ((RegisteredListener) handler).registry);
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/PluginExceptionHandler.java b/src/main/java/org/bukkit/plugin/PluginExceptionHandler.java
new file mode 100644
index 0000000..d5a96b1
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/PluginExceptionHandler.java
@@ -0,0 +1,33 @@
+package org.bukkit.plugin;
+
+import java.util.logging.Level;
+import javax.inject.Inject;
+
+import tc.oc.exception.LoggingExceptionHandler;
+
+public class PluginExceptionHandler extends LoggingExceptionHandler {
+
+    private final Plugin plugin;
+
+    @Inject public PluginExceptionHandler(Plugin plugin) {
+        super(plugin.getLogger());
+        this.plugin = plugin;
+    }
+
+    @Override
+    public void handleException(Throwable exception, String message) {
+        if(exception instanceof AuthorNagException) {
+            if (plugin.isNaggable()) {
+                plugin.setNaggable(false);
+
+                plugin.getLogger().log(Level.SEVERE, String.format(
+                    "Nag author(s): '%s' of '%s' about the following: %s",
+                    plugin.getDescription().getAuthors(),
+                    plugin.getDescription().getFullName(),
+                    exception.getMessage()
+                ));
+            }
+        }
+        super.handleException(exception, message);
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/PluginInstanceModule.java b/src/main/java/org/bukkit/plugin/PluginInstanceModule.java
new file mode 100644
index 0000000..8c64d81
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/PluginInstanceModule.java
@@ -0,0 +1,22 @@
+package org.bukkit.plugin;
+
+import tc.oc.inject.ProtectedModule;
+
+/**
+ * Configures a {@link Plugin} instance
+ */
+public class PluginInstanceModule extends ProtectedModule {
+
+    private final Plugin plugin;
+
+    public PluginInstanceModule(Plugin plugin) {
+        this.plugin = plugin;
+    }
+
+    @Override
+    protected void configure() {
+        install(new PluginModule());
+        bind(Plugin.class).toInstance(plugin);
+        plugin.configure(binder());
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/PluginManager.java b/src/main/java/org/bukkit/plugin/PluginManager.java
--- a/src/main/java/org/bukkit/plugin/PluginManager.java
+++ b/src/main/java/org/bukkit/plugin/PluginManager.java
@@ -8,13 +8,12 @@ import org.bukkit.event.EventPriority;
 import org.bukkit.event.Listener;
 import org.bukkit.permissions.Permissible;
 import org.bukkit.permissions.Permission;
-import tc.oc.minecraft.api.event.EventBus;
 import tc.oc.minecraft.api.plugin.PluginFinder;
 
 /**
  * Handles all plugin management from the Server
  */
-public interface PluginManager extends PluginFinder, EventBus {
+public interface PluginManager extends PluginFinder {
 
     /**
      * Registers the specified plugin loader
diff --git a/src/main/java/org/bukkit/plugin/PluginModule.java b/src/main/java/org/bukkit/plugin/PluginModule.java
new file mode 100644
index 0000000..1e2dda4
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/PluginModule.java
@@ -0,0 +1,54 @@
+package org.bukkit.plugin;
+
+import javax.inject.Singleton;
+
+import com.google.inject.Provides;
+import org.bukkit.configuration.Configuration;
+import org.bukkit.event.EventRegistry;
+import org.bukkit.permissions.PermissionBinder;
+import tc.oc.inject.ProtectedModule;
+import tc.oc.minecraft.api.event.ListenerBinder;
+import tc.oc.exception.ExceptionHandler;
+import tc.oc.minecraft.api.plugin.PluginDescription;
+import tc.oc.minecraft.api.scheduler.Scheduler;
+
+/**
+ * Bindings for things belonging to a particular {@link Plugin}.
+ *
+ * Does not bind {@link Plugin} itself
+ *
+ * @see PluginInstanceModule
+ */
+public class PluginModule extends ProtectedModule {
+
+    @Override
+    protected void configure() {
+        // Ensure these collections have bindings
+        new PermissionBinder(binder());
+        new ListenerBinder(binder());
+
+        bind(tc.oc.minecraft.api.plugin.Plugin.class).to(Plugin.class);
+        bind(PluginDescription.class).to(PluginDescriptionFile.class);
+        bind(tc.oc.minecraft.api.configuration.Configuration.class).to(Configuration.class);
+        bind(tc.oc.minecraft.api.event.EventRegistry.class).to(EventRegistry.class);
+
+        bind(ExceptionHandler.class).to(PluginExceptionHandler.class).in(Singleton.class);
+        bind(EventRegistry.class).to(PluginEventRegistry.class).in(Singleton.class);
+        bind(Scheduler.class).to(PluginScheduler.class).in(Singleton.class);
+    }
+
+    @Provides
+    PluginDescriptionFile description(Plugin plugin) {
+        return plugin.getDescription();
+    }
+
+    @Provides
+    PluginLogger logger(Plugin plugin) {
+        return (PluginLogger) plugin.getLogger();
+    }
+
+    @Provides
+    Configuration configuration(Plugin plugin) {
+        return plugin.getConfig();
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/PluginScheduler.java b/src/main/java/org/bukkit/plugin/PluginScheduler.java
new file mode 100644
index 0000000..80c562e
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/PluginScheduler.java
@@ -0,0 +1,33 @@
+package org.bukkit.plugin;
+
+import java.time.Duration;
+import javax.annotation.Nullable;
+import javax.inject.Inject;
+
+import org.bukkit.scheduler.BukkitScheduler;
+import org.bukkit.scheduler.BukkitTask;
+import tc.oc.minecraft.api.scheduler.Scheduler;
+
+class PluginScheduler implements Scheduler {
+
+    private final Plugin plugin;
+    private final BukkitScheduler scheduler;
+
+    @Inject PluginScheduler(Plugin plugin, BukkitScheduler scheduler) {
+        this.plugin = plugin;
+        this.scheduler = scheduler;
+    }
+
+    private long ticks(Duration duration) {
+        return Math.max(1, scheduler.toTicks(duration, 1));
+    }
+
+    @Override
+    public BukkitTask schedule(boolean sync, @Nullable Duration delay, @Nullable Duration period, Runnable task) {
+        final long delayTicks = delay == null ? 0 : ticks(delay);
+        final long periodTicks = period == null ? -1 : ticks(period);
+
+        return sync ? scheduler.runTaskTimer(plugin, task, delayTicks, periodTicks)
+                    : scheduler.runTaskTimerAsynchronously(plugin, task, delayTicks, periodTicks);
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/RegisteredListener.java b/src/main/java/org/bukkit/plugin/RegisteredListener.java
--- a/src/main/java/org/bukkit/plugin/RegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/RegisteredListener.java
@@ -1,32 +1,32 @@
 package org.bukkit.plugin;
 
+import javax.annotation.Nullable;
+
 import org.bukkit.event.*;
+import org.bukkit.event.Listener;
 
 /**
- * Stores relevant information for plugin listeners
+ * A {@link BoundEventHandler} belonging to a particular {@link Plugin}.
+ *
+ * @deprecated legacy compatibility
  */
-public class RegisteredListener {
-    private final Listener listener;
-    private final EventPriority priority;
+@Deprecated
+public class RegisteredListener extends BoundEventHandler {
+
     private final Plugin plugin;
-    private final EventExecutor executor;
-    private final boolean ignoreCancelled;
+    final @Nullable PluginEventRegistry registry;
 
+    // This constructor is for upstream compatibility
     public RegisteredListener(final Listener listener, final EventExecutor executor, final EventPriority priority, final Plugin plugin, final boolean ignoreCancelled) {
-        this.listener = listener;
-        this.priority = priority;
+        super(new EventHandlerMeta<>(Event.class, priority, ignoreCancelled), new EventExecutorAdapter<>(executor), listener);
         this.plugin = plugin;
-        this.executor = executor;
-        this.ignoreCancelled = ignoreCancelled;
+        this.registry = null;
     }
 
-    /**
-     * Gets the listener for this registration
-     *
-     * @return Registered Listener
-     */
-    public Listener getListener() {
-        return listener;
+    RegisteredListener(EventHandlerMeta meta, org.bukkit.event.EventExecutor executor, tc.oc.minecraft.api.event.Listener listener, Plugin plugin, PluginEventRegistry registry) {
+        super(meta, executor, listener);
+        this.plugin = plugin;
+        this.registry = registry;
     }
 
     /**
@@ -38,36 +38,13 @@ public class RegisteredListener {
         return plugin;
     }
 
-    /**
-     * Gets the priority for this registration
-     *
-     * @return Registered Priority
-     */
-    public EventPriority getPriority() {
-        return priority;
+    @Override
+    public boolean isEnabled() {
+        return getPlugin().isEnabled();
     }
 
-    /**
-     * Calls the event executor
-     *
-     * @param event The event
-     * @throws EventException If an event handler throws an exception.
-     */
-    public void callEvent(final Event event) throws EventException {
-        if (event instanceof Cancellable){
-            if (((Cancellable) event).isCancelled() && isIgnoringCancelled()){
-                return;
-            }
-        }
-        executor.execute(listener, event);
-    }
-
-     /**
-     * Whether this listener accepts cancelled events
-     *
-     * @return True when ignoring cancelled events
-     */
-    public boolean isIgnoringCancelled() {
-        return ignoreCancelled;
-    }
+    // These aliases provided for legacy binary compatibility
+    public Listener getListener() { return (Listener) listener(); }
+    public EventPriority getPriority() { return meta().priority(); }
+    public boolean isIgnoringCancelled() { return meta().ignoreCancelled(); }
 }
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -2,7 +2,6 @@ package org.bukkit.plugin;
 
 import java.io.File;
 import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -25,6 +24,7 @@ import org.bukkit.command.PluginCommandYamlParser;
 import org.bukkit.command.SimpleCommandMap;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
 import org.bukkit.event.Event;
+import org.bukkit.event.EventHandlerMeta;
 import org.bukkit.event.EventPriority;
 import org.bukkit.event.HandlerList;
 import org.bukkit.event.Listener;
@@ -49,7 +49,6 @@ public final class SimplePluginManager implements PluginManager {
     private final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
     private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
     private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
-    private boolean useTimings = false;
 
     public SimplePluginManager(Server instance, SimpleCommandMap commandMap) {
         server = instance;
@@ -489,83 +488,13 @@ public final class SimplePluginManager implements PluginManager {
         }
     }
 
-    /**
-     * Calls an event with the given details.
-     * <p>
-     * This method only synchronizes when the event is not asynchronous.
-     *
-     * @param event Event details
-     */
-    public void callEvent(Event event) {
-        if (event.isAsynchronous()) {
-            if (Thread.holdsLock(this)) {
-                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.");
-            }
-            if (server.isPrimaryThread()) {
-                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from primary server thread.");
-            }
-            fireEvent(event);
-        } else {
-            synchronized (this) {
-                fireEvent(event);
-            }
-        }
-    }
-
-    private void fireEvent(Event event) {
-        HandlerList handlers = event.getHandlers();
-        RegisteredListener[] listeners = handlers.getRegisteredListeners();
-
-        for (RegisteredListener registration : listeners) {
-            if (!registration.getPlugin().isEnabled()) {
-                continue;
-            }
-
-            try {
-                registration.callEvent(event);
-            } catch (AuthorNagException ex) {
-                Plugin plugin = registration.getPlugin();
-
-                if (plugin.isNaggable()) {
-                    plugin.setNaggable(false);
-
-                    server.getLogger().log(Level.SEVERE, String.format(
-                            "Nag author(s): '%s' of '%s' about the following: %s",
-                            plugin.getDescription().getAuthors(),
-                            plugin.getDescription().getFullName(),
-                            ex.getMessage()
-                            ));
-                }
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName(), ex);
-            }
-        }
-    }
-
-    @Override
-    public void registerListener(tc.oc.minecraft.api.plugin.Plugin plugin, tc.oc.minecraft.api.event.Listener listener) {
-        registerEvents((Listener) listener, (Plugin) plugin);
-    }
-
     @Override
-    public void unregisterListener(tc.oc.minecraft.api.event.Listener listener) {
-        HandlerList.unregisterAll((Listener) listener);
-    }
-
-    @Override
-    public void unregisterListeners(tc.oc.minecraft.api.plugin.Plugin plugin) {
-        HandlerList.unregisterAll((Plugin) plugin);
+    public void callEvent(Event event) {
+        server.eventBus().callEvent(event);
     }
 
     public void registerEvents(Listener listener, Plugin plugin) {
-        if (!plugin.isEnabled()) {
-            throw new IllegalPluginAccessException("Plugin attempted to register " + listener + " while not enabled");
-        }
-
-        for (Map.Entry<Class<? extends Event>, Set<RegisteredListener>> entry : plugin.getPluginLoader().createRegisteredListeners(listener, plugin).entrySet()) {
-            getEventListeners(getRegistrationClass(entry.getKey())).registerAll(entry.getValue());
-        }
-
+        plugin.eventRegistry().registerListener(listener);
     }
 
     public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin) {
@@ -585,45 +514,7 @@ public final class SimplePluginManager implements PluginManager {
      *     cancelled
      */
     public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled) {
-        Validate.notNull(listener, "Listener cannot be null");
-        Validate.notNull(priority, "Priority cannot be null");
-        Validate.notNull(executor, "Executor cannot be null");
-        Validate.notNull(plugin, "Plugin cannot be null");
-
-        if (!plugin.isEnabled()) {
-            throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
-        }
-
-        if (useTimings) {
-            getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
-        } else {
-            getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
-        }
-    }
-
-    private HandlerList getEventListeners(Class<? extends Event> type) {
-        try {
-            Method method = getRegistrationClass(type).getDeclaredMethod("getHandlerList");
-            method.setAccessible(true);
-            return (HandlerList) method.invoke(null);
-        } catch (Exception e) {
-            throw new IllegalPluginAccessException(e.toString());
-        }
-    }
-
-    private Class<? extends Event> getRegistrationClass(Class<? extends Event> clazz) {
-        try {
-            clazz.getDeclaredMethod("getHandlerList");
-            return clazz;
-        } catch (NoSuchMethodException e) {
-            if (clazz.getSuperclass() != null
-                    && !clazz.getSuperclass().equals(Event.class)
-                    && Event.class.isAssignableFrom(clazz.getSuperclass())) {
-                return getRegistrationClass(clazz.getSuperclass().asSubclass(Event.class));
-            } else {
-                throw new IllegalPluginAccessException("Unable to find handler list for event " + clazz.getName() + ". Static getHandlerList method required!");
-            }
-        }
+        plugin.eventRegistry().bindHandler(new EventHandlerMeta<>(event, priority, ignoreCancelled), listener, new EventExecutorAdapter<>(executor));
     }
 
     public Permission getPermission(String name) {
@@ -755,15 +646,6 @@ public final class SimplePluginManager implements PluginManager {
     }
 
     public boolean useTimings() {
-        return useTimings;
-    }
-
-    /**
-     * Sets whether or not per event timing code should be used
-     *
-     * @param use True if per event timing code should be used
-     */
-    public void useTimings(boolean use) {
-        useTimings = use;
+        return server.pluginProfiling();
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
--- a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
@@ -2,22 +2,31 @@ package org.bukkit.plugin;
 
 import org.bukkit.event.Event;
 import org.bukkit.event.EventException;
+import org.bukkit.event.EventHandlerMeta;
 import org.bukkit.event.EventPriority;
 import org.bukkit.event.Listener;
 
 /**
  * Extends RegisteredListener to include timing information
+ *
+ * @deprecated legacy compatibility
  */
+@Deprecated
 public class TimedRegisteredListener extends RegisteredListener {
     private int count;
     private long totalTime;
     private Class<? extends Event> eventClass;
     private boolean multiple = false;
 
+    // This constructor is for upstream compatibility
     public TimedRegisteredListener(final Listener pluginListener, final EventExecutor eventExecutor, final EventPriority eventPriority, final Plugin registeredPlugin, final boolean listenCancelled) {
         super(pluginListener, eventExecutor, eventPriority, registeredPlugin, listenCancelled);
     }
 
+    TimedRegisteredListener(EventHandlerMeta meta, org.bukkit.event.EventExecutor executor, tc.oc.minecraft.api.event.Listener listener, Plugin plugin, PluginEventRegistry registry) {
+        super(meta, executor, listener, plugin, registry);
+    }
+
     @Override
     public void callEvent(Event event) throws EventException {
         if (event.isAsynchronous()) {
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -9,24 +9,20 @@ import java.io.OutputStream;
 import java.io.Reader;
 import java.net.URL;
 import java.net.URLConnection;
-import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
 
 import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
-import org.bukkit.Warning.WarningState;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.bukkit.command.PluginCommand;
-import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.FileConfiguration;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.generator.ChunkGenerator;
-import org.bukkit.plugin.AuthorNagException;
-import org.bukkit.plugin.PluginAwareness;
 import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
@@ -40,7 +36,6 @@ import com.avaje.ebeaninternal.api.SpiEbeanServer;
 import com.avaje.ebeaninternal.server.ddl.DdlGenerator;
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
-import com.google.common.io.ByteStreams;
 
 /**
  * Represents a Java plugin
@@ -60,7 +55,13 @@ public abstract class JavaPlugin extends PluginBase {
     private PluginLogger logger = null;
 
     public JavaPlugin() {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
+        this(null);
+    }
+
+    JavaPlugin(@Nullable ClassLoader classLoader) {
+        if(classLoader == null) {
+            classLoader = getClass().getClassLoader();
+        }
         if (!(classLoader instanceof PluginClassLoader)) {
             throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
         }
@@ -266,15 +267,21 @@ public abstract class JavaPlugin extends PluginBase {
     protected final void setEnabled(final boolean enabled) {
         if(!isEnabled && enabled) {
             isEnabled = true;
-            try {
-                onEnable();
-            } catch(RuntimeException e) {
-                isEnabled = false;
-                throw e;
+            if(isActive()) {
+                try {
+                    preEnable();
+                    onEnable();
+                } catch(RuntimeException e) {
+                    isEnabled = false;
+                    throw e;
+                }
             }
         } else if(isEnabled && !enabled) {
             try {
-                onDisable();
+                if(isActive()) {
+                    onDisable();
+                    postDisable();
+                }
             } finally {
                 isEnabled = false;
             }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -4,9 +4,6 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -25,23 +22,16 @@ import com.google.common.cache.CacheBuilder;
 import com.google.common.hash.HashCode;
 import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
-import org.bukkit.Warning;
-import org.bukkit.Warning.WarningState;
 import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.EventHandler;
 import org.bukkit.event.Listener;
 import org.bukkit.event.server.PluginDisableEvent;
 import org.bukkit.event.server.PluginEnableEvent;
-import org.bukkit.plugin.AuthorNagException;
-import org.bukkit.plugin.EventExecutor;
 import org.bukkit.plugin.InvalidDescriptionException;
 import org.bukkit.plugin.InvalidPluginException;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
 import org.bukkit.plugin.RegisteredListener;
-import org.bukkit.plugin.TimedRegisteredListener;
 import org.bukkit.plugin.UnknownDependencyException;
 import org.yaml.snakeyaml.error.YAMLException;
 
@@ -207,92 +197,12 @@ public final class JavaPluginLoader implements PluginLoader {
     }
 
     public Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(Listener listener, final Plugin plugin) {
-        Validate.notNull(plugin, "Plugin can not be null");
-        Validate.notNull(listener, "Listener can not be null");
-
-        boolean useTimings = server.getPluginManager().useTimings();
-        Map<Class<? extends Event>, Set<RegisteredListener>> ret = new HashMap<Class<? extends Event>, Set<RegisteredListener>>();
-        Set<Method> methods;
-        try {
-            Method[] publicMethods = listener.getClass().getMethods();
-            Method[] privateMethods = listener.getClass().getDeclaredMethods();
-            methods = new HashSet<Method>(publicMethods.length + privateMethods.length, 1.0f);
-            for (Method method : publicMethods) {
-                methods.add(method);
-            }
-            for (Method method : privateMethods) {
-                methods.add(method);
-            }
-        } catch (NoClassDefFoundError e) {
-            plugin.getLogger().severe("Plugin " + plugin.getDescription().getFullName() + " has failed to register events for " + listener.getClass() + " because " + e.getMessage() + " does not exist.");
-            return ret;
-        }
-
-        for (final Method method : methods) {
-            final EventHandler eh = method.getAnnotation(EventHandler.class);
-            if (eh == null) continue;
-            // Do not register bridge or synthetic methods to avoid event duplication
-            // Fixes SPIGOT-893
-            if (method.isBridge() || method.isSynthetic()) {
-                continue;
-            }
-            final Class<?> checkClass;
-            if (method.getParameterTypes().length != 1 || !Event.class.isAssignableFrom(checkClass = method.getParameterTypes()[0])) {
-                plugin.getLogger().severe(plugin.getDescription().getFullName() + " attempted to register an invalid EventHandler method signature \"" + method.toGenericString() + "\" in " + listener.getClass());
-                continue;
-            }
-            final Class<? extends Event> eventClass = checkClass.asSubclass(Event.class);
-            method.setAccessible(true);
-            Set<RegisteredListener> eventSet = ret.get(eventClass);
-            if (eventSet == null) {
-                eventSet = new HashSet<RegisteredListener>();
-                ret.put(eventClass, eventSet);
-            }
-
-            for (Class<?> clazz = eventClass; Event.class.isAssignableFrom(clazz); clazz = clazz.getSuperclass()) {
-                // This loop checks for extending deprecated events
-                if (clazz.getAnnotation(Deprecated.class) != null) {
-                    Warning warning = clazz.getAnnotation(Warning.class);
-                    WarningState warningState = server.getWarningState();
-                    if (!warningState.printFor(warning)) {
-                        break;
-                    }
-                    plugin.getLogger().log(
-                            Level.WARNING,
-                            String.format(
-                                    "\"%s\" has registered a listener for %s on method \"%s\", but the event is Deprecated." +
-                                    " \"%s\"; please notify the authors %s.",
-                                    plugin.getDescription().getFullName(),
-                                    clazz.getName(),
-                                    method.toGenericString(),
-                                    (warning != null && warning.reason().length() != 0) ? warning.reason() : "Server performance will be affected",
-                                    Arrays.toString(plugin.getDescription().getAuthors().toArray())),
-                            warningState == WarningState.ON ? new AuthorNagException(null) : null);
-                    break;
-                }
-            }
-
-            EventExecutor executor = new EventExecutor() {
-                public void execute(Listener listener, Event event) throws EventException {
-                    try {
-                        if (!eventClass.isAssignableFrom(event.getClass())) {
-                            return;
-                        }
-                        method.invoke(listener, event);
-                    } catch (InvocationTargetException ex) {
-                        throw new EventException(ex.getCause(), event);
-                    } catch (Throwable t) {
-                        throw new EventException(t, event);
-                    }
-                }
-            };
-            if (useTimings) {
-                eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
-            } else {
-                eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
-            }
-        }
-        return ret;
+        final Map<Class<? extends Event>, Set<RegisteredListener>> result = new HashMap<>();
+        plugin.eventRegistry().bindHandlers(listener).forEach(
+            handler -> result.computeIfAbsent(handler.meta().event(), event -> new HashSet<>())
+                             .add((RegisteredListener) handler)
+        );
+        return result;
     }
 
     public void enablePlugin(final Plugin plugin) {
diff --git a/src/main/java/org/bukkit/plugin/java/ModularPlugin.java b/src/main/java/org/bukkit/plugin/java/ModularPlugin.java
new file mode 100644
index 0000000..98941df
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/java/ModularPlugin.java
@@ -0,0 +1,18 @@
+package org.bukkit.plugin.java;
+
+import com.google.inject.Module;
+import tc.oc.inject.ProtectedBinder;
+
+class ModularPlugin extends JavaPlugin {
+
+    private final Module module;
+
+    ModularPlugin(Module module) {
+        super(module.getClass().getClassLoader());
+        this.module = module;
+    }
+
+    public void configure(ProtectedBinder binder) {
+        binder.install(module);
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -12,6 +12,7 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
 import com.google.common.hash.Hashing;
 import com.google.common.hash.HashingInputStream;
 import com.google.common.io.ByteStreams;
+import com.google.inject.Module;
 import org.apache.commons.lang.Validate;
 import org.bukkit.plugin.InvalidPluginException;
 import org.bukkit.plugin.PluginDescriptionFile;
@@ -57,14 +58,16 @@ final class PluginClassLoader extends URLClassLoader {
                 throw new InvalidPluginException("Cannot find main class `" + description.getMain() + "'", ex);
             }
 
-            Class<? extends JavaPlugin> pluginClass;
-            try {
-                pluginClass = jarClass.asSubclass(JavaPlugin.class);
-            } catch (ClassCastException ex) {
-                throw new InvalidPluginException("main class `" + description.getMain() + "' does not extend JavaPlugin", ex);
+            if(JavaPlugin.class.isAssignableFrom(jarClass)) {
+                plugin = jarClass.asSubclass(JavaPlugin.class).newInstance();
+            } else if(Module.class.isAssignableFrom(jarClass)) {
+                plugin = new ModularPlugin(jarClass.asSubclass(Module.class).newInstance());
+            } else {
+                throw new InvalidPluginException("main class `" + jarClass.getName() +
+                                                 "' must extend either " + JavaPlugin.class.getName() +
+                                                 " or " + Module.class.getName());
             }
 
-            plugin = pluginClass.newInstance();
             return plugin;
         } catch (IllegalAccessException ex) {
             throw new InvalidPluginException("No public constructor", ex);
@@ -195,7 +198,6 @@ final class PluginClassLoader extends URLClassLoader {
 
     synchronized void initialize(JavaPlugin javaPlugin) {
         Validate.notNull(javaPlugin, "Initializing plugin cannot be null");
-        Validate.isTrue(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
 
         if (this.plugin != null) {
             throw new IllegalArgumentException("Plugin already initialized!");
diff --git a/src/main/java/org/bukkit/scheduler/BukkitScheduler.java b/src/main/java/org/bukkit/scheduler/BukkitScheduler.java
--- a/src/main/java/org/bukkit/scheduler/BukkitScheduler.java
+++ b/src/main/java/org/bukkit/scheduler/BukkitScheduler.java
@@ -1,6 +1,8 @@
 package org.bukkit.scheduler;
 
 import org.bukkit.plugin.Plugin;
+
+import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
 import java.util.List;
@@ -366,4 +368,21 @@ public interface BukkitScheduler {
      */
     @Deprecated
     public BukkitTask runTaskTimerAsynchronously(Plugin plugin, BukkitRunnable task, long delay, long period) throws IllegalArgumentException;
+
+    Duration tickDuration();
+
+    default Duration tickDuration(long ticks) {
+        return tickDuration().multipliedBy(ticks);
+    }
+
+    default long toTicks(Duration duration, int rounding) {
+        final long tick = tickDuration().toNanos();
+        if(rounding < 0) {
+            return duration.toNanos() / tick;
+        }
+        if(rounding > 0) {
+            return (duration.toNanos() + tick - 1) / tick;
+        }
+        return (duration.toNanos() + (tick / 2)) / tick;
+    }
 }
diff --git a/src/main/java/org/bukkit/scheduler/BukkitTask.java b/src/main/java/org/bukkit/scheduler/BukkitTask.java
--- a/src/main/java/org/bukkit/scheduler/BukkitTask.java
+++ b/src/main/java/org/bukkit/scheduler/BukkitTask.java
@@ -1,11 +1,12 @@
 package org.bukkit.scheduler;
 
 import org.bukkit.plugin.Plugin;
+import tc.oc.minecraft.api.scheduler.Task;
 
 /**
  * Represents a task being executed by the scheduler
  */
-public interface BukkitTask {
+public interface BukkitTask extends Task {
 
     /**
      * Returns the taskId for the task.
diff --git a/src/test/java/org/bukkit/TestServer.java b/src/test/java/org/bukkit/TestServer.java
--- a/src/test/java/org/bukkit/TestServer.java
+++ b/src/test/java/org/bukkit/TestServer.java
@@ -6,12 +6,13 @@ import java.lang.reflect.Proxy;
 import java.util.Map;
 import java.util.logging.Logger;
 
+import com.google.common.collect.ImmutableMap;
 import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.event.EventBus;
+import org.bukkit.event.SimpleEventBus;
 import org.bukkit.plugin.PluginManager;
 import org.bukkit.plugin.SimplePluginManager;
 
-import com.google.common.collect.ImmutableMap;
-
 public class TestServer implements InvocationHandler {
     private static interface MethodHandler {
         Object handle(TestServer server, Object[] args);
@@ -39,6 +40,14 @@ public class TestServer implements InvocationHandler {
                     }
                 );
             methodMap.put(
+                    Server.class.getMethod("eventBus"),
+                    new MethodHandler() {
+                        public Object handle(TestServer server, Object[] args) {
+                            return server.eventBus;
+                        }
+                    }
+                );
+            methodMap.put(
                     Server.class.getMethod("getLogger"),
                     new MethodHandler() {
                         final Logger logger = Logger.getLogger(TestServer.class.getCanonicalName());
@@ -77,6 +86,7 @@ public class TestServer implements InvocationHandler {
             Server instance = Proxy.getProxyClass(Server.class.getClassLoader(), Server.class).asSubclass(Server.class).getConstructor(InvocationHandler.class).newInstance(server);
             Bukkit.setServer(instance);
             server.pluginManager = new SimplePluginManager(instance, new SimpleCommandMap(instance));
+            server.eventBus = new SimpleEventBus(null, server.pluginManager);
         } catch (Throwable t) {
             throw new Error(t);
         }
@@ -84,6 +94,7 @@ public class TestServer implements InvocationHandler {
 
     private Thread creatingThread = Thread.currentThread();
     private PluginManager pluginManager;
+    private EventBus eventBus;
     private TestServer() {};
 
     public static Server getInstance() {
diff --git a/src/test/java/org/bukkit/event/EventBusTest.java b/src/test/java/org/bukkit/event/EventBusTest.java
new file mode 100644
index 0000000..efb19e5
--- /dev/null
+++ b/src/test/java/org/bukkit/event/EventBusTest.java
@@ -0,0 +1,275 @@
+package org.bukkit.event;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Stream;
+
+import tc.oc.exception.ExceptionHandler;
+import org.bukkit.exception.TestExceptionHandler;
+import tc.oc.test.TestThread;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static tc.oc.test.Assert.*;
+import static org.junit.Assert.*;
+
+public class EventBusTest {
+
+    static class Oops extends Exception {}
+
+    ExceptionHandler exceptionHandler = new TestExceptionHandler();
+    Object lock;
+    SimpleEventBus bus;
+    List<String> flow;
+
+    @Before
+    public void setUp() throws Exception {
+        bus = new SimpleEventBus(Thread.currentThread(), lock = new Object());
+        flow = new ArrayList<>();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        HandlerList.unregisterAll();
+    }
+
+    void flow(String action) {
+        flow.add(action);
+    }
+
+    void assertFlow(String... actions) {
+        assertEquals(Arrays.asList(actions), flow);
+    }
+
+    void register(EventCallable<TestEvent> handler) {
+        CallableEventHandler.register(TestEvent.class, handler, exceptionHandler);
+    }
+
+    void register(EventPriority priority, EventCallable<TestEvent> handler) {
+        CallableEventHandler.register(TestEvent.class, priority, handler, exceptionHandler);
+    }
+
+    @Test
+    public void handleSyncEvent() {
+        register(event ->
+            flow("handler")
+        );
+        bus.callEvent(new TestEvent());
+        assertFlow("handler");
+    }
+
+    @Test
+    public void handleAsyncEvent() throws Throwable {
+        register(event ->
+            flow("handler")
+        );
+        TestThread.join(() ->
+            bus.callEvent(new TestEvent(true))
+        );
+        assertFlow("handler");
+    }
+
+    @Test
+    public void asyncEventOnMainThreadThrows() throws Throwable {
+        assertThrows(IllegalStateException.class, () ->
+            bus.callEvent(new TestEvent(true))
+        );
+    }
+
+    @Test
+    public void asyncEventHoldingLockThrows() throws Throwable {
+        TestThread.join(() -> {
+            synchronized(lock) {
+                assertThrows(IllegalStateException.class, () ->
+                    bus.callEvent(new TestEvent(true))
+                );
+            }
+        });
+    }
+
+    @Test
+    public void eventWithBody() throws Exception {
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+        assertFlow("body");
+    }
+
+    @Test
+    public void nonYieldingHandler() throws Exception {
+        register(event ->
+            flow("handler")
+        );
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+        assertFlow("handler", "body");
+    }
+
+    @Test
+    public void yieldingHandler() throws Exception {
+        register(event -> {
+            flow("before");
+            event.yield();
+            flow("after");
+        });
+
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+
+        assertFlow("before", "body", "after");
+    }
+
+    @Test
+    public void yieldMultipleTimesThrows() throws Throwable {
+        register(event -> {
+            event.yield();
+            assertThrows(IllegalStateException.class, event::yield);
+        });
+
+        bus.callEvent(new TestEvent());
+    }
+
+    @Test
+    public void mixedYieldingAndNonYieldingHandlers() throws Exception {
+        register(EventPriority.LOW, event -> {
+            flow("low");
+        });
+
+        register(EventPriority.NORMAL, event -> {
+            flow("normal before");
+            event.yield();
+            flow("normal after");
+        });
+
+        register(EventPriority.HIGH, event -> {
+            flow("high");
+        });
+
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+
+        assertFlow(
+            "low",
+            "normal before",
+            "high",
+            "body",
+            "normal after"
+        );
+    }
+
+    @Test
+    public void yieldAtMultiplePriorityLevels() throws Exception {
+        Stream.of(EventPriority.LOW, EventPriority.NORMAL, EventPriority.HIGH).forEach(priority -> {
+            register(priority, event -> {
+                flow("before " + priority);
+                event.yield();
+                flow("after " + priority);
+            });
+        });
+
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+
+        assertFlow(
+            "before LOW",
+            "before NORMAL",
+            "before HIGH",
+            "body",
+            "after HIGH",
+            "after NORMAL",
+            "after LOW"
+        );
+    }
+
+    @Test
+    public void eventBodyException() throws Throwable {
+        register(Event::yield); // A handler that just yields
+
+        assertThrows(Oops.class, () ->
+            bus.callEvent(new TestEvent(), event -> {
+                throw new Oops();
+            })
+        );
+    }
+
+    @Test
+    public void handlerExceptionBeforeYield() throws Exception {
+        ExceptionHandler exceptionHandler = (exception, message) -> flow("report");
+
+        CallableEventHandler.register(TestEvent.class, EventPriority.LOW, event -> {
+            flow("low handler before");
+            event.yield();
+            flow("low handler after");
+        }, exceptionHandler);
+
+        CallableEventHandler.register(TestEvent.class, EventPriority.NORMAL, event -> {
+            flow("bad handler");
+            throw new RuntimeException();
+        }, exceptionHandler);
+
+        CallableEventHandler.register(TestEvent.class, EventPriority.HIGH, event -> {
+            flow("high handler before");
+            event.yield();
+            flow("high handler after");
+        }, exceptionHandler);
+
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+
+        assertFlow(
+            "low handler before",
+            "bad handler",
+            "report",
+            "high handler before",
+            "body",
+            "high handler after",
+            "low handler after"
+        );
+    }
+
+    @Test
+    public void handlerExceptionAfterYield() throws Exception {
+        ExceptionHandler exceptionHandler = (exception, message) -> flow("report");
+
+        CallableEventHandler.register(TestEvent.class, EventPriority.LOW, event -> {
+            flow("low handler before");
+            event.yield();
+            flow("low handler after");
+        }, exceptionHandler);
+
+        CallableEventHandler.register(TestEvent.class, EventPriority.NORMAL, event -> {
+            flow("bad handler before");
+            event.yield();
+            flow("bad handler after");
+            throw new RuntimeException();
+        }, exceptionHandler);
+
+        CallableEventHandler.register(TestEvent.class, EventPriority.HIGH, event -> {
+            flow("high handler before");
+            event.yield();
+            flow("high handler after");
+        }, exceptionHandler);
+
+        bus.callEvent(new TestEvent(), event ->
+            flow("body")
+        );
+
+        assertFlow(
+            "low handler before",
+            "bad handler before",
+            "high handler before",
+            "body",
+            "high handler after",
+            "bad handler after",
+            "report",
+            "low handler after"
+        );
+    }
+}
diff --git a/src/test/java/org/bukkit/event/EventHandlerMetaTest.java b/src/test/java/org/bukkit/event/EventHandlerMetaTest.java
new file mode 100644
index 0000000..7399b06
--- /dev/null
+++ b/src/test/java/org/bukkit/event/EventHandlerMetaTest.java
@@ -0,0 +1,87 @@
+package org.bukkit.event;
+
+import org.junit.Test;
+
+import static tc.oc.test.Assert.*;
+import static org.junit.Assert.*;
+
+public class EventHandlerMetaTest {
+
+    @Test
+    public void canHandle() throws Throwable {
+        EventHandlerMeta<TestEvent> meta = new EventHandlerMeta<>(TestEvent.class, EventPriority.NORMAL, false);
+
+        // Base case
+        assertTrue(meta.canHandle(new TestEvent(), null));
+
+        // Event type
+        assertFalse(meta.canHandle(new Event(){}, null));
+        assertTrue(meta.canHandle(new TestEvent(){}, null));
+
+        // Priority
+        assertTrue(meta.canHandle(new TestEvent(), EventPriority.NORMAL));
+        assertFalse(meta.canHandle(new TestEvent(), EventPriority.LOW));
+
+        // Cancelled
+        TestEvent cancelled = new TestEvent(){
+            public boolean isCancelled() { return true; }
+        };
+        assertTrue(meta.canHandle(cancelled, null));
+        assertFalse(new EventHandlerMeta<>(TestEvent.class, EventPriority.NORMAL, true).canHandle(cancelled, null));
+    }
+
+    @Test
+    public void createForMethod() throws Exception {
+        class C {
+            @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
+            void handler(TestEvent event) {}
+        }
+
+        EventHandlerMeta<?> meta = EventHandlerMeta.forMethod(C.class.getDeclaredMethod("handler", TestEvent.class));
+
+        assertEquals(TestEvent.class, meta.event());
+        assertEquals(EventPriority.HIGH, meta.priority());
+        assertEquals(true, meta.ignoreCancelled());
+    }
+
+    @Test
+    public void ignoreMethodWithoutAnnotation() throws Exception {
+        class C {
+            void handler(TestEvent event) {}
+        }
+        assertNull(EventHandlerMeta.forMethod(C.class.getDeclaredMethod("handler", TestEvent.class)));
+    }
+
+    @Test
+    public void missingEventParameter() throws Throwable {
+        class C {
+            @EventHandler
+            void handler() {}
+        }
+        assertThrows(IllegalArgumentException.class, () ->
+            EventHandlerMeta.forMethod(C.class.getDeclaredMethod("handler"))
+        );
+    }
+
+    @Test
+    public void extraParameter() throws Throwable {
+        class C {
+            @EventHandler
+            void handler(TestEvent event, int what) {}
+        }
+        assertThrows(IllegalArgumentException.class, () ->
+            EventHandlerMeta.forMethod(C.class.getDeclaredMethod("handler", TestEvent.class, int.class))
+        );
+    }
+
+    @Test
+    public void abstractEvent() throws Throwable {
+        class C {
+            @EventHandler
+            void handler(Event event) {}
+        }
+        assertThrows(IllegalArgumentException.class, () ->
+            EventHandlerMeta.forMethod(C.class.getDeclaredMethod("handler", Event.class))
+        );
+    }
+}
diff --git a/src/test/java/org/bukkit/event/EventMethodExecutorTest.java b/src/test/java/org/bukkit/event/EventMethodExecutorTest.java
new file mode 100644
index 0000000..d879171
--- /dev/null
+++ b/src/test/java/org/bukkit/event/EventMethodExecutorTest.java
@@ -0,0 +1,135 @@
+package org.bukkit.event;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Collectors;
+
+import tc.oc.exception.ExceptionHandler;
+import org.bukkit.exception.TestExceptionHandler;
+import tc.oc.test.TestCodeBlock;
+import org.junit.Test;
+
+import static tc.oc.test.Assert.*;
+import static org.junit.Assert.*;
+
+public class EventMethodExecutorTest {
+
+    ExceptionHandler exceptionHandler = new TestExceptionHandler();
+
+    List<EventMethodExecutor<?>> createHandlers(Class<? extends Listener> listener) {
+        return EventMethodExecutor.forMethods(listener, exceptionHandler)
+                                  .collect(Collectors.toList());
+    }
+
+    @Test
+    public void empty() throws Exception {
+        class C implements Listener {}
+        assertEmpty(createHandlers(C.class));
+    }
+
+    @Test
+    public void singleHandler() throws Exception {
+        class C implements Listener {
+            @EventHandler
+            public void handler(TestEvent event) {}
+        }
+        assertSize(1, createHandlers(C.class));
+    }
+
+    @Test
+    public void nonPublicHandlers() throws Exception {
+        class C implements Listener {
+            @EventHandler private void privateHandler(TestEvent event) {}
+            @EventHandler protected void protectedHandler(TestEvent event) {}
+            @EventHandler void packageHandler(TestEvent event) {}
+        }
+        assertSize(3, createHandlers(C.class));
+    }
+
+    @Test
+    public void superclassHandler() throws Exception {
+        class C implements Listener {
+            @EventHandler
+            public void handler(TestEvent event) {}
+        }
+        class D extends C {}
+        assertSize(1, createHandlers(D.class));
+    }
+
+    interface I extends Listener {
+        @EventHandler
+        default void handler(TestEvent event) {}
+    }
+
+    @Test
+    public void interfaceHandler() throws Exception {
+        assertSize(1, createHandlers(I.class));
+    }
+
+    @Test
+    public void inheritedInterfaceHandler() throws Exception {
+        class C implements I {}
+        assertSize(1, createHandlers(C.class));
+    }
+
+    static class PrivateHandler implements Listener {
+        boolean called = false;
+
+        @EventHandler
+        private void handler(TestEvent event) {
+            called = true;
+        }
+    }
+
+    @Test
+    public void callPrivateHandler() throws Throwable {
+        PrivateHandler listener = new PrivateHandler();
+        EventMethodExecutor.forMethod(
+            PrivateHandler.class.getDeclaredMethod("handler", TestEvent.class),
+            exceptionHandler
+        ).execute(listener, new TestEvent());
+
+        assertTrue(listener.called);
+    }
+
+    @Test
+    public void reportException() throws Throwable {
+        class C implements Listener {
+            @EventHandler
+            void handler(TestEvent event) throws Exception {
+                throw new Exception();
+            }
+        }
+
+        AtomicBoolean reported = new AtomicBoolean(false);
+
+        EventMethodExecutor.forMethod(
+            C.class.getDeclaredMethod("handler", TestEvent.class),
+            (exception, message) -> reported.set(true)
+        ).execute(new C(), new TestEvent());
+
+        assertTrue(reported.get());
+    }
+
+    @Test
+    public void propagateEventException() throws Throwable {
+        class C implements Listener {
+            @EventHandler
+            void handler(TestEvent event) throws Exception {
+                throw new EventException();
+            }
+        }
+
+        EventMethodExecutor executor = EventMethodExecutor.forMethod(
+            C.class.getDeclaredMethod("handler", TestEvent.class),
+            exceptionHandler
+        );
+
+        assertThrows(EventException.class, new TestCodeBlock() { // lambda here crashes the compiler
+            @Override
+            public void run() throws Throwable {
+                executor.execute(new C(), new TestEvent());
+            }
+        });
+    }
+}
diff --git a/src/test/java/org/bukkit/event/EventRegistryTest.java b/src/test/java/org/bukkit/event/EventRegistryTest.java
new file mode 100644
index 0000000..9da2f8d
--- /dev/null
+++ b/src/test/java/org/bukkit/event/EventRegistryTest.java
@@ -0,0 +1,93 @@
+package org.bukkit.event;
+
+import java.util.List;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static tc.oc.test.Assert.*;
+import static org.junit.Assert.*;
+
+public class EventRegistryTest {
+
+    EventRegistry registry;
+
+    @Before
+    public void setUp() throws Exception {
+        registry = new SimpleEventRegistry();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        HandlerList.unregisterAll();
+    }
+
+    List<EventMethodExecutor<?>> createHandlers(Class<? extends Listener> listener) {
+        return registry.createHandlers(listener).collect(Collectors.toList());
+    }
+
+    void assertRegistered(Predicate<? super RegisteredHandler<?>> filter) {
+        assertRegistered(1, filter);
+    }
+
+    void assertNotRegistered(Predicate<? super RegisteredHandler<?>> filter) {
+        assertRegistered(0, filter);
+    }
+
+    void assertRegistered(int count, Predicate<? super RegisteredHandler<?>> filter) {
+        assertEquals(count, Stream.of(Event.getHandlerList(TestEvent.class)
+                                           .getRegisteredListeners())
+                                  .filter(filter)
+                                  .count());
+    }
+
+    @Test
+    public void registerListener() throws Exception {
+        class C implements Listener {
+            @EventHandler
+            void handler(TestEvent event) {}
+        }
+        C c = new C();
+        registry.registerListener(c);
+        assertRegistered(handler -> handler instanceof BoundEventHandler &&
+                                    ((BoundEventHandler) handler).listener() == c);
+    }
+
+    @Test
+    public void unregisterListener() throws Exception {
+        class C implements Listener {
+            @EventHandler
+            void handler(TestEvent event) {}
+        }
+        C c1 = new C();
+        C c2 = new C();
+        registry.registerListener(c1);
+        registry.registerListener(c2);
+        registry.unregisterListener(c1);
+
+        assertNotRegistered(handler -> handler instanceof BoundEventHandler && ((BoundEventHandler) handler).listener() == c1);
+        assertRegistered(handler -> handler instanceof BoundEventHandler && ((BoundEventHandler) handler).listener() == c2);
+    }
+
+    @Test
+    public void unregisterAll() throws Exception {
+        class C implements Listener {
+            @EventHandler
+            void handler(TestEvent event) {}
+        }
+        EventRegistry registry1 = new SimpleEventRegistry();
+        EventRegistry registry2 = new SimpleEventRegistry();
+        C c1 = new C();
+        C c2 = new C();
+        registry1.registerListener(c1);
+        registry2.registerListener(c2);
+        registry1.unregisterAll();
+
+        assertNotRegistered(handler -> handler instanceof BoundEventHandler && ((BoundEventHandler) handler).listener() == c1);
+        assertRegistered(handler -> handler instanceof BoundEventHandler && ((BoundEventHandler) handler).listener() == c2);
+    }
+}
diff --git a/src/test/java/org/bukkit/event/HandlerListTest.java b/src/test/java/org/bukkit/event/HandlerListTest.java
new file mode 100644
index 0000000..ff30c1d
--- /dev/null
+++ b/src/test/java/org/bukkit/event/HandlerListTest.java
@@ -0,0 +1,18 @@
+package org.bukkit.event;
+
+import org.junit.Test;
+
+import static tc.oc.test.Assert.*;
+
+public class HandlerListTest {
+
+    @Test
+    public void duplicateRegistration() throws Throwable {
+        HandlerList list = Event.getHandlerList(TestEvent.class);
+        CallableEventHandler<TestEvent> handler = CallableEventHandler.create(TestEvent.class, event -> {});
+        list.register(handler);
+        assertThrows(IllegalStateException.class, () ->
+            list.register(handler)
+        );
+    }
+}
diff --git a/src/test/java/org/bukkit/event/SyntheticEventTest.java b/src/test/java/org/bukkit/event/SyntheticEventTest.java
deleted file mode 100644
index df6cf00..0000000
--- a/src/test/java/org/bukkit/event/SyntheticEventTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.event;
-
-import org.bukkit.TestServer;
-import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.TestPlugin;
-import org.bukkit.plugin.java.JavaPluginLoader;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class SyntheticEventTest {
-    @SuppressWarnings("deprecation")
-    @Test
-    public void test() {
-        final JavaPluginLoader loader = new JavaPluginLoader(TestServer.getInstance());
-        TestPlugin plugin = new TestPlugin(getClass().getName()) {
-            @Override
-            public PluginLoader getPluginLoader() {
-                return loader;
-            }
-        };
-        SimplePluginManager pluginManager = new SimplePluginManager(TestServer.getInstance(), null);
-
-        TestEvent event = new TestEvent(false);
-        Impl impl = new Impl();
-
-        pluginManager.registerEvents(impl, plugin);
-        pluginManager.callEvent(event);
-
-        Assert.assertEquals(1, impl.callCount);
-    }
-
-    public static abstract class Base<E extends Event> implements Listener {
-        int callCount = 0;
-
-        public void accept(E evt) {
-            System.out.println("Invk " + evt);
-            callCount++;
-        }
-    }
-
-    public static class Impl extends Base<TestEvent> {
-        @Override
-        @EventHandler
-        public void accept(TestEvent evt) {
-            super.accept(evt);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/event/TestEvent.java b/src/test/java/org/bukkit/event/TestEvent.java
--- a/src/test/java/org/bukkit/event/TestEvent.java
+++ b/src/test/java/org/bukkit/event/TestEvent.java
@@ -4,6 +4,10 @@ package org.bukkit.event;
 public class TestEvent extends Event {
     private static final HandlerList handlers = new HandlerList();
 
+    public TestEvent() {
+        this(false);
+    }
+
     public TestEvent(boolean async) {
         super(async);
     }
diff --git a/src/test/java/org/bukkit/exception/TestExceptionHandler.java b/src/test/java/org/bukkit/exception/TestExceptionHandler.java
new file mode 100644
index 0000000..440d183
--- /dev/null
+++ b/src/test/java/org/bukkit/exception/TestExceptionHandler.java
@@ -0,0 +1,10 @@
+package org.bukkit.exception;
+
+import tc.oc.exception.ExceptionHandler;
+
+public class TestExceptionHandler implements ExceptionHandler {
+    @Override
+    public void handleException(Throwable exception, String message) {
+        throw new AssertionError(message, exception);
+    }
+}
diff --git a/src/test/java/org/bukkit/plugin/PluginManagerTest.java b/src/test/java/org/bukkit/plugin/PluginManagerTest.java
--- a/src/test/java/org/bukkit/plugin/PluginManagerTest.java
+++ b/src/test/java/org/bukkit/plugin/PluginManagerTest.java
@@ -26,7 +26,7 @@ public class PluginManagerTest {
         try {
             pm.callEvent(event);
         } catch (IllegalStateException ex) {
-            assertThat(event.getEventName() + " cannot be triggered asynchronously from primary server thread.", is(ex.getMessage()));
+            assertThat(event.getEventName() + " cannot be called asynchronously from primary thread.", is(ex.getMessage()));
             return;
         }
         throw new IllegalStateException("No exception thrown");
@@ -57,7 +57,7 @@ public class PluginManagerTest {
         secondThread.start();
         secondThread.join();
         assertThat(store.value, is(instanceOf(IllegalStateException.class)));
-        assertThat(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.", is(((Throwable) store.value).getMessage()));
+        assertThat(event.getEventName() + " cannot be called asynchronously from inside synchronized code.", is(((Throwable) store.value).getMessage()));
     }
 
     @Test
diff --git a/src/test/java/org/bukkit/plugin/TestPlugin.java b/src/test/java/org/bukkit/plugin/TestPlugin.java
--- a/src/test/java/org/bukkit/plugin/TestPlugin.java
+++ b/src/test/java/org/bukkit/plugin/TestPlugin.java
@@ -3,22 +3,37 @@ package org.bukkit.plugin;
 import java.io.File;
 import java.io.InputStream;
 import java.util.List;
+import java.util.logging.Logger;
+import javax.annotation.Nullable;
 
+import com.avaje.ebean.EbeanServer;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.bukkit.configuration.file.FileConfiguration;
+import tc.oc.exception.ExceptionHandler;
 import org.bukkit.generator.ChunkGenerator;
 
-import com.avaje.ebean.EbeanServer;
-
 public class TestPlugin extends PluginBase {
     private boolean enabled = true;
+    private boolean naggable = true;
 
     final private String pluginName;
+    final private @Nullable Server server;
+    final private Logger logger;
+    final private ExceptionHandler exceptionHandler;
+    final private PluginEventRegistry eventRegistry;
 
     public TestPlugin(String pluginName) {
+        this(pluginName, null);
+    }
+
+    public TestPlugin(String pluginName, @Nullable Server server) {
         this.pluginName = pluginName;
+        this.server = server;
+        this.logger = server != null ? new PluginLogger(this) : Logger.getGlobal();
+        this.exceptionHandler = new PluginExceptionHandler(this);
+        this.eventRegistry = new PluginEventRegistry(this);
     }
 
     public void setEnabled(boolean enabled) {
@@ -57,15 +72,26 @@ public class TestPlugin extends PluginBase {
         throw new UnsupportedOperationException("Not supported.");
     }
 
-    public PluginLogger getLogger() {
-        throw new UnsupportedOperationException("Not supported.");
+    public Logger getLogger() {
+        return logger;
+    }
+
+    @Override
+    public ExceptionHandler exceptionHandler() {
+        return exceptionHandler;
     }
 
     public PluginLoader getPluginLoader() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    @Override
+    public PluginEventRegistry eventRegistry() {
+        return eventRegistry;
+    }
+
     public Server getServer() {
+        if(server != null) return server;
         throw new UnsupportedOperationException("Not supported.");
     }
 
@@ -86,11 +112,11 @@ public class TestPlugin extends PluginBase {
     }
 
     public boolean isNaggable() {
-        throw new UnsupportedOperationException("Not supported.");
+        return naggable;
     }
 
-    public void setNaggable(boolean canNag) {
-        throw new UnsupportedOperationException("Not supported.");
+    public void setNaggable(boolean naggable) {
+        this.naggable = naggable;
     }
 
     public EbeanServer getDatabase() {
