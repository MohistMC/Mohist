From: Jedediah Smith <jedediah@silencegreys.com>
Date: Fri, 18 Nov 2016 04:34:11 -0500
Subject: [PATCH] Geometry API


diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -50,6 +50,7 @@ import org.bukkit.generator.ChunkGenerator;
 
 import org.bukkit.inventory.ItemFactory;
 import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.geometry.VectorFactory;
 
 /**
  * Represents the Bukkit core, for version and Server singleton handling
@@ -586,6 +587,10 @@ public final class Bukkit {
         return server.getWorld(uid);
     }
 
+    public static World world(UUID uid) {
+        return server.world(uid);
+    }
+
     /**
      * Gets the map from the given item ID.
      *
@@ -1256,6 +1261,8 @@ public final class Bukkit {
         return runtime().key(id);
     }
 
+    public static VectorFactory vectors() { return runtime().vectors(); }
+
     public static PotionBrewRegistry potionRegistry() {
         return runtime().potionRegistry();
     }
diff --git a/src/main/java/org/bukkit/BukkitRuntime.java b/src/main/java/org/bukkit/BukkitRuntime.java
--- a/src/main/java/org/bukkit/BukkitRuntime.java
+++ b/src/main/java/org/bukkit/BukkitRuntime.java
@@ -5,6 +5,7 @@ import org.bukkit.inventory.meta.ItemMeta;
 import org.bukkit.potion.PotionEffectRegistry;
 import org.bukkit.potion.PotionBrewRegistry;
 import org.bukkit.registry.Key;
+import org.bukkit.geometry.VectorFactory;
 
 public interface BukkitRuntime {
 
@@ -12,6 +13,8 @@ public interface BukkitRuntime {
 
     Key key(String key);
 
+    VectorFactory vectors();
+
     /**
      * Gets the instance of the item factory (for {@link ItemMeta}).
      *
diff --git a/src/main/java/org/bukkit/Location.java b/src/main/java/org/bukkit/Location.java
--- a/src/main/java/org/bukkit/Location.java
+++ b/src/main/java/org/bukkit/Location.java
@@ -2,24 +2,64 @@ package org.bukkit;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+import javax.annotation.Nullable;
 
 import org.bukkit.block.Block;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.geometry.Direction;
+import org.bukkit.geometry.Ray;
+import org.bukkit.util.BlockVector;
 import org.bukkit.util.NumberConversions;
-import static org.bukkit.util.NumberConversions.checkFinite;
+
+import org.bukkit.geometry.Vec3;
 import org.bukkit.util.Vector;
 
 /**
  * Represents a 3-dimensional position in a world
  */
 public class Location implements Cloneable, ConfigurationSerializable, Physical {
-    private World world;
-    private double x;
-    private double y;
-    private double z;
+
+    private UUID worldId;
+    private final Vector position;
     private float pitch;
     private float yaw;
 
+    public Location(World world, Vec3 position) {
+        this(world, position, 0, 0);
+    }
+
+    public Location(UUID world, Vec3 position) {
+        this(world, position, 0, 0);
+    }
+
+    public Location(World world, Vec3 position, float yaw, float pitch) {
+        this(world, position.fineX(), position.fineY(), position.fineZ(), yaw, pitch);
+    }
+
+    public Location(UUID world, Vec3 position, float yaw, float pitch) {
+        this(world, position.fineX(), position.fineY(), position.fineZ(), yaw, pitch);
+    }
+
+    public Location(World world, Vec3 position, Direction direction) {
+        this(world, position.fineX(), position.fineY(), position.fineZ(), direction.yawDegrees(), direction.pitchDegrees());
+    }
+
+    public Location(UUID world, Vec3 position, Direction direction) {
+        this(world, position.fineX(), position.fineY(), position.fineZ(), direction.yawDegrees(), direction.pitchDegrees());
+    }
+
+    public Location(World world, Ray ray) {
+        this(world, ray.origin().fineX(), ray.origin().fineY(), ray.origin().fineZ(),
+             ray.direction().yawDegrees(), ray.direction().pitchDegrees());
+    }
+
+    public Location(UUID world, Ray ray) {
+        this(world, ray.origin().fineX(), ray.origin().fineY(), ray.origin().fineZ(),
+             ray.direction().yawDegrees(), ray.direction().pitchDegrees());
+    }
+
     /**
      * Constructs a new Location with the given coordinates
      *
@@ -28,7 +68,11 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @param y The y-coordinate of this new location
      * @param z The z-coordinate of this new location
      */
-    public Location(final World world, final double x, final double y, final double z) {
+    public Location(World world, double x, double y, double z) {
+        this(world, x, y, z, 0, 0);
+    }
+
+    public Location(UUID world, double x, double y, double z) {
         this(world, x, y, z, 0, 0);
     }
 
@@ -42,11 +86,13 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @param yaw The absolute rotation on the x-plane, in degrees
      * @param pitch The absolute rotation on the y-plane, in degrees
      */
-    public Location(final World world, final double x, final double y, final double z, final float yaw, final float pitch) {
-        this.world = world;
-        this.x = x;
-        this.y = y;
-        this.z = z;
+    public Location(World world, double x, double y, double z, float yaw, float pitch) {
+        this(world.getUID(), x, y, z, yaw, pitch);
+    }
+
+    public Location(UUID world, double x, double y, double z, float yaw, float pitch) {
+        this.worldId = world;
+        this.position = new Vector(x, y, z);
         this.pitch = pitch;
         this.yaw = yaw;
     }
@@ -57,7 +103,11 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @param world New world that this location resides in
      */
     public void setWorld(World world) {
-        this.world = world;
+        setWorldId(world.getUID());
+    }
+
+    public void setWorldId(UUID worldId) {
+        this.worldId = worldId;
     }
 
     /**
@@ -66,7 +116,23 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return World that contains this location
      */
     public World getWorld() {
-        return world;
+        return getWorld(Bukkit.getServer());
+    }
+
+    public World getWorld(Server server) {
+        return server.world(getWorldId());
+    }
+
+    public @Nullable World getWorldIfLoaded() {
+        return getWorldIfLoaded(Bukkit.getServer());
+    }
+
+    public @Nullable World getWorldIfLoaded(Server server) {
+        return server.getWorld(getWorldId());
+    }
+
+    public UUID getWorldId() {
+        return worldId;
     }
 
     /**
@@ -75,7 +141,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return Chunk at the represented location
      */
     public Chunk getChunk() {
-        return world.getChunkAt(this);
+        return getWorld().getChunkAt(this);
     }
 
     /**
@@ -84,7 +150,19 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return Block at the represented location
      */
     public Block getBlock() {
-        return world.getBlockAt(this);
+        return getWorld().getBlockAt(this);
+    }
+
+    public Vector position() {
+        return position;
+    }
+
+    public void setPosition(Vec3 pos) {
+        position.set(pos);
+    }
+
+    public void setPosition(double x, double y, double z) {
+        position.set(x, y, z);
     }
 
     /**
@@ -93,7 +171,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @param x X-coordinate
      */
     public void setX(double x) {
-        this.x = x;
+        position.setX(x);
     }
 
     /**
@@ -102,7 +180,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return x-coordinate
      */
     public double getX() {
-        return x;
+        return position.fineX();
     }
 
     /**
@@ -112,7 +190,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return block X
      */
     public int getBlockX() {
-        return locToBlock(x);
+        return position.coarseX();
     }
 
     /**
@@ -121,7 +199,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @param y y-coordinate
      */
     public void setY(double y) {
-        this.y = y;
+        position.setY(y);
     }
 
     /**
@@ -130,7 +208,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return y-coordinate
      */
     public double getY() {
-        return y;
+        return position.fineY();
     }
 
     /**
@@ -140,7 +218,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return block y
      */
     public int getBlockY() {
-        return locToBlock(y);
+        return position.coarseY();
     }
 
     /**
@@ -149,7 +227,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @param z z-coordinate
      */
     public void setZ(double z) {
-        this.z = z;
+        position.setZ(z);
     }
 
     /**
@@ -158,7 +236,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return z-coordinate
      */
     public double getZ() {
-        return z;
+        return position.fineZ();
     }
 
     /**
@@ -168,7 +246,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return block z
      */
     public int getBlockZ() {
-        return locToBlock(z);
+        return position.coarseZ();
     }
 
     /**
@@ -239,6 +317,14 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
         return pitch;
     }
 
+    public Direction direction() {
+        return Direction.ofDegrees(yaw, pitch);
+    }
+
+    public Ray ray() {
+        return Ray.fromLocation(this);
+    }
+
     /**
      * Gets a unit-vector pointing in the direction that this Location is
      * facing.
@@ -310,11 +396,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
         if (vec == null || vec.getWorld() != getWorld()) {
             throw new IllegalArgumentException("Cannot add Locations of differing worlds");
         }
-
-        x += vec.x;
-        y += vec.y;
-        z += vec.z;
-        return this;
+        return add(vec.position());
     }
 
     /**
@@ -325,9 +407,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the same location
      */
     public Location add(Vector vec) {
-        this.x += vec.getX();
-        this.y += vec.getY();
-        this.z += vec.getZ();
+        position.add(vec);
         return this;
     }
 
@@ -341,9 +421,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the same location
      */
     public Location add(double x, double y, double z) {
-        this.x += x;
-        this.y += y;
-        this.z += z;
+        position.add(x, y, z);
         return this;
     }
 
@@ -359,11 +437,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
         if (vec == null || vec.getWorld() != getWorld()) {
             throw new IllegalArgumentException("Cannot add Locations of differing worlds");
         }
-
-        x -= vec.x;
-        y -= vec.y;
-        z -= vec.z;
-        return this;
+        return subtract(vec.position());
     }
 
     /**
@@ -374,9 +448,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the same location
      */
     public Location subtract(Vector vec) {
-        this.x -= vec.getX();
-        this.y -= vec.getY();
-        this.z -= vec.getZ();
+        position.subtract(vec);
         return this;
     }
 
@@ -391,9 +463,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the same location
      */
     public Location subtract(double x, double y, double z) {
-        this.x -= x;
-        this.y -= y;
-        this.z -= z;
+        position.subtract(x, y, z);
         return this;
     }
 
@@ -409,7 +479,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the magnitude
      */
     public double length() {
-        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
+        return position.length();
     }
 
     /**
@@ -420,7 +490,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the magnitude
      */
     public double lengthSquared() {
-        return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
+        return position.lengthSquared();
     }
 
     /**
@@ -455,8 +525,7 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
         } else if (o.getWorld() != getWorld()) {
             throw new IllegalArgumentException("Cannot measure distance between " + getWorld().getName() + " and " + o.getWorld().getName());
         }
-
-        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
+        return position.distanceSquared(o.position());
     }
 
     /**
@@ -468,72 +537,59 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      * @return the same location
      */
     public Location multiply(double m) {
-        x *= m;
-        y *= m;
-        z *= m;
+        position.multiply(m);
         return this;
     }
 
     /**
+     * Copy yaw and pitch from the given {@link Location} to this one.
+     * @return this object
+     */
+    public Location copyAngles(Location loc) {
+        this.yaw = loc.getYaw();
+        this.pitch = loc.getPitch();
+        return this;
+    }
+
+    /**
+     * Copy position and angles from the given {@link Location} to this one.
+     * @return this object
+     */
+    public Location copyLocation(Location loc) {
+        position.set(loc.position());
+        return copyAngles(loc);
+    }
+
+    /**
      * Zero this location's components. Not world-aware.
      *
      * @see Vector
      * @return the same location
      */
     public Location zero() {
-        x = 0;
-        y = 0;
-        z = 0;
+        position.setZero();
         return this;
     }
 
     @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final Location other = (Location) obj;
-
-        if (this.world != other.world && (this.world == null || !this.world.equals(other.world))) {
-            return false;
-        }
-        if (Double.doubleToLongBits(this.x) != Double.doubleToLongBits(other.x)) {
-            return false;
-        }
-        if (Double.doubleToLongBits(this.y) != Double.doubleToLongBits(other.y)) {
-            return false;
-        }
-        if (Double.doubleToLongBits(this.z) != Double.doubleToLongBits(other.z)) {
-            return false;
-        }
-        if (Float.floatToIntBits(this.pitch) != Float.floatToIntBits(other.pitch)) {
-            return false;
-        }
-        if (Float.floatToIntBits(this.yaw) != Float.floatToIntBits(other.yaw)) {
-            return false;
-        }
-        return true;
+    public final boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof Location)) return false;
+        final Location that = (Location) obj;
+        return Objects.equals(worldId, that.getWorldId()) &&
+               Objects.equals(position, that.position()) &&
+               yaw == that.getYaw() &&
+               pitch == that.getPitch();
     }
 
     @Override
-    public int hashCode() {
-        int hash = 3;
-
-        hash = 19 * hash + (this.world != null ? this.world.hashCode() : 0);
-        hash = 19 * hash + (int) (Double.doubleToLongBits(this.x) ^ (Double.doubleToLongBits(this.x) >>> 32));
-        hash = 19 * hash + (int) (Double.doubleToLongBits(this.y) ^ (Double.doubleToLongBits(this.y) >>> 32));
-        hash = 19 * hash + (int) (Double.doubleToLongBits(this.z) ^ (Double.doubleToLongBits(this.z) >>> 32));
-        hash = 19 * hash + Float.floatToIntBits(this.pitch);
-        hash = 19 * hash + Float.floatToIntBits(this.yaw);
-        return hash;
+    public final int hashCode() {
+        return Objects.hash(worldId, position, yaw, pitch);
     }
 
     @Override
     public String toString() {
-        return "Location{" + "world=" + world + ",x=" + x + ",y=" + y + ",z=" + z + ",pitch=" + pitch + ",yaw=" + yaw + '}';
+        return "Location{" + "world=" + worldId + ",pos=" + position + ",pitch=" + pitch + ",yaw=" + yaw + '}';
     }
 
     /**
@@ -543,37 +599,26 @@ public class Location implements Cloneable, ConfigurationSerializable, Physical
      *     Location
      */
     public Vector toVector() {
-        return new Vector(x, y, z);
+        return position.mutableCopy();
     }
 
-    @Override
-    public Location clone() {
-        try {
-            return (Location) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
+    public BlockVector toBlockVector() {
+        return position.toBlockVector();
     }
 
-    /**
-     * Safely converts a double (location coordinate) to an int (block
-     * coordinate)
-     *
-     * @param loc Precise coordinate
-     * @return Block coordinate
-     */
-    public static int locToBlock(double loc) {
-        return NumberConversions.floor(loc);
+    @Override
+    public Location clone() {
+        return new Location(worldId, position, yaw, pitch);
     }
 
-	@Utility
+    @Utility
 	public Map<String, Object> serialize() {
 		Map<String, Object> data = new HashMap<String, Object>();
-		data.put("world", this.world.getName());
+		data.put("world", this.worldId);
 
-		data.put("x", this.x);
-		data.put("y", this.y);
-		data.put("z", this.z);
+		data.put("x", position.fineX());
+		data.put("y", position.fineY());
+		data.put("z", position.fineZ());
 
 		data.put("yaw", this.yaw);
 		data.put("pitch", this.pitch);
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -479,6 +479,8 @@ public interface Server extends PluginMessageRecipient, BukkitRuntime, tc.oc.min
      */
     public World getWorld(UUID uid);
 
+    World world(UUID uid);
+
     /**
      * Gets the map from the given item ID.
      *
diff --git a/src/main/java/org/bukkit/block/BlockFace.java b/src/main/java/org/bukkit/block/BlockFace.java
--- a/src/main/java/org/bukkit/block/BlockFace.java
+++ b/src/main/java/org/bukkit/block/BlockFace.java
@@ -1,43 +1,79 @@
 package org.bukkit.block;
 
+import java.util.Arrays;
+import java.util.List;
+
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.geometry.Vec3Coarse;
+import org.bukkit.util.ImVector;
+import org.bukkit.util.NumberConversions;
+
 /**
  * Represents the face of a block
  */
-public enum BlockFace {
-    NORTH(0, 0, -1),
-    EAST(1, 0, 0),
-    SOUTH(0, 0, 1),
-    WEST(-1, 0, 0),
-    UP(0, 1, 0),
-    DOWN(0, -1, 0),
-    NORTH_EAST(NORTH, EAST),
-    NORTH_WEST(NORTH, WEST),
-    SOUTH_EAST(SOUTH, EAST),
-    SOUTH_WEST(SOUTH, WEST),
-    WEST_NORTH_WEST(WEST, NORTH_WEST),
-    NORTH_NORTH_WEST(NORTH, NORTH_WEST),
-    NORTH_NORTH_EAST(NORTH, NORTH_EAST),
-    EAST_NORTH_EAST(EAST, NORTH_EAST),
-    EAST_SOUTH_EAST(EAST, SOUTH_EAST),
-    SOUTH_SOUTH_EAST(SOUTH, SOUTH_EAST),
-    SOUTH_SOUTH_WEST(SOUTH, SOUTH_WEST),
-    WEST_SOUTH_WEST(WEST, SOUTH_WEST),
-    SELF(0, 0, 0);
-
-    private final int modX;
-    private final int modY;
-    private final int modZ;
-
-    private BlockFace(final int modX, final int modY, final int modZ) {
-        this.modX = modX;
-        this.modY = modY;
-        this.modZ = modZ;
-    }
-
-    private BlockFace(final BlockFace face1, final BlockFace face2) {
-        this.modX = face1.getModX() + face2.getModX();
-        this.modY = face1.getModY() + face2.getModY();
-        this.modZ = face1.getModZ() + face2.getModZ();
+public enum BlockFace implements Vec3Coarse<Vec3> {
+    NORTH(8, 0, 0, -1),
+    EAST(12, 1, 0, 0),
+    SOUTH(0, 0, 0, 1),
+    WEST(4, -1, 0, 0),
+    UP(-1, 0, 1, 0),
+    DOWN(-1, 0, -1, 0),
+    NORTH_EAST(10, NORTH, EAST),
+    NORTH_WEST(6, NORTH, WEST),
+    SOUTH_EAST(14, SOUTH, EAST),
+    SOUTH_WEST(2, SOUTH, WEST),
+    WEST_NORTH_WEST(5, WEST, NORTH_WEST),
+    NORTH_NORTH_WEST(7, NORTH, NORTH_WEST),
+    NORTH_NORTH_EAST(9, NORTH, NORTH_EAST),
+    EAST_NORTH_EAST(11, EAST, NORTH_EAST),
+    EAST_SOUTH_EAST(13, EAST, SOUTH_EAST),
+    SOUTH_SOUTH_EAST(15, SOUTH, SOUTH_EAST),
+    SOUTH_SOUTH_WEST(1, SOUTH, SOUTH_WEST),
+    WEST_SOUTH_WEST(3, WEST, SOUTH_WEST),
+    SELF(-1, 0, 0, 0);
+
+    private final int blockYaw; // -1 for undefined
+    private final Vec3 direction;
+
+    BlockFace(final int blockYaw, final int modX, final int modY, final int modZ) {
+        this.blockYaw = blockYaw;
+        this.direction = ImVector.of(modX, modY, modZ);
+    }
+
+    BlockFace(final int blockYaw, final BlockFace face1, final BlockFace face2) {
+        this.blockYaw = blockYaw;
+        this.direction = face1.normal().plus(face2.normal());
+    }
+
+    public boolean isHorizontal() {
+        return blockYaw >= 0;
+    }
+
+    /**
+     * A number from 0 to 15 representing the yaw of this face.
+     *
+     * The number increases in the clockwise direction looking down,
+     * and 0 is due {@link #SOUTH}.
+     *
+     * @throws UnsupportedOperationException if this face is not oriented horizontally
+     */
+    public int blockYaw() {
+        if(blockYaw < 0) {
+            throw new UnsupportedOperationException("Face " + this + " is not a horizontal direction");
+        }
+        return blockYaw;
+    }
+
+    /**
+     * The yaw of this face in degrees, between -180 and +180
+     */
+    public float yaw() {
+        return (blockYaw() + 8) * (360F / 16F) - 180F;
+    }
+
+    public Vec3 normal() {
+        return direction;
     }
 
     /**
@@ -46,7 +82,7 @@ public enum BlockFace {
      * @return Amount of X-coordinates to modify
      */
     public int getModX() {
-        return modX;
+        return direction.coarseX();
     }
 
     /**
@@ -55,7 +91,7 @@ public enum BlockFace {
      * @return Amount of Y-coordinates to modify
      */
     public int getModY() {
-        return modY;
+        return direction.coarseY();
     }
 
     /**
@@ -64,7 +100,7 @@ public enum BlockFace {
      * @return Amount of Z-coordinates to modify
      */
     public int getModZ() {
-        return modZ;
+        return direction.coarseZ();
     }
 
     public BlockFace getOppositeFace() {
@@ -129,4 +165,154 @@ public enum BlockFace {
 
         return BlockFace.SELF;
     }
+
+    private static final List<BlockFace> HORIZONTAL;
+
+    static {
+        final BlockFace[] array = new BlockFace[16];
+        for(BlockFace face : values()) {
+            if(face.isHorizontal()) {
+                array[face.blockYaw()] = face;
+            }
+        }
+        HORIZONTAL = Arrays.asList(array);
+    }
+
+    private static final BlockFace[] DIAGONAL = new BlockFace[] {
+        SOUTH_EAST,
+        SOUTH_WEST,
+        NORTH_EAST,
+        NORTH_WEST,
+    };
+
+    private static final BlockFace[] DIAGONAL_Z = new BlockFace[] {
+        SOUTH_SOUTH_EAST,
+        SOUTH_SOUTH_WEST,
+        NORTH_NORTH_EAST,
+        NORTH_NORTH_WEST,
+    };
+
+    private static final BlockFace[] DIAGONAL_X = new BlockFace[] {
+        EAST_SOUTH_EAST,
+        WEST_SOUTH_WEST,
+        EAST_NORTH_EAST,
+        WEST_NORTH_WEST,
+    };
+
+    /**
+     * All horizontally oriented faces, starting with {@link #SOUTH}
+     * and increasing clockwise looking down.
+     */
+    public static List<BlockFace> horizontal() {
+        return HORIZONTAL;
+    }
+
+    /**
+     * The horizontal face representing the given yaw direction.
+     *
+     * The yaw is wrapped to fit in the range 0 to 15.
+     */
+    public static BlockFace byBlockYaw(int yaw) {
+        return HORIZONTAL.get(NumberConversions.mod(yaw, 16));
+    }
+
+    /**
+     * Return the horizontal face that is closest to the given yaw in degrees.
+     */
+    public static BlockFace byYaw(float degrees) {
+        return byBlockYaw(Math.round(degrees * (16F / 360F)));
+    }
+
+    public static BlockFace byDirection(Vec3 direction) {
+        if(direction instanceof BlockFace) return (BlockFace) direction;
+        return byDirection(direction.fineX(),
+                           direction.fineY(),
+                           direction.fineZ());
+    }
+
+    public static BlockFace byDirection(double x, double y, double z) {
+        if(y != 0) {
+            // vertical
+            if(x != 0 || z != 0) {
+                throw new IllegalArgumentException("No " + BlockFace.class.getSimpleName() +
+                                                   " for direction " + x + ", " + y + ", " + z);
+            }
+            return y > 0 ? UP : DOWN;
+        } else if(z == 0) {
+            // on X axis (including origin)
+            return x > 0 ? EAST : x < 0 ? WEST : SELF;
+        } else if(x == 0) {
+            // on Z axis
+            return z > 0 ? SOUTH : NORTH;
+        } else {
+            // diagonal
+            int quadrant = 0;
+            if(z < 0) quadrant += 2;
+            if(x < 0) quadrant += 1;
+
+            final double ax = Math.abs(x);
+            final double az = Math.abs(z);
+
+            if(ax > az) {
+                // X major
+                return DIAGONAL_X[quadrant];
+            } else if(ax < az) {
+                // Z major
+                return DIAGONAL_Z[quadrant];
+            } else {
+                // 45 degrees
+                return DIAGONAL[quadrant];
+            }
+        }
+    }
+
+    @Override
+    public int coarseX() {
+        return direction.coarseX();
+    }
+
+    @Override
+    public int coarseY() {
+        return direction.coarseY();
+    }
+
+    @Override
+    public int coarseZ() {
+        return direction.coarseZ();
+    }
+
+    @Override
+    public BlockFace copy() {
+        return this;
+    }
+
+    @Override
+    public MutableVec3 mutableCopy() {
+        return direction.mutableCopy();
+    }
+
+    @Override
+    public Vec3 fineCopy() {
+        return direction.fineCopy();
+    }
+
+    @Override
+    public Vec3 fineOf(double x, double y, double z) {
+        return direction.fineOf(x, y, z);
+    }
+
+    @Override
+    public Vec3 fineZero() {
+        return direction.fineZero();
+    }
+
+    @Override
+    public Vec3 coarseOf(int x, int y, int z) {
+        return direction.coarseOf(x, y, z);
+    }
+
+    @Override
+    public Vec3 coarseZero() {
+        return direction.coarseZero();
+    }
 }
diff --git a/src/main/java/org/bukkit/geometry/Axis.java b/src/main/java/org/bukkit/geometry/Axis.java
new file mode 100644
index 0000000..d0122e6
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Axis.java
@@ -0,0 +1,63 @@
+package org.bukkit.geometry;
+
+import org.bukkit.block.BlockFace;
+import org.bukkit.util.ImVector;
+
+/**
+ * Represents one of the three spatial axes
+ */
+public enum Axis {
+
+    X(ImVector.of(1, 0, 0)),
+    Y(ImVector.of(0, 1, 0)),
+    Z(ImVector.of(0, 0, 1));
+
+    public static final Axis EAST_WEST = X;
+    public static final Axis UP_DOWN = Y;
+    public static final Axis NORTH_SOUTH = Z;
+
+    private final Vec3 positive, negative;
+    private final BlockFace positiveFace, negativeFace;
+
+    Axis(Vec3 positive) {
+        this.positive = positive;
+        this.negative = positive.negate();
+        this.positiveFace = BlockFace.byDirection(this.positive);
+        this.negativeFace = BlockFace.byDirection(this.negative);
+    }
+
+    /**
+     * Is this axis horizontally oriented?
+     */
+    boolean isHorizontal() {
+        return this != Y;
+    }
+
+    /**
+     * Return a unit vector pointing in the positive direction along this axis
+     */
+    public Vec3 positive() {
+        return positive;
+    }
+
+    /**
+     * Return a unit vector pointing in the negative direction along this axis
+     */
+    public Vec3 negative() {
+        return negative;
+    }
+
+    /**
+     * Return the {@link BlockFace} facing in the positive direction along this axis
+     */
+    public BlockFace positiveFace() {
+        return positiveFace;
+    }
+
+    /**
+     * Return the {@link BlockFace} facing in the negative direction along this axis
+     */
+    public BlockFace negativeFace() {
+        return negativeFace;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/BlockReflection.java b/src/main/java/org/bukkit/geometry/BlockReflection.java
new file mode 100644
index 0000000..04d175c
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/BlockReflection.java
@@ -0,0 +1,56 @@
+package org.bukkit.geometry;
+
+/**
+ * A reflection transform that can be applied to blocks,
+ * i.e. reflection in either the X or Z axes, or no reflection at all.
+ */
+public enum BlockReflection {
+
+    NONE(IdentityTransform.INSTANCE),
+
+    LEFT_RIGHT(new BlockTransform(
+        1, 0,
+        0, -1,
+        0, 0, 0
+    )),
+
+    FRONT_BACK(new BlockTransform(
+        -1, 0,
+        0, 1,
+        0, 0, 0
+    ));
+
+    public static final BlockReflection X = FRONT_BACK;
+    public static final BlockReflection Z = LEFT_RIGHT;
+
+    public static final BlockReflection EAST_WEST = FRONT_BACK;
+    public static final BlockReflection NORTH_SOUTH = LEFT_RIGHT;
+
+    /**
+     * Return the reflection along the given {@link Axis}, which must be X or Z.
+     */
+    public static BlockReflection inAxis(Axis axis) {
+        switch(axis) {
+            case X: return FRONT_BACK;
+            case Z: return LEFT_RIGHT;
+        }
+        throw new IllegalArgumentException("Cannot reflect blocks in the " + axis + " axis");
+    }
+
+    private final CoarseTransform transform;
+
+    BlockReflection(CoarseTransform transform) {
+        this.transform = transform;
+    }
+
+    public boolean isIdentity() {
+        return this == NONE;
+    }
+
+    /**
+     * Return a {@link CoarseTransform} equivalent to this reflection.
+     */
+    public CoarseTransform transform() {
+        return transform;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/BlockRotation.java b/src/main/java/org/bukkit/geometry/BlockRotation.java
new file mode 100644
index 0000000..5e1bb1a
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/BlockRotation.java
@@ -0,0 +1,94 @@
+package org.bukkit.geometry;
+
+import org.bukkit.util.NumberConversions;
+
+/**
+ * A rotation transform that can be applied to blocks,
+ * i.e. a rotation around the Y axis in units of 90 degrees.
+ *
+ * Wherever rotations are represented as a number of turns,
+ * these turns are always clockwise looking down.
+ */
+public enum BlockRotation {
+
+    NONE(IdentityTransform.INSTANCE),
+    CLOCKWISE_90(makeTransform(1)),
+    CLOCKWISE_180(makeTransform(2)),
+    COUNTERCLOCKWISE_90(makeTransform(3));
+
+    public static final BlockRotation CLOCKWISE_270 = COUNTERCLOCKWISE_90;
+    public static final BlockRotation COUNTERCLOCKWISE_180 = CLOCKWISE_180;
+    public static final BlockRotation COUNTERCLOCKWISE_270 = CLOCKWISE_90;
+
+    private static int sin(int turns) {
+        switch(turns) {
+            default: return 0;
+            case 1: return 1;
+            case 3: return -1;
+        }
+    }
+
+    private static int cos(int turns) {
+        switch(turns) {
+            default: return 0;
+            case 0: return 1;
+            case 2: return -1;
+        }
+    }
+
+    private static CoarseTransform makeTransform(int turns) {
+        return new BlockTransform(
+            cos(turns), -sin(turns),
+            sin(turns), cos(turns),
+            0, 0, 0
+        );
+    }
+
+    /**
+     * Return the rotation for the given number of 90 degree clockwise turns.
+     *
+     * The number can be any positive or negative amount.
+     */
+    public static BlockRotation turns(int turns) {
+        return values()[NumberConversions.mod(turns, 4)];
+    }
+
+    private final CoarseTransform transform;
+
+    BlockRotation(CoarseTransform transform) {
+        this.transform = transform;
+    }
+
+    public boolean isIdentity() {
+        return this == NONE;
+    }
+
+    /**
+     * Return a {@link CoarseTransform} equivalent to this rotation.
+     */
+    public CoarseTransform transform() {
+        return transform;
+    }
+
+    /**
+     * Return the number of 90-degree clockwise turns for this rotation.
+     *
+     * This is always in the range 0 to 3 inclusive.
+     */
+    public int turns() {
+        return ordinal();
+    }
+
+    /**
+     * Apply this rotation to the given {@link Axis}
+     */
+    public Axis apply(Axis axis) {
+        if(turns() % 2 == 1) {
+            switch(axis) {
+                case X: return Axis.Z;
+                case Z: return Axis.X;
+            }
+        }
+        return axis;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/BlockRotoflection.java b/src/main/java/org/bukkit/geometry/BlockRotoflection.java
new file mode 100644
index 0000000..46e8655
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/BlockRotoflection.java
@@ -0,0 +1,149 @@
+package org.bukkit.geometry;
+
+import org.bukkit.util.NumberConversions;
+
+/**
+ * A combined reflection and rotation transform that can be applied to blocks.
+ *
+ * This class can represent any of the 8 transforms that affect only the state of a block (and not its position).
+ *
+ * The transform is always normalized to an optional reflection in the X axis,
+ * followed by a rotation of 0 to 3 clockwise right turns, around the Y axis, looking down.
+ */
+public class BlockRotoflection {
+
+    private static final BlockRotoflection[] NORMAL = new BlockRotoflection[] {
+        new BlockRotoflection(false, 0),
+        new BlockRotoflection(false, 1),
+        new BlockRotoflection(false, 2),
+        new BlockRotoflection(false, 3)
+    };
+
+    private static final BlockRotoflection[] INVERTED = new BlockRotoflection[] {
+        new BlockRotoflection(true, 0),
+        new BlockRotoflection(true, 1),
+        new BlockRotoflection(true, 2),
+        new BlockRotoflection(true, 3)
+    };
+
+    public static BlockRotoflection identity() {
+        return NORMAL[0];
+    }
+
+    /**
+     * Return the transform equivalent to the given operations
+     *
+     * @param reflect    Reflect in X axis
+     * @param turns      Number of clockwise right turns, around Y axis, facing down
+     */
+    public static BlockRotoflection of(boolean reflect, int turns) {
+        turns = NumberConversions.mod(turns, 4);
+        return reflect ? INVERTED[turns] : NORMAL[turns];
+    }
+
+    /**
+     * Return the transform equivalent to the given operations
+     */
+    public static BlockRotoflection of(BlockReflection reflection, BlockRotation rotation) {
+        if(reflection == BlockReflection.Z) {
+            // Normalize reflection axis to X
+            return of(true, rotation.turns() + 2);
+        } else {
+            return of(reflection == BlockReflection.X, rotation.turns());
+        }
+    }
+
+    /**
+     * Return the transform equivalent to the given reflection alone
+     */
+    public static BlockRotoflection of(BlockReflection reflection) {
+        return of(reflection, BlockRotation.NONE);
+    }
+
+    /**
+     * Return the transform equivalent to the given rotation alone
+     */
+    public static BlockRotoflection of(BlockRotation rotation) {
+        return of(false, rotation.turns());
+    }
+
+    private final BlockReflection reflection;
+    private final BlockRotation rotation;
+    private final CoarseTransform transform;
+
+    private BlockRotoflection(boolean reflect, int turns) {
+        this.reflection = reflect ? BlockReflection.X : BlockReflection.NONE;
+        this.rotation = BlockRotation.turns(turns);
+        this.transform = reflection.transform().andThen(rotation.transform());
+    }
+
+    public boolean isIdentity() {
+        return reflection.isIdentity() && rotation.isIdentity();
+    }
+
+    /**
+     * Return the reflection component of this transform,
+     * which is either {@link BlockReflection#NONE} or {@link BlockReflection#X}.
+     */
+    public BlockReflection reflection() {
+        return reflection;
+    }
+
+    /**
+     * Does this transform include a reflection?
+     */
+    boolean isReflected() {
+        return reflection != BlockReflection.NONE;
+    }
+
+    /**
+     * Return the rotation component of this transform
+     */
+    public BlockRotation rotation() {
+        return rotation;
+    }
+
+    /**
+     * Return the rotation component of this transform,
+     * as a count of clockwise right turns.
+     */
+    int turns() {
+        return rotation.turns();
+    }
+
+    /**
+     * Return a {@link CoarseTransform} equivalent to this transform
+     */
+    public CoarseTransform transform() {
+        return transform;
+    }
+
+    /**
+     * Apply this transform to the given {@link Axis}
+     */
+    public Axis apply(Axis axis) {
+        return rotation.apply(axis);
+    }
+
+    @Override
+    public int hashCode() {
+        return reflection.ordinal() * 4 +
+               rotation.ordinal();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+        return this == that || (
+            that instanceof BlockRotoflection &&
+            this.reflection.equals(((BlockRotoflection) that).reflection) &&
+            this.rotation.equals(((BlockRotoflection) that).rotation)
+        );
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{reflection=" + reflection +
+               " rotation=" + rotation + "}";
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/BlockTransform.java b/src/main/java/org/bukkit/geometry/BlockTransform.java
new file mode 100644
index 0000000..ddd24cd
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/BlockTransform.java
@@ -0,0 +1,237 @@
+package org.bukkit.geometry;
+
+import java.util.Arrays;
+
+import org.bukkit.Bukkit;
+
+/**
+ * Represents by a 4x4 matrix of the form:
+ *
+ *     [ xx  0   xz  xt ]
+ *     [ 0   1   0   yt ]
+ *     [ zx  0   zz  zt ]
+ *     [ 0   0   0   1  ]
+ *
+ * Where
+ *
+ *     xt, yt, zt are integers
+ *
+ * and
+ *
+ *     |  xx  xz  |
+ *     |          | = -1 or 1
+ *     |  zx  zz  |
+ *
+ * i.e. the determinant of the x-z minor 2x2 matrix is -1 or 1,
+ * which ensures that area is preserved in the x-z plane,
+ * though orientation may be inverted.
+ */
+class BlockTransform implements CoarseTransform {
+
+    private final int xx, xz,
+                      zx, zz;
+    private final int xt, yt, zt;
+
+    // The x-z determinant, might come in handy
+    private final int determinant;
+
+    // Cached inverse
+    private BlockTransform inverse;
+
+    BlockTransform(int xx, int xz, int zx, int zz, int xt, int yt, int zt) {
+        this(null, xx, xz, zx, zz, xt, yt, zt);
+    }
+
+    BlockTransform(BlockTransform inverse, int xx, int xz, int zx, int zz, int xt, int yt, int zt) {
+        this.determinant = xx * zz - xz * zx;
+
+        if(determinant != -1 && determinant != 1) {
+            throw new IllegalArgumentException(
+                "Invalid block transform - coefficients do not preserve area: [ " + xx + " " + xz + " ], [ " + zx + " " + zz + " ]"
+            );
+        }
+
+        this.inverse = inverse;
+
+        this.xx = xx; this.xz = xz;
+        this.zx = zx; this.zz = zz;
+
+        this.xt = xt; this.yt = yt; this.zt = zt;
+    }
+
+    @Override
+    public boolean isIdentity() {
+        return xx == 1 && xz == 0 &&
+               zx == 0 && zz == 1 &&
+               xt == 0 && yt == 0 && zt == 0;
+    }
+
+    @Override
+    public Vec3 apply(Vec3 v) {
+        if(v.isFine()) {
+            final double x = v.fineX();
+            final double y = v.fineY();
+            final double z = v.fineZ();
+
+            return Bukkit.vectors().fine(
+                x * xx + z * xz + xt,
+                y + yt,
+                x * zx + z * zz + zt
+            );
+        } else {
+            final int x = v.coarseX();
+            final int y = v.coarseY();
+            final int z = v.coarseZ();
+
+            return Bukkit.vectors().coarse(
+                x * xx + z * xz + xt,
+                y + yt,
+                x * zx + z * zz + zt
+            );
+        }
+    }
+
+    @Override
+    public void applyInPlace(MutableVec3 v) {
+        if(v.isFine()) {
+            final double x = v.fineX();
+            final double y = v.fineY();
+            final double z = v.fineZ();
+
+            v.set(
+                x * xx + z * xz + xt,
+                y + yt,
+                x * zx + z * zz + zt
+            );
+        } else {
+            final int x = v.coarseX();
+            final int y = v.coarseY();
+            final int z = v.coarseZ();
+
+            v.set(
+                x * xx + z * xz + xt,
+                y + yt,
+                x * zx + z * zz + zt
+            );
+        }
+    }
+
+    @Override
+    public CoarseTransform inverse() {
+        if(inverse == null) {
+            inverse = new BlockTransform(
+                this,
+                xx, zx,
+                xz, zz,
+                - xx * xt - zx * zt,
+                - yt,
+                - xz * xt - zz * zt
+            );
+        }
+        return inverse;
+    }
+
+    @Override
+    public CoarseTransform compose(CoarseTransform before) {
+        if(before instanceof BlockTransform) {
+            final BlockTransform that = (BlockTransform) before;
+            return new BlockTransform(
+                this.xx * that.xx + this.xz * that.zx, this.xx * that.xz + this.xz * that.zz,
+                this.zx * that.xx + this.zz * that.zx, this.zx * that.xz + this.zz * that.zz,
+                this.xx * that.xt + this.xz * that.zt + this.xt,
+                this.yt + that.yt,
+                this.zx * that.xt + this.zz * that.zt + this.zt
+            );
+        }
+
+        return before.andThen(this);
+    }
+
+    @Override
+    public Transform compose(Transform before) {
+        if(before instanceof CoarseTransform) {
+            return compose((CoarseTransform) before);
+        }
+
+        return before.andThen(this);
+    }
+
+    @Override
+    public CoarseTransform andThen(CoarseTransform after) {
+        return after.compose(this);
+    }
+
+    @Override
+    public Transform andThen(Transform after) {
+        return after.compose(this);
+    }
+
+    @Override
+    public BlockRotoflection orientation() {
+        /*
+
+        + 0     0 -     - 0     0 +
+        0 +     + 0     0 -     - 0
+
+        - 0     0 -     + 0     0 +
+        0 +     - 0     0 -     + 0
+
+         */
+        if(xx < 0) {
+            if(zz < 0) {
+                return BlockRotoflection.of(false, 2);
+            } else {
+                return BlockRotoflection.of(true, 0);
+            }
+        } else if(xx > 0) {
+            if(zz < 0) {
+                return BlockRotoflection.of(true, 2);
+            } else {
+                return BlockRotoflection.of(false, 0);
+            }
+        } else if(xz < 0) {
+            if(zx < 0) {
+                return BlockRotoflection.of(true, 1);
+            } else {
+                return BlockRotoflection.of(false, 1);
+            }
+        } else {
+            if(zx < 0) {
+                return BlockRotoflection.of(false, 3);
+            } else {
+                return BlockRotoflection.of(true, 3);
+            }
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        // Identity transform is always 0
+        return isIdentity() ? 0 : Arrays.hashCode(new int[]{xx, xz, zx, zz, xt, yt, zt});
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+
+        if(obj instanceof BlockTransform) {
+            final BlockTransform that = (BlockTransform) obj;
+            return this.xx == that.xx &&
+                   this.xz == that.xz &&
+                   this.zx == that.zx &&
+                   this.zz == that.zz &&
+                   this.xt == that.xt &&
+                   this.yt == that.yt &&
+                   this.zt == that.zt;
+        }
+
+        return obj.equals(this);
+    }
+
+    @Override
+    public String toString() {
+        return Transform.class.getSimpleName() +
+               "{orientation=" + orientation() +
+               " translation=(" + xt + ", " + yt + ", " + zt + ")}";
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/CoarseTransform.java b/src/main/java/org/bukkit/geometry/CoarseTransform.java
new file mode 100644
index 0000000..ef931bc
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/CoarseTransform.java
@@ -0,0 +1,59 @@
+package org.bukkit.geometry;
+
+/**
+ * A transform that can be applied to blocks, i.e. any combination
+ * of reflection along horizontal axes, right-angle rotation, and
+ * translation by integer offsets.
+ */
+public interface CoarseTransform extends Transform {
+
+    BlockRotoflection orientation();
+
+    @Override
+    CoarseTransform inverse();
+
+    CoarseTransform compose(CoarseTransform before);
+
+    CoarseTransform andThen(CoarseTransform after);
+
+    @Override
+    default CoarseTransform translate(int x, int y, int z) {
+        return andThen(translation(x, y, z));
+    }
+
+    @Override
+    default CoarseTransform translate(Vec3 offset) {
+        return andThen(translation(offset));
+    }
+
+    @Override
+    default CoarseTransform reflect(Axis axis) {
+        return andThen(reflection(axis));
+    }
+
+    @Override
+    default CoarseTransform rotate(int turns) {
+        return andThen(rotation(turns));
+    }
+
+    static CoarseTransform translation(int x, int y, int z) {
+        if(x == 0 && y == 0 && z == 0) return Transform.identity();
+        return new BlockTransform(
+            1, 0,
+            0, 1,
+            x, y, z
+        );
+    }
+
+    static CoarseTransform translation(Vec3 offset) {
+        return translation(offset.coarseX(), offset.coarseY(), offset.coarseZ());
+    }
+
+    static CoarseTransform reflection(Axis axis) {
+        return BlockReflection.inAxis(axis).transform();
+    }
+
+    static CoarseTransform rotation(int turns) {
+        return BlockRotation.turns(turns).transform();
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Cuboid.java b/src/main/java/org/bukkit/geometry/Cuboid.java
new file mode 100644
index 0000000..ba64e92
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Cuboid.java
@@ -0,0 +1,589 @@
+package org.bukkit.geometry;
+
+import java.util.Objects;
+import java.util.Random;
+
+import org.bukkit.Bukkit;
+import org.bukkit.region.BlockRegion;
+import org.bukkit.region.CuboidBlockRegion;
+import org.bukkit.util.ImVector;
+import org.bukkit.util.NumberConversions;
+import org.bukkit.util.Vector;
+
+/**
+ * Represents an axis-aligned cuboid (box) in fine (real-valued) coordinates
+ *
+ * In fine-space, all boundaries of the cuboid are closed. That is, points on
+ * any boundary are considered inside the cuboid. Blocks are considered inside
+ * the cuboid if and only if their center points are inside.
+ *
+ * Cuboids can be unbounded in any combination of the 6 directions, in which case
+ * the respective coordinate will be +/- Infinity.
+ *
+ * Cuboids can have zero length on any combination of axes, in which case the
+ * minimum and maximum coordinates on those axes will be equal. If any axis has
+ * zero length, then the cuboid has zero volume, but may still contain points
+ * that lie on the degenerate boundary.
+ *
+ * There is a single "empty cuboid" which has the following properties:
+ *
+ *      - It is equal only to itself.
+ *      - It contains no points or other spatial objects, except for itself.
+ *      - It is contained by all other cuboids.
+ *      - It's minimum and maximum points are the NaN vector, as are any other points
+ *        in space that are generated from the cuboid.
+ *      - Attempts to generate any coarse points will throw an {@link ArithmeticException}.
+ *      - Any relative measurements of the cuboid (such as size or volume) are zero.
+ *
+ * The empty cuboid is returned in these cases:
+ *
+ *      - Calling {@link #empty()}
+ *      - Trying to construct a cuboid with any NaN values
+ *      - Trying to construct a cuboid with negative length in any axis
+ *      - Trying to construct a cuboid enclosing an empty set of points
+ */
+public abstract class Cuboid implements Region {
+
+    protected final ImVector min;
+    protected final ImVector max;
+
+    Cuboid(Vec3 min, Vec3 max) {
+        this.min = ImVector.copyOf(min);
+        this.max = ImVector.copyOf(max);
+    }
+
+    /**
+     * Create a minimal cuboid enclosing the given pair of points
+     *
+     * The relative order of the points on any axis does not matter.
+     */
+    public static Cuboid between(Vec3 a, Vec3 b) {
+        if(a.anyNaN() || b.anyNaN()) return empty();
+        return new NonEmptyCuboid(a.minimum(b), a.maximum(b));
+    }
+
+    /**
+     * Create a cuboid with the given minimum corner and size
+     */
+    public static Cuboid fromMinAndSize(Vec3 min, Vec3 size) {
+        if(min.anyNaN() || size.anyNaN() ||
+           size.fineX() < 0 || size.fineY() < 0 || size.fineZ() < 0) return empty();
+        return new NonEmptyCuboid(min, min.plus(size));
+    }
+
+    /**
+     * Create a minimal bounding box containing all of the given points
+     */
+    public static Cuboid enclosing(Vec3... points) {
+        if(points.length == 0) return empty();
+
+        final Vector min = new Vector(Double.POSITIVE_INFINITY);
+        final Vector max = new Vector(Double.NEGATIVE_INFINITY);
+
+        for(Vec3 p : points) {
+            if(p.anyNaN()) return empty();
+            min.minimize(p);
+            max.maximize(p);
+        }
+
+        return between(min, max);
+    }
+
+    /**
+     * Return the cuboid that is unbounded in all directions
+     */
+    public static Cuboid unbounded() {
+        return NonEmptyCuboid.UNBOUNDED;
+    }
+
+    /**
+     * Return the inverse of the {@link #unbounded()} cuboid
+     */
+    public static Cuboid empty() {
+        return EmptyCuboid.INSTANCE;
+    }
+
+    /**
+     * Return the largest cuboid contained entirely within both of the given cuboids
+     */
+    public static Cuboid intersect(Cuboid a, Cuboid b) {
+        if(a.contains(b)) {
+            return b;
+        } else if(b.contains(a)) {
+            return a;
+        } else {
+            return between(a.min.maximum(b.min),
+                           a.max.minimum(b.max));
+        }
+    }
+
+    /**
+     * Return the smallest cuboid containing both of the given cuboids
+     */
+    public static Cuboid union(Cuboid a, Cuboid b) {
+        if(a.contains(b)) {
+            return a;
+        } else if(b.contains(a)) {
+            return b;
+        } else {
+            return between(a.min.minimum(b.min),
+                           a.max.maximum(b.max));
+        }
+    }
+
+    /**
+     * Return the smallest cuboid containing the given original cuboid, after subtracting the other given cuboid.
+     */
+    public static Cuboid complement(Cuboid original, Cuboid subtracted) {
+        // The booleans reflect if the subtracted set contains the
+        // original set on each axis. The final bounds for each axis
+        // are then the minimum of the two sets, if the other two axes
+        // are containing, otherwise the bounds of the original set.
+        boolean cx = subtracted.min.fineX() < original.min.fineX() && subtracted.max.fineX() > original.max.fineX();
+        boolean cy = subtracted.min.fineY() < original.min.fineY() && subtracted.max.fineY() > original.max.fineY();
+        boolean cz = subtracted.min.fineZ() < original.min.fineZ() && subtracted.max.fineZ() > original.max.fineZ();
+        return between(ImVector.of(cy && cz ? Math.max(original.min.fineX(), subtracted.min.fineX()) : original.min.fineX(),
+                                   cz && cx ? Math.max(original.min.fineY(), subtracted.min.fineY()) : original.min.fineY(),
+                                   cx && cy ? Math.max(original.min.fineZ(), subtracted.min.fineZ()) : original.min.fineZ()),
+                       ImVector.of(cy && cz ? Math.min(original.max.fineX(), subtracted.max.fineX()) : original.max.fineX(),
+                                   cz && cx ? Math.min(original.max.fineY(), subtracted.max.fineY()) : original.max.fineY(),
+                                   cx && cy ? Math.min(original.max.fineZ(), subtracted.max.fineZ()) : original.max.fineZ()));
+    }
+
+    @Override
+    public Cuboid bounds() {
+        return this;
+    }
+
+    /**
+     * Return the distance from the origin of the given ray to the point
+     * where it first intersects this cuboid. If the ray originates inside
+     * the cuboid, zero is returned.
+     *
+     * If the ray does not intersect the cuboid, but the line of the ray does
+     * intersect (behind the ray's origin), then a negative distance is returned.
+     *
+     * In any other case, NaN is returned.
+     */
+    public abstract double intersectionDistance(Ray ray);
+
+    /**
+     * Return the point at which the given ray enters this cuboid,
+     * or null if the ray does not intersect the cuboid. If the ray
+     * originates inside the cuboid, the ray's origin point is returned.
+     */
+    public abstract ImVector intersect(Ray ray);
+
+
+    /**
+     * Construct a cuboid by translating this cuboid by the given offset
+     */
+    public abstract Cuboid translate(Vec3 offset);
+
+    public abstract Cuboid transform(Transform transform);
+
+    /**
+     * Does this cuboid fully enclose the given cuboid?
+     */
+    public abstract boolean contains(Cuboid cuboid);
+
+    /**
+     * Return the minimum corner of this cuboid
+     */
+    public ImVector minimum() {
+        return min;
+    }
+
+    /**
+     * Return the maximum corner of this cuboid
+     */
+    public ImVector maximum() {
+        return max;
+    }
+
+    /**
+     * Return the dimensions of this cuboid
+     */
+    public ImVector size() {
+        return max.minus(min);
+    }
+
+    public double volume() {
+        final ImVector size = size();
+        return size.fineX() * size.fineY() * size.fineZ();
+    }
+
+    /**
+     * Return the center point of this cuboid
+     */
+    public ImVector center() {
+        return ImVector.copyOf(min.midway(max));
+    }
+
+    /**
+     * Return the eight corner points of this cuboid
+     */
+    public ImVector[] vertices() {
+        return new ImVector[] {
+            min,
+            ImVector.of(min.fineX(), min.fineY(), max.fineZ()),
+            ImVector.of(min.fineX(), max.fineY(), min.fineZ()),
+            ImVector.of(min.fineX(), max.fineY(), max.fineZ()),
+            ImVector.of(max.fineX(), min.fineY(), min.fineZ()),
+            ImVector.of(max.fineX(), min.fineY(), max.fineZ()),
+            ImVector.of(max.fineX(), max.fineY(), min.fineZ()),
+            max
+        };
+    }
+
+    /**
+     * Generate an evenly distributed random point inside this cuboid,
+     * using the given source of random numbers.
+     *
+     * {@link Random#nextDouble()} is used to choose the individual
+     * components, so the range of possible coordinates includes the
+     * lower bounds of the cuboid, but not the upper bounds.
+     *
+     * @throws ArithmeticException if the cuboid is unbounded
+     */
+    public abstract ImVector randomPointInside(Random random);
+
+    /**
+     * Return the lowest block with a center point inside this cuboid
+     */
+    public abstract Vec3 minimumBlockInside();
+
+    /**
+     * Return the highest block with a center point inside this cuboid
+     */
+    public abstract Vec3 maximumBlockInside();
+
+    /**
+     * Return the lowest block with a center point that is greater,
+     * on all axes, than any point in the cuboid.
+     *
+     * This block will have coordinates one greater than {@link #maximumBlockInside()}.
+     */
+    public abstract Vec3 minimumBlockOutside();
+
+    /**
+     * Return number of blocks on each axis with center points inside this cuboid.
+     */
+    public abstract Vec3 blockSize();
+}
+
+class NonEmptyCuboid extends Cuboid {
+
+    static final Cuboid UNBOUNDED = new NonEmptyCuboid(ImVector.of(Double.NEGATIVE_INFINITY),
+                                                       ImVector.of(Double.POSITIVE_INFINITY));
+
+    public NonEmptyCuboid(Vec3 min, Vec3 max) {
+        super(min, max);
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() + "{min=[" + min.toString() + "],max=[" + max.toString() + "]}";
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(min, max);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof Cuboid)) return false;
+        final Cuboid that = (Cuboid) obj;
+        return min.equals(that.minimum()) && max.equals(that.max);
+    }
+
+    /**
+     * Return the distance from the origin of the given ray to the point
+     * where it first intersects this cuboid. If the ray originates inside
+     * the cuboid, zero is returned.
+     *
+     * If the ray does not intersect the cuboid, but the line of the ray does
+     * intersect (behind the ray's origin), then a negative distance is returned.
+     *
+     * In any other case, NaN is returned.
+     */
+    public double intersectionDistance(Ray ray) {
+        // Find the distances to both boundaries on each axis
+        final ImVector d1 = min.minus(ray.origin()).over(ray.normal());
+        final ImVector d2 = max.minus(ray.origin()).over(ray.normal());
+
+        // Sort the distances into near and far for each axis
+        final ImVector near = d1.minimum(d2);
+        final ImVector far = d1.maximum(d2);
+
+        // Last near point enters the cuboid
+        // First far point exits the cuboid
+        final double enter = NumberConversions.max(near.fineX(), near.fineY(), near.fineZ());
+        final double exit = NumberConversions.min(far.fineX(), far.fineY(), far.fineZ());
+
+        // If the ray enters the cuboid before it exits, then it intersects
+        return enter <= exit ? enter : Double.NaN;
+    }
+
+    /**
+     * Return the point at which the given ray enters this cuboid,
+     * or null if the ray does not intersect the cuboid. If the ray
+     * originates inside the cuboid, the ray's origin point is returned.
+     */
+    public ImVector intersect(Ray ray) {
+        final double distance = intersectionDistance(ray);
+        if(distance == 0) {
+            return ray.origin();
+        } else if(distance > 0) {
+            return ray.origin().plus(ray.normal().times(distance));
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Construct a cuboid by translating this cuboid by the given offset
+     */
+    public Cuboid translate(Vec3 offset) {
+        return offset.isZero() ? this : new NonEmptyCuboid(min.plus(offset), max.plus(offset));
+    }
+
+    public Cuboid transform(Transform transform) {
+        return transform.isIdentity() ? this : new NonEmptyCuboid(transform.apply(min), transform.apply(max));
+    }
+
+    public boolean isFinite() {
+        return !(Double.isInfinite(min.fineX()) || Double.isInfinite(max.fineX()) ||
+                 Double.isInfinite(min.fineY()) || Double.isInfinite(max.fineY()) ||
+                 Double.isInfinite(min.fineZ()) || Double.isInfinite(max.fineZ()));
+    }
+
+    public boolean isBlockFinite() {
+        return !(Double.isInfinite(min.fineX()) || Double.isInfinite(max.fineX()) ||
+                 Double.isInfinite(min.fineZ()) || Double.isInfinite(max.fineZ()));
+    }
+
+    public boolean isEmpty() {
+        return false;
+    }
+
+    public boolean contains(Vec3 point) {
+        return min.fineLessOrEqual(point) && max.fineGreaterOrEqual(point);
+    }
+
+    /**
+     * Does this cuboid fully enclose the given cuboid?
+     */
+    public boolean contains(Cuboid cuboid) {
+        return cuboid.isEmpty() || (contains(cuboid.minimum()) && cuboid.contains(minimum()));
+    }
+
+    /**
+     * Generate an evenly distributed random point inside this cuboid,
+     * using the given source of random numbers.
+     *
+     * {@link Random#nextDouble()} is used to choose the individual
+     * components, so the range of possible coordinates includes the
+     * lower bounds of the cuboid, but not the upper bounds.
+     *
+     * @throws ArithmeticException if the cuboid is unbounded
+     */
+    public ImVector randomPointInside(Random random) {
+        assertFinite();
+        final ImVector size = size();
+        return min.plus(size.fineX() * random.nextDouble(),
+                        size.fineY() * random.nextDouble(),
+                        size.fineZ() * random.nextDouble());
+    }
+
+    /**
+     * Return the lowest block with a center point inside this cuboid
+     */
+    public Vec3 minimumBlockInside() {
+        assertBlockFinite();
+        return Bukkit.vectors().coarse(min.fineX() + 0.5d,
+                                       NumberConversions.clamp(min.fineY(), 0, 256) + 0.5d,
+                                       min.fineZ() + 0.5d);
+    }
+
+    /**
+     * Return the highest block with a center point inside this cuboid
+     */
+    public Vec3 maximumBlockInside() {
+        assertBlockFinite();
+        return Bukkit.vectors().coarse(max.fineX() - 0.5d,
+                                       NumberConversions.clamp(max.fineY(), 0, 256) - 0.5d,
+                                       max.fineZ() - 0.5d);
+    }
+
+    /**
+     * Return the lowest block with a center point that is greater,
+     * on all axes, than any point in the cuboid.
+     *
+     * This block will have coordinates one greater than {@link #maximumBlockInside()}.
+     */
+    public Vec3 minimumBlockOutside() {
+        assertBlockFinite();
+        return Bukkit.vectors().coarse(max.fineX() + 0.5d,
+                                       NumberConversions.clamp(max.fineY(), 0, 256) + 0.5d,
+                                       max.fineZ() + 0.5d);
+    }
+
+    public boolean containsBlock(Vec3 v) {
+        return v.coarseGreaterOrEqual(minimumBlockInside()) &&
+               v.coarseLess(minimumBlockOutside());
+    }
+
+    /**
+     * Return number of blocks on each axis with center points inside this cuboid.
+     */
+    public Vec3 blockSize() {
+        return minimumBlockOutside().minus(minimumBlockInside());
+    }
+
+    public int blockVolume() {
+        final Vec3 size = blockSize();
+        if(size.coarseX() <= 0 || size.coarseY() <= 0 || size.coarseZ() <= 0) return 0;
+        return size.coarseX() * size.coarseY() * size.coarseZ();
+    }
+
+    public boolean isBlockEmpty() {
+        return blockVolume() <= 0;
+    }
+
+    public Vec3 randomBlockInside(Random random) {
+        final Vec3 size = blockSize();
+        if(size.coarseX() <= 0 || size.coarseY() <= 0 || size.coarseZ() <= 0) {
+            throw new ArithmeticException("Cuboid contains no blocks");
+        }
+
+        return minimumBlockInside().plus(random.nextInt(size.coarseX()),
+                                         random.nextInt(size.coarseY()),
+                                         random.nextInt(size.coarseZ()));
+    }
+
+    public BlockRegion blockRegion() {
+        return CuboidBlockRegion.fromMinAndSize(minimumBlockInside(), blockSize());
+    }
+}
+
+class EmptyCuboid extends Cuboid implements EmptyRegion {
+
+    static final EmptyCuboid INSTANCE = new EmptyCuboid();
+
+    private EmptyCuboid() {
+        super(ImVector.ofNaN(), ImVector.ofNaN());
+    }
+
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return obj instanceof Region && ((Region) obj).isEmpty();
+    }
+
+    @Override
+    public double intersectionDistance(Ray ray) {
+        return Double.NaN;
+    }
+
+    @Override
+    public ImVector intersect(Ray ray) {
+        return null;
+    }
+
+    @Override
+    public Cuboid translate(Vec3 offset) {
+        return this;
+    }
+
+    @Override
+    public Cuboid transform(Transform transform) {
+        return this;
+    }
+
+    @Override
+    public boolean isFinite() {
+        return true;
+    }
+
+    @Override
+    public boolean isBlockFinite() {
+        return true;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return true;
+    }
+
+    @Override
+    public boolean isBlockEmpty() {
+        return true;
+    }
+
+    @Override
+    public boolean contains(Vec3 point) {
+        return false;
+    }
+
+    @Override
+    public boolean contains(Cuboid cuboid) {
+        return cuboid.isEmpty();
+    }
+
+    @Override
+    public ImVector size() {
+        return ImVector.ofZero();
+    }
+
+    @Override
+    public double volume() {
+        return 0;
+    }
+
+    @Override
+    public ImVector randomPointInside(Random random) {
+        return ImVector.ofNaN();
+    }
+
+    @Override
+    public boolean containsBlock(Vec3 v) {
+        return false;
+    }
+
+    @Override
+    public Vec3 blockSize() {
+        return ImVector.ofZero();
+    }
+
+    @Override
+    public int blockVolume() {
+        return 0;
+    }
+
+    @Override
+    public BlockRegion blockRegion() {
+        return BlockRegion.empty();
+    }
+
+    @Override
+    public Vec3 minimumBlockInside() {
+        throw new ArithmeticException("Region is empty");
+    }
+
+    @Override
+    public Vec3 maximumBlockInside() {
+        throw new ArithmeticException("Region is empty");
+    }
+
+    @Override
+    public Vec3 minimumBlockOutside() {
+        throw new ArithmeticException("Region is empty");
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/geometry/Direction.java b/src/main/java/org/bukkit/geometry/Direction.java
new file mode 100644
index 0000000..4b193c1
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Direction.java
@@ -0,0 +1,79 @@
+package org.bukkit.geometry;
+
+import org.bukkit.Bukkit;
+
+public class Direction {
+
+    private static final double TWO_PI = Math.PI * 2, HALF_PI = Math.PI / 2;
+
+    private final double yaw, pitch;
+
+    private Direction(double yaw, double pitch) {
+        this.yaw = yaw;
+        this.pitch = pitch;
+    }
+
+    public double yaw() {
+        return yaw;
+    }
+
+    public double pitch() {
+        return pitch;
+    }
+
+    public float yawDegrees() {
+        return (float) Math.toDegrees(yaw);
+    }
+
+    public float pitchDegrees() {
+        return (float) Math.toDegrees(pitch);
+    }
+
+    public Vec3 toVector() {
+        final double cos = Math.cos(pitch);
+        return Bukkit.vectors().fine(
+            -cos * Math.sin(yaw),
+            -Math.sin(pitch),
+            cos * Math.cos(yaw)
+        );
+    }
+
+    public static Direction of(double yaw, double pitch) {
+        return new Direction((yaw + TWO_PI) % TWO_PI, pitch);
+    }
+
+    public static Direction ofDegrees(double yaw, double pitch) {
+        return of(Math.toRadians(yaw), Math.toRadians(pitch));
+    }
+
+    public static Direction fromVector(double x, double y, double z) {
+        if (x == 0 && z == 0) {
+            return new Direction(0, y > 0 ? -HALF_PI : HALF_PI);
+        }
+
+        final double xz = Math.sqrt(x * x + z * z);
+        return of(Math.atan2(-x, z), Math.atan(-y / xz));
+    }
+
+    @Override
+    public int hashCode() {
+        return Double.hashCode(yaw) * 31 + Double.hashCode(pitch);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof Direction)) return false;
+        final Direction that = (Direction) obj;
+        return this.yaw == that.yaw() &&
+               this.pitch == that.pitch();
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{yaw=" + yaw +
+               " pitch=" + pitch +
+               "}";
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/EmptyRegion.java b/src/main/java/org/bukkit/geometry/EmptyRegion.java
new file mode 100644
index 0000000..578e718
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/EmptyRegion.java
@@ -0,0 +1,82 @@
+package org.bukkit.geometry;
+
+import java.util.Random;
+
+import org.bukkit.region.BlockRegion;
+import org.bukkit.util.ImVector;
+
+public interface EmptyRegion extends Region {
+
+    default int standardHashCode() {
+        return 0;
+    }
+
+    default boolean standardEquals(Object obj) {
+        return obj instanceof Region && ((Region) obj).isEmpty();
+    }
+
+    @Override
+    default boolean isEmpty() {
+        return true;
+    }
+
+    @Override
+    default boolean isBlockEmpty() {
+        return true;
+    }
+
+    @Override
+    default boolean isFinite() {
+        return true;
+    }
+
+    @Override
+    default boolean isBlockFinite() {
+        return true;
+    }
+
+    @Override
+    default double volume() {
+        return 0;
+    }
+
+    @Override
+    default int blockVolume() {
+        return 0;
+    }
+
+    @Override
+    default boolean contains(Vec3 point) {
+        return false;
+    }
+
+    @Override
+    default boolean containsBlock(Vec3 v) {
+        return false;
+    }
+
+    @Override
+    default Vec3 randomPointInside(Random random) {
+        return ImVector.ofNaN();
+    }
+
+    @Override
+    default Vec3 randomBlockInside(Random random) {
+        throw new ArithmeticException("Region is empty");
+    }
+
+    @Override
+    default Cuboid bounds() {
+        return Cuboid.empty();
+    }
+
+    @Override
+    default BlockRegion blockRegion() {
+        return BlockRegion.empty();
+    }
+
+    @Override
+    default Region transform(Transform transform) {
+        return this;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Everywhere.java b/src/main/java/org/bukkit/geometry/Everywhere.java
new file mode 100644
index 0000000..1c535db
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Everywhere.java
@@ -0,0 +1,81 @@
+package org.bukkit.geometry;
+
+import java.util.Random;
+
+import org.bukkit.region.BlockRegion;
+
+class Everywhere implements Region {
+
+    static final Everywhere INSTANCE = new Everywhere();
+
+    private Everywhere() {}
+
+    @Override
+    public boolean isEmpty() {
+        return false;
+    }
+
+    @Override
+    public boolean isBlockEmpty() {
+        return false;
+    }
+
+    @Override
+    public boolean isFinite() {
+        return false;
+    }
+
+    @Override
+    public boolean isBlockFinite() {
+        return false;
+    }
+
+    @Override
+    public double volume() {
+        return Double.POSITIVE_INFINITY;
+    }
+
+    @Override
+    public int blockVolume() throws ArithmeticException {
+        assertBlockFinite();
+        return 0;
+    }
+
+    @Override
+    public boolean contains(Vec3 point) {
+        return true;
+    }
+
+    @Override
+    public boolean containsBlock(Vec3 v) {
+        return true;
+    }
+
+    @Override
+    public Vec3 randomPointInside(Random random) throws ArithmeticException {
+        assertFinite();
+        return null;
+    }
+
+    @Override
+    public Vec3 randomBlockInside(Random random) throws ArithmeticException {
+        assertBlockFinite();
+        return null;
+    }
+
+    @Override
+    public Cuboid bounds() {
+        return Cuboid.unbounded();
+    }
+
+    @Override
+    public BlockRegion blockRegion() throws ArithmeticException {
+        assertBlockFinite();
+        return null;
+    }
+
+    @Override
+    public Region transform(Transform transform) {
+        return this;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/IdentityTransform.java b/src/main/java/org/bukkit/geometry/IdentityTransform.java
new file mode 100644
index 0000000..827316c
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/IdentityTransform.java
@@ -0,0 +1,75 @@
+package org.bukkit.geometry;
+
+import org.bukkit.block.BlockFace;
+
+class IdentityTransform implements CoarseTransform {
+
+    static final IdentityTransform INSTANCE = new IdentityTransform();
+
+    private IdentityTransform() {}
+
+    @Override
+    public boolean isIdentity() {
+        return true;
+    }
+
+    @Override
+    public CoarseTransform inverse() {
+        return this;
+    }
+
+    @Override
+    public Vec3 apply(Vec3 v) {
+        return v.copy();
+    }
+
+    @Override
+    public void applyInPlace(MutableVec3 v) {
+    }
+
+    @Override
+    public BlockFace apply(BlockFace face) {
+        return face;
+    }
+
+    @Override
+    public CoarseTransform compose(CoarseTransform before) {
+        return before;
+    }
+
+    @Override
+    public CoarseTransform andThen(CoarseTransform after) {
+        return after;
+    }
+
+    @Override
+    public Transform compose(Transform before) {
+        return before;
+    }
+
+    @Override
+    public Transform andThen(Transform after) {
+        return after;
+    }
+
+    @Override
+    public BlockRotoflection orientation() {
+        return BlockRotoflection.identity();
+    }
+
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object that) {
+        return that instanceof Transform &&
+               ((Transform) that).isIdentity();
+    }
+
+    @Override
+    public String toString() {
+        return Transform.class.getSimpleName() + "{identity}";
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/MutableVec3.java b/src/main/java/org/bukkit/geometry/MutableVec3.java
new file mode 100644
index 0000000..f2b8525
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/MutableVec3.java
@@ -0,0 +1,123 @@
+package org.bukkit.geometry;
+
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntUnaryOperator;
+
+/**
+ * Extends {@link Vec3} with mutating methods.
+ *
+ * All mutating methods return the vector they are called on.
+ *
+ * Due to the sordid history of Bukkit vector types, some implementors
+ * of this interface are NOT, in fact, mutable. However, all vectors that
+ * are mutable do implement this interface.
+ *
+ * @see MutableVec3Coarse
+ * @see MutableVec3Fine
+ */
+public interface MutableVec3 extends Vec3 {
+
+    /**
+     * Return an unmodifiable view of this vector
+     */
+    Vec3 unmodifiable();
+
+    MutableVec3 setX(double x);
+    MutableVec3 setY(double y);
+    MutableVec3 setZ(double z);
+
+    MutableVec3 setX(int x);
+    MutableVec3 setY(int y);
+    MutableVec3 setZ(int z);
+
+    MutableVec3 set(int x, int y, int z);
+    MutableVec3 set(double x, double y, double z);
+    MutableVec3 set(Vec3 v);
+
+    MutableVec3 setZero();
+
+    MutableVec3 modify(IntUnaryOperator op);
+    MutableVec3 modify(DoubleUnaryOperator op);
+    MutableVec3 modify(Vec3 v, IntBinaryOperator op);
+    MutableVec3 modify(Vec3 v, DoubleBinaryOperator op);
+
+    MutableVec3 add(int x, int y, int z);
+    MutableVec3 add(double x, double y, double z);
+    MutableVec3 add(Vec3 v);
+
+    MutableVec3 subtract(int x, int y, int z);
+    MutableVec3 subtract(double x, double y, double z);
+    MutableVec3 subtract(Vec3 v);
+
+    MutableVec3 multiply(int x, int y, int z);
+    MutableVec3 multiply(double x, double y, double z);
+    MutableVec3 multiply(Vec3 v);
+
+    MutableVec3 divide(int x, int y, int z);
+    MutableVec3 divide(double x, double y, double z);
+    MutableVec3 divide(Vec3 v);
+
+    MutableVec3 minimize(Vec3 v);
+    MutableVec3 maximize(Vec3 v);
+    MutableVec3 clamp(Vec3 min, Vec3 max);
+
+    default MutableVec3 set(Axis axis, double n) {
+        switch(axis) {
+            case X: return setX(n);
+            case Y: return setY(n);
+            case Z: return setZ(n);
+        }
+        throw new IllegalStateException();
+    }
+
+    default MutableVec3 set(Axis axis, int n) {
+        switch(axis) {
+            case X: return setX(n);
+            case Y: return setY(n);
+            case Z: return setZ(n);
+        }
+        throw new IllegalStateException();
+    }
+
+    default MutableVec3 set(int xyz) {
+        return set(xyz, xyz, xyz);
+    }
+
+    default MutableVec3 set(double xyz) {
+        return set(xyz, xyz, xyz);
+    }
+
+    default MutableVec3 add(int xyz) {
+        return add(xyz, xyz, xyz);
+    }
+
+    default MutableVec3 add(double xyz) {
+        return add(xyz, xyz, xyz);
+    }
+
+    default MutableVec3 subtract(int xyz) {
+        return subtract(xyz, xyz, xyz);
+    }
+
+    default MutableVec3 subtract(double xyz) {
+        return subtract(xyz, xyz, xyz);
+    }
+
+    default MutableVec3 multiply(int n) {
+        return multiply(n, n, n);
+    }
+
+    default MutableVec3 multiply(double n) {
+        return multiply(n, n, n);
+    }
+
+    default MutableVec3 divide(int n) {
+        return divide(n, n, n);
+    }
+
+    default MutableVec3 divide(double n) {
+        return divide(n, n, n);
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/MutableVec3Coarse.java b/src/main/java/org/bukkit/geometry/MutableVec3Coarse.java
new file mode 100644
index 0000000..4dc203e
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/MutableVec3Coarse.java
@@ -0,0 +1,189 @@
+package org.bukkit.geometry;
+
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntUnaryOperator;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Base implementation for mutable coarse vectors.
+ *
+ * This interface is intended to help with implementation of the API.
+ * It should NOT be used by consumers of the API.
+ *
+ * @see MutableVec3Fine
+ */
+public interface MutableVec3Coarse<V extends Vec3, M extends MutableVec3Coarse<V, M>> extends MutableVec3, Vec3Coarse<V> {
+
+    @Override M setX(int x);
+    @Override M setY(int y);
+    @Override M setZ(int z);
+
+    @Override
+    M set(int x, int y, int z);
+
+    @Override
+    default boolean isMutable() {
+        return true;
+    }
+
+    @Override
+    default V copy() {
+        return coarseOf(coarseX(), coarseY(), coarseZ());
+    }
+
+    @Override
+    default M setX(double x) {
+        return setX(NumberConversions.floor(x));
+    }
+
+    @Override
+    default M setY(double y) {
+        return setY(NumberConversions.floor(y));
+    }
+
+    @Override
+    default M setZ(double z) {
+        return setZ(NumberConversions.floor(z));
+    }
+
+    @Override
+    default M setZero() {
+        return set(0, 0, 0);
+    }
+
+    @Override
+    default M set(double x, double y, double z) {
+        return set(NumberConversions.floor(x),
+                   NumberConversions.floor(y),
+                   NumberConversions.floor(z));
+    }
+
+    @Override
+    default M set(Vec3 v) {
+        return set(v.coarseX(),
+                   v.coarseY(),
+                   v.coarseZ());
+    }
+
+    @Override
+    default M modify(IntUnaryOperator op) {
+        return set(op.applyAsInt(coarseX()),
+                   op.applyAsInt(coarseY()),
+                   op.applyAsInt(coarseZ()));
+    }
+
+    @Override
+    default M modify(DoubleUnaryOperator op) {
+        return set(op.applyAsDouble(fineX()),
+                   op.applyAsDouble(fineY()),
+                   op.applyAsDouble(fineZ()));
+    }
+
+    @Override
+    default M modify(Vec3 v, IntBinaryOperator op) {
+        return set(op.applyAsInt(coarseX(), v.coarseX()),
+                   op.applyAsInt(coarseY(), v.coarseY()),
+                   op.applyAsInt(coarseZ(), v.coarseZ()));
+    }
+
+    @Override
+    default M modify(Vec3 v, DoubleBinaryOperator op) {
+        return set(op.applyAsDouble(fineX(), v.fineX()),
+                   op.applyAsDouble(fineY(), v.fineY()),
+                   op.applyAsDouble(fineZ(), v.fineZ()));
+    }
+
+    @Override
+    default M minimize(Vec3 v) {
+        return modify(v, (IntBinaryOperator) Math::min);
+    }
+
+    @Override
+    default M maximize(Vec3 v) {
+        return modify(v, (IntBinaryOperator) Math::max);
+    }
+
+    @Override
+    default M clamp(Vec3 min, Vec3 max) {
+        Preconditions.checkArgument(min.coarseLessOrEqual(max));
+        return set(NumberConversions.clamp(coarseX(), min.coarseX(), max.coarseX()),
+                   NumberConversions.clamp(coarseY(), min.coarseY(), max.coarseY()),
+                   NumberConversions.clamp(coarseZ(), min.coarseZ(), max.coarseZ()));
+    }
+
+    @Override
+    default M add(int x, int y, int z) {
+        return set(coarseX() + x,
+                   coarseY() + y,
+                   coarseZ() + z);
+    }
+
+    @Override
+    default M add(double x, double y, double z) {
+        return add(NumberConversions.floor(x),
+                   NumberConversions.floor(y),
+                   NumberConversions.floor(z));
+    }
+
+    @Override
+    default M add(Vec3 v) {
+        return add(v.coarseX(),
+                   v.coarseY(),
+                   v.coarseZ());
+    }
+
+    @Override
+    default M subtract(double x, double y, double z) {
+        // Be careful to floor AFTER negating
+        return add(-x, -y, -z);
+    }
+
+    @Override
+    default M subtract(int x, int y, int z) {
+        return set(coarseX() - x,
+                   coarseY() - y,
+                   coarseZ() - z);
+    }
+
+    @Override
+    default M subtract(Vec3 v) {
+        return v.isFine() ? subtract(v.fineX(), v.fineY(), v.fineZ())
+                          : subtract(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    @Override
+    default M multiply(int x, int y, int z) {
+        return set(coarseX() * x, coarseY() * y, coarseZ() * z);
+    }
+
+    @Override
+    default M multiply(double x, double y, double z) {
+        return set(coarseX() * x, coarseY() * y, coarseZ() * z);
+    }
+
+    @Override
+    default M multiply(Vec3 v) {
+        return v.isFine() ? multiply(v.fineX(), v.fineY(), v.fineZ())
+                          : multiply(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    @Override
+    default M divide(int x, int y, int z) {
+        return set(coarseX() / x, coarseY() / y, coarseZ() / z);
+    }
+
+    @Override
+    default M divide(double x, double y, double z) {
+        return set(coarseX() / x, coarseY() / y, coarseZ() / z);
+    }
+
+    @Override
+    default M divide(Vec3 v) {
+        return v.isFine() ? divide(v.fineX(), v.fineY(), v.fineZ())
+                          : divide(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/MutableVec3Fine.java b/src/main/java/org/bukkit/geometry/MutableVec3Fine.java
new file mode 100644
index 0000000..62efc4a
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/MutableVec3Fine.java
@@ -0,0 +1,177 @@
+package org.bukkit.geometry;
+
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntUnaryOperator;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Base implementation for mutable fine vectors.
+ *
+ * This interface is intended to help with implementation of the API.
+ * It should NOT be used by consumers of the API.
+ *
+ * @see MutableVec3Coarse
+ */
+public interface MutableVec3Fine<V extends Vec3, M extends MutableVec3Fine<V, M>> extends MutableVec3, Vec3Fine<V> {
+
+    @Override M setX(double x);
+    @Override M setY(double y);
+    @Override M setZ(double z);
+
+    @Override
+    M set(double x, double y, double z);
+
+    @Override
+    default boolean isMutable() {
+        return true;
+    }
+
+    @Override
+    default V copy() {
+        return fineOf(fineX(), fineY(), fineZ());
+    }
+
+    @Override
+    default M setZero() {
+        return set(0, 0, 0);
+    }
+
+    @Override
+    default M setX(int x) {
+        return setX((double) x);
+    }
+
+    @Override
+    default M setY(int y) {
+        return setX((double) y);
+    }
+
+    @Override
+    default M setZ(int z) {
+        return setX((double) z);
+    }
+
+    @Override
+    default M set(int x, int y, int z) {
+        return set((double) x, (double) y, (double) z);
+    }
+
+    @Override
+    default M set(Vec3 v) {
+        return set(v.fineX(), v.fineY(), v.fineZ());
+    }
+
+    @Override
+    default M modify(IntUnaryOperator op) {
+        return set(op.applyAsInt(coarseX()),
+                   op.applyAsInt(coarseY()),
+                   op.applyAsInt(coarseZ()));
+    }
+
+    @Override
+    default M modify(DoubleUnaryOperator op) {
+        return set(op.applyAsDouble(fineX()),
+                   op.applyAsDouble(fineY()),
+                   op.applyAsDouble(fineZ()));
+    }
+
+    @Override
+    default M modify(Vec3 v, IntBinaryOperator op) {
+        return set(op.applyAsInt(coarseX(), v.coarseX()),
+                   op.applyAsInt(coarseY(), v.coarseY()),
+                   op.applyAsInt(coarseZ(), v.coarseZ()));
+    }
+
+    @Override
+    default M modify(Vec3 v, DoubleBinaryOperator op) {
+        return set(op.applyAsDouble(fineX(), v.fineX()),
+                   op.applyAsDouble(fineY(), v.fineY()),
+                   op.applyAsDouble(fineZ(), v.fineZ()));
+    }
+
+    @Override
+    default M minimize(Vec3 v) {
+        return set(Math.min(fineX(), v.fineX()),
+                   Math.min(fineY(), v.fineY()),
+                   Math.min(fineZ(), v.fineZ()));
+    }
+
+    @Override
+    default M maximize(Vec3 v) {
+        return set(Math.max(fineX(), v.fineX()),
+                   Math.max(fineY(), v.fineY()),
+                   Math.max(fineZ(), v.fineZ()));
+    }
+
+    @Override
+    default M clamp(Vec3 min, Vec3 max) {
+        Preconditions.checkArgument(min.fineLessOrEqual(max));
+        return set(NumberConversions.clamp(fineX(), min.fineX(), max.fineX()),
+                   NumberConversions.clamp(fineY(), min.fineY(), max.fineY()),
+                   NumberConversions.clamp(fineZ(), min.fineZ(), max.fineZ()));
+    }
+
+    @Override
+    default M add(int x, int y, int z) {
+        return add((double) x, (double) y, (double) z);
+    }
+
+    @Override
+    default M add(double x, double y, double z) {
+        return set(fineX() + x, fineY() + y, fineZ() + z);
+    }
+
+    @Override
+    default M add(Vec3 v) {
+        return add(v.fineX(), v.fineY(), v.fineZ());
+    }
+
+    @Override
+    default M subtract(int x, int y, int z) {
+        return subtract((double) x, (double) y, (double) z);
+    }
+
+    @Override
+    default M subtract(double x, double y, double z) {
+        return set(fineX() - x, fineY() - y, fineZ() - z);
+    }
+
+    @Override
+    default M subtract(Vec3 v) {
+        return subtract(v.fineX(), v.fineY(), v.fineZ());
+    }
+
+    @Override
+    default M multiply(int x, int y, int z) {
+        return set(fineX() * x, fineY() * y, fineZ() * z);
+    }
+
+    @Override
+    default M multiply(double x, double y, double z) {
+        return set(fineX() * x, fineY() * y, fineZ() * z);
+    }
+
+    @Override
+    default M multiply(Vec3 v) {
+        return multiply(v.fineX(), v.fineY(), v.fineZ());
+    }
+
+    @Override
+    default M divide(int x, int y, int z) {
+        return set(fineX() / x, fineY() / y, fineZ() / z);
+    }
+
+    @Override
+    default M divide(double x, double y, double z) {
+        return set(fineX() / x, fineY() / y, fineZ() / z);
+    }
+
+    @Override
+    default M divide(Vec3 v) {
+        return divide(v.fineX(), v.fineY(), v.fineZ());
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Nowhere.java b/src/main/java/org/bukkit/geometry/Nowhere.java
new file mode 100644
index 0000000..ca7b26d
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Nowhere.java
@@ -0,0 +1,8 @@
+package org.bukkit.geometry;
+
+class Nowhere implements EmptyRegion {
+
+    static final Nowhere INSTANCE = new Nowhere();
+
+    private Nowhere() {}
+}
diff --git a/src/main/java/org/bukkit/geometry/Ray.java b/src/main/java/org/bukkit/geometry/Ray.java
new file mode 100644
index 0000000..ab0dfa4
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Ray.java
@@ -0,0 +1,79 @@
+package org.bukkit.geometry;
+
+import java.util.Objects;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.Location;
+import org.bukkit.util.ImVector;
+
+public class Ray {
+
+    private final ImVector origin;
+    private final ImVector normal;
+
+    private Ray(Vec3 origin, Vec3 normal) {
+        this.origin = ImVector.copyOf(origin);
+        this.normal = ImVector.copyOf(normal.unit());
+    }
+
+    public static Ray fromOriginAndNormal(Vec3 origin, Vec3 normal) {
+        Preconditions.checkArgument(!normal.isZero(), "Ray normal must have non-zero length");
+        return new Ray(origin, normal);
+    }
+
+    public static Ray fromOriginAndTarget(Vec3 origin, Vec3 target) {
+        final Vec3 normal = target.minus(origin);
+        Preconditions.checkArgument(!normal.isZero(), "Ray target must be different from origin");
+        return new Ray(origin, normal);
+    }
+
+    public static Ray fromOriginAndDirection(Vec3 origin, Direction direction) {
+        return new Ray(origin, direction.toVector());
+    }
+
+    public static Ray fromLocation(Location location) {
+        return new Ray(location.toVector(), location.getDirection());
+    }
+
+    public ImVector origin() {
+        return origin;
+    }
+
+    public ImVector normal() {
+        return normal;
+    }
+
+    public Direction direction() {
+        return normal.direction();
+    }
+
+    public ImVector atDistance(double distance) {
+        return origin.plus(normal.times(distance));
+    }
+
+    public Ray translate(Vec3 offset) {
+        return new Ray(origin.plus(offset), normal);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(origin, normal);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(!(obj instanceof Ray)) return false;
+        final Ray that = (Ray) obj;
+        return origin.equals(that.origin) &&
+               normal.equals(that.normal);
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() +
+               "{origin=" + origin +
+               " normal=" + normal +
+               "}";
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Region.java b/src/main/java/org/bukkit/geometry/Region.java
new file mode 100644
index 0000000..8d203b2
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Region.java
@@ -0,0 +1,128 @@
+package org.bukkit.geometry;
+
+import java.util.Random;
+
+import org.bukkit.region.BlockRegion;
+
+public interface Region {
+
+    /**
+     * Does this cuboid contain no points?
+     */
+    boolean isEmpty();
+
+    /**
+     * Does this region contain the center point of any blocks?
+     */
+    boolean isBlockEmpty();
+
+    /**
+     * Does this region have a finite volume?
+     */
+    boolean isFinite();
+
+    /**
+     * Does this region contain a finite number of blocks?
+     */
+    boolean isBlockFinite();
+
+    /**
+     * Return the volume of this region
+     */
+    double volume();
+
+    /**
+     * Return the number of blocks with center points inside this region.
+     */
+    int blockVolume() throws ArithmeticException;
+
+    /**
+     * Does this region contain the given point?
+     */
+    boolean contains(Vec3 point);
+
+    /**
+     * Does this region contain the center point of the given block?
+     */
+    boolean containsBlock(Vec3 v);
+
+    /**
+     * Generate an evenly distributed random point inside this region,
+     * using the given source of random numbers. If the region is empty,
+     * the NaN vector is returned.
+     *
+     * @throws ArithmeticException if this region is unbounded
+     */
+    Vec3 randomPointInside(Random random) throws ArithmeticException;
+
+    /**
+     * Return a randomly chosen block with a center point inside this region.
+     *
+     * @throws ArithmeticException if this region is block-empty or block-unbounded
+     */
+    Vec3 randomBlockInside(Random random) throws ArithmeticException;
+
+    /**
+     * Return a {@link Cuboid} that contains this entire region.
+     *
+     * Implementations should try to make the cuboid small,
+     * but it does not have to be minimal.
+     */
+    Cuboid bounds();
+
+    /**
+     * Return a {@link BlockRegion} of all the blocks with center points
+     * inside this region.
+     */
+    BlockRegion blockRegion() throws ArithmeticException;
+
+    Region transform(Transform transform);
+
+    /**
+     * @throws ArithmeticException if this region is unbounded
+     */
+    default void assertFinite() throws ArithmeticException {
+        if(!isFinite()) {
+            throw new ArithmeticException("Region is unbounded");
+        }
+    }
+
+    /**
+     * @throws ArithmeticException unless this region contains a finite number of blocks
+     */
+    default void assertBlockFinite() throws ArithmeticException {
+        if(!isBlockFinite()) {
+            throw new ArithmeticException("Region is not block-bounded");
+        }
+    }
+
+    /**
+     * @throws ArithmeticException if this region is empty
+     */
+    default void assertNonEmpty() throws ArithmeticException {
+        if(!isEmpty()) {
+            throw new ArithmeticException("Region is empty");
+        }
+    }
+
+    /**
+     * @throws ArithmeticException if this region contains no blocks
+     */
+    default void assertBlockNonEmpty() throws ArithmeticException {
+        if(!isEmpty()) {
+            throw new ArithmeticException("Region contains no blocks");
+        }
+    }
+
+    static Region everywhere() {
+        return Everywhere.INSTANCE;
+    }
+
+    static Region nowhere() {
+        return Nowhere.INSTANCE;
+    }
+
+    static Region empty() {
+        return Nowhere.INSTANCE;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Transform.java b/src/main/java/org/bukkit/geometry/Transform.java
new file mode 100644
index 0000000..49fe0a3
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Transform.java
@@ -0,0 +1,66 @@
+package org.bukkit.geometry;
+
+import java.util.function.Function;
+import java.util.function.UnaryOperator;
+
+import org.bukkit.block.BlockFace;
+
+/**
+ * A transform applicable to {@link Vec3} and other spatial objects.
+ *
+ * Transforms are ALWAYS immutable.
+ *
+ * Currently, all implementations of this interface are also {@link CoarseTransform}s.
+ * In the future, fine-resolution transforms, which cannot always be applied to blocks,
+ * may extend this interface.
+ *
+ * @see CoarseTransform
+ */
+public interface Transform extends UnaryOperator<Vec3> {
+
+    void applyInPlace(MutableVec3 v);
+
+    default BlockFace apply(BlockFace face) {
+        return BlockFace.byDirection(apply((Vec3) face));
+    }
+
+    boolean isIdentity();
+
+    Transform inverse();
+
+    Transform compose(Transform before);
+
+    Transform andThen(Transform after);
+
+    @Override
+    default <V> Function<V, Vec3> compose(Function<? super V, ? extends Vec3> before) {
+        return before instanceof Transform ? (Function<V, Vec3>) compose((Transform) before)
+                                           : UnaryOperator.super.compose(before);
+    }
+
+    @Override
+    default <V> Function<Vec3, V> andThen(Function<? super Vec3, ? extends V> after) {
+        return after instanceof Transform ? (Function<Vec3, V>) andThen((Transform) after)
+                                          : UnaryOperator.super.andThen(after);
+    }
+
+    default Transform translate(int x, int y, int z) {
+        return andThen(CoarseTransform.translation(x, y, z));
+    }
+
+    default Transform translate(Vec3 offset) {
+        return andThen(CoarseTransform.translation(offset));
+    }
+
+    default Transform reflect(Axis axis) {
+        return andThen(CoarseTransform.reflection(axis));
+    }
+
+    default Transform rotate(int turns) {
+        return andThen(CoarseTransform.rotation(turns));
+    }
+
+    static CoarseTransform identity() {
+        return IdentityTransform.INSTANCE;
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Vec3.java b/src/main/java/org/bukkit/geometry/Vec3.java
new file mode 100644
index 0000000..0921461
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Vec3.java
@@ -0,0 +1,602 @@
+package org.bukkit.geometry;
+
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoublePredicate;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntPredicate;
+import java.util.function.IntUnaryOperator;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Base interface for all 3-vector types.
+ *
+ * Subtypes may have either coarse (integer) resolution, or fine (real) resolution,
+ * which can be checked with {@link #isCoarse()} or {@link #isFine()}. Regardless of resolution,
+ * the element values are always available as either integers or doubles. For coarse vectors,
+ * the fine components are the closest double approximations of the coarse components. For fine
+ * vectors, the coarse components are the floors of the fine components.
+ *
+ * Coarse vectors compare equal if and only if their integer components are all equal.
+ * Fine vectors compare equal if and only if their fine components are all EXACTLY equal.
+ * Coarse and fine vectors NEVER compare equal to each other, even if they have equal components.
+ *
+ * These rules for (in)equality apply to ALL {@link Vec3} implementations, and any given implementation
+ * must be comparable to any other implementation, and generate identical {@link #hashCode}s.
+ * The methods {@link #fineHashCode()}, {@link #coarseHashCode()}, and {@link #equals(Vec3)} can be used to
+ * easily implement this.
+ *
+ * Note that coarse vectors MAY be able to store and retrieve fractional coordinates,
+ * but they must use only integer coordinates when comparing to other vectors or generating hash codes.
+ *
+ * Generally, methods that return a {@link Vec3} result will return a vector with the same resolution as the one
+ * the method is called on. Binary operations between a coarse and fine vector will (effectively) use the
+ * fine components of both vectors, and the result will be converted to a coarse vector if necessary.
+ * There are a few noted exceptions to this rule, such as {@link #unit()}, which always returns a fine vector.
+ *
+ * Vectors are generally immutable, and the operations defined in the {@link Vec3} interface ALWAYS return
+ * immutable vectors that are independent of the original vector (with a few obvious exceptions, such as
+ * {@link #mutableCopy()}. Mutable vectors implement {@link MutableVec3}, which is where all the mutating
+ * operations are defined.
+ *
+ * @see MutableVec3
+ * @see Vec3Coarse
+ * @see Vec3Fine
+ * @see VectorFactory
+ */
+public interface Vec3 {
+
+    /**
+     * Can the value of this vector change?
+     */
+    boolean isMutable();
+
+    /**
+     * Can this vector contain fractional coordinates?
+     */
+    boolean isFine();
+
+    /**
+     * Inverse of {@link #isFine()}
+     */
+    default boolean isCoarse() {
+        return !isFine();
+    }
+
+    /**
+     * Return the ith fine component of the vector, starting at 0
+     *
+     * @throws IndexOutOfBoundsException if there is no component with the given index
+     */
+    default double fineAt(int i) {
+        switch(i) {
+            case 0: return fineX();
+            case 1: return fineY();
+            case 2: return fineZ();
+        }
+        throw new IndexOutOfBoundsException();
+    }
+
+    default double fineAt(Axis axis) {
+        switch(axis) {
+            case X: return fineX();
+            case Y: return fineY();
+            case Z: return fineZ();
+        }
+        throw new IllegalStateException();
+    }
+
+    double fineX();
+
+    double fineY();
+
+    double fineZ();
+
+    default DoubleStream fineStream() {
+        return DoubleStream.of(fineX(), fineY(), fineZ());
+    }
+
+    default boolean isZero() {
+        return fineX() == 0 && fineY() == 0 && fineZ() == 0;
+    }
+
+    /**
+     * Return the ith coarse component of the vector, starting at 0
+     *
+     * @throws IndexOutOfBoundsException if there is no component with the given index
+     */
+    default int coarseAt(int i) {
+        switch(i) {
+            case 0: return coarseX();
+            case 1: return coarseY();
+            case 2: return coarseZ();
+        }
+        throw new IndexOutOfBoundsException();
+    }
+
+    default int coarseAt(Axis axis) {
+        switch(axis) {
+            case X: return coarseX();
+            case Y: return coarseY();
+            case Z: return coarseZ();
+        }
+        throw new IllegalStateException();
+    }
+
+    int coarseX();
+
+    int coarseY();
+
+    int coarseZ();
+
+    default IntStream coarseStream() {
+        return IntStream.of(coarseX(), coarseY(), coarseZ());
+    }
+
+    /**
+     * Are the integer components of this object all zero?
+     */
+    default boolean isCoarseZero() {
+        return coarseX() == 0 && coarseY() == 0 && coarseZ() == 0;
+    }
+
+    default boolean fineEquals(Vec3 v) {
+        return v != null &&
+               fineX() == v.fineX() &&
+               fineY() == v.fineY() &&
+               fineZ() == v.fineZ();
+    }
+
+    default boolean coarseEquals(Vec3 v) {
+        return v != null &&
+               coarseX() == v.coarseX() &&
+               coarseY() == v.coarseY() &&
+               coarseZ() == v.coarseZ();
+    }
+
+    /**
+     * Test if this vector is equal to the given vector.
+     *
+     * See the notes about equality in the {@link Vec3} documentation.
+     */
+    default boolean equals(Vec3 v) {
+        if(v == null) return false;
+
+        if(isFine()) {
+            return v.isFine() && fineEquals(v);
+        } else {
+            return v.isCoarse() && coarseEquals(v);
+        }
+    }
+
+    /**
+     * Return the proper hashCode of a vector whos individual components have the given hashCodes
+     *
+     * This is intended for use by implementors of this interface
+     */
+    static int combineHashCodes(int hashX, int hashY, int hashZ) {
+        // 31 bits gives us roughly 10 bits per axis, and 1021 is the closest prime to 2^10
+        return (hashX * 1021 + hashY) * 1021 + hashZ;
+    }
+
+    default int fineHashCode() {
+        return combineHashCodes(
+            NumberConversions.hashCode(fineX()),
+            NumberConversions.hashCode(fineY()),
+            NumberConversions.hashCode(fineZ())
+        );
+    }
+
+    default int coarseHashCode() {
+        return combineHashCodes(
+            coarseX(),
+            coarseY(),
+            coarseZ()
+        );
+    }
+
+    /**
+     * Return an immutable vector equal to the current value of this vector.
+     * If this vector is immutable, it may return itself.
+     */
+    Vec3 copy();
+
+    /**
+     * Return a new mutable vector equal to the current value of this vector.
+     * This is always a new object that is independent of this vector.
+     */
+    MutableVec3 mutableCopy();
+
+    /**
+     * Return an immutable fine vector with components equal to the fine
+     * components of this vector.
+     */
+    Vec3 fineCopy();
+
+    Vec3 fineOf(double x, double y, double z);
+
+    Vec3 fineZero();
+
+    /**
+     * Return an immutable coarse vector with components equal to the integer
+     * components of this vector.
+     */
+    Vec3 coarseCopy();
+
+    Vec3 coarseOf(int x, int y, int z);
+
+    Vec3 coarseZero();
+
+    /**
+     * Return true only if ALL fine components of this vector are strictly less
+     * than their respective fine component in the given vector.
+     */
+    default boolean fineLess(Vec3 v) {
+        return fineX() < v.fineX() &&
+               fineY() < v.fineY() &&
+               fineZ() < v.fineZ();
+    }
+
+    /**
+     * Return true only if ALL fine components of this vector are less or equal
+     * to their respective fine component in the given vector.
+     */
+    default boolean fineLessOrEqual(Vec3 v) {
+        return fineX() <= v.fineX() &&
+               fineY() <= v.fineY() &&
+               fineZ() <= v.fineZ();
+    }
+
+    /**
+     * Return true only if ALL fine components of this vector are strictly greater
+     * than their respective fine component in the given vector.
+     */
+    default boolean fineGreater(Vec3 v) {
+        return fineX() > v.fineX() &&
+               fineY() > v.fineY() &&
+               fineZ() > v.fineZ();
+    }
+
+    /**
+     * Return true only if ALL fine components of this vector are greater or equal
+     * to their respective fine component in the given vector.
+     */
+    default boolean fineGreaterOrEqual(Vec3 v) {
+        return fineX() >= v.fineX() &&
+               fineY() >= v.fineY() &&
+               fineZ() >= v.fineZ();
+    }
+
+    /**
+     * Return true only if ALL coarse components of this vector are strictly less
+     * than their respective coarse component in the given vector.
+     */
+    default boolean coarseLess(Vec3 v) {
+        return coarseX() < v.coarseX() &&
+               coarseY() < v.coarseY() &&
+               coarseZ() < v.coarseZ();
+    }
+
+    /**
+     * Return true only if ALL coarse components of this vector are less or equal
+     * to their respective coarse component in the given vector.
+     */
+    default boolean coarseLessOrEqual(Vec3 v) {
+        return coarseX() <= v.coarseX() &&
+               coarseY() <= v.coarseY() &&
+               coarseZ() <= v.coarseZ();
+    }
+
+    /**
+     * Return true only if ALL coarse components of this vector are strictly greater
+     * than their respective coarse component in the given vector.
+     */
+    default boolean coarseGreater(Vec3 v) {
+        return coarseX() > v.coarseX() &&
+               coarseY() > v.coarseY() &&
+               coarseZ() > v.coarseZ();
+    }
+
+    /**
+     * Return true only if ALL coarse components of this vector are greater or equal
+     * to their respective coarse component in the given vector.
+     */
+    default boolean coarseGreaterOrEqual(Vec3 v) {
+        return coarseX() >= v.coarseX() &&
+               coarseY() >= v.coarseY() &&
+               coarseZ() >= v.coarseZ();
+    }
+
+    default boolean isBlockCorner() {
+        return isFine() &&
+               fineX() == coarseX() &&
+               fineY() == coarseY() &&
+               fineZ() == coarseZ();
+    }
+
+    default boolean isBlockCenter() {
+        return isFine() &&
+               fineX() == coarseX() + 0.5 &&
+               fineY() == coarseY() + 0.5 &&
+               fineZ() == coarseZ() + 0.5;
+    }
+
+    /**
+     * Return an immutable fine vector at the center of the block position
+     * represented by this vector's coarse coordinates.
+     */
+    default Vec3 blockCenter() {
+        return fineOf(coarseX() + 0.5,
+                      coarseY() + 0.5,
+                      coarseZ() + 0.5);
+    }
+
+    default boolean anyMatch(DoublePredicate predicate) {
+        return predicate.test(fineX()) ||
+               predicate.test(fineY()) ||
+               predicate.test(fineZ());
+    }
+
+    default boolean anyMatch(IntPredicate predicate) {
+        return predicate.test(coarseX()) ||
+               predicate.test(coarseY()) ||
+               predicate.test(coarseZ());
+    }
+
+    default boolean allMatch(DoublePredicate predicate) {
+        return predicate.test(fineX()) &&
+               predicate.test(fineY()) &&
+               predicate.test(fineZ());
+    }
+
+    default boolean allMatch(IntPredicate predicate) {
+        return predicate.test(coarseX()) &&
+               predicate.test(coarseY()) &&
+               predicate.test(coarseZ());
+    }
+
+    boolean anyNaN();
+    boolean allNaN();
+    boolean anyFinite();
+    boolean allFinite();
+    boolean anyInfinite();
+    boolean allInfinite();
+
+    Vec3 map(IntUnaryOperator op);
+
+    Vec3 map(DoubleUnaryOperator op);
+
+    Vec3 map(Vec3 v, IntBinaryOperator op);
+
+    Vec3 map(Vec3 v, DoubleBinaryOperator op);
+
+    /**
+     * Return a vector of the minimums of each component of this vector
+     * and the respective component of the given vector.
+     */
+    Vec3 minimum(Vec3 v);
+
+    /**
+     * Return a vector of the maximums of each component of this vector
+     * and the respective component of the given vector.
+     */
+    Vec3 maximum(Vec3 v);
+
+    /**
+     * Return a vector of this vector's components, each clamped to the
+     * respective minimum and maximum components.
+     */
+    Vec3 clamped(Vec3 min, Vec3 max);
+
+    /**
+     * Add the given coarse vector components to this vector
+     */
+    Vec3 plus(int x, int y, int z);
+
+    /**
+     * Add the given fine vector components to this vector
+     */
+    Vec3 plus(double x, double y, double z);
+
+    /**
+     * Add the given vector to this one
+     */
+    Vec3 plus(Vec3 v);
+
+    /**
+     * Add the given value to all components of this vector
+     */
+    default Vec3 plus(int xyz) {
+        return plus(xyz, xyz, xyz);
+    }
+
+    /**
+     * Add the given value to all components of this vector
+     */
+    default Vec3 plus(double xyz) {
+        return plus(xyz, xyz, xyz);
+    }
+
+    default Vec3 plus(Axis axis, int delta) {
+        return plus(axis.positive().times(delta));
+    }
+
+    default Vec3 plus(Axis axis, double delta) {
+        return plus(axis.positive().times(delta));
+    }
+
+    /**
+     * Subtract the given coarse vector components from this one
+     */
+    Vec3 minus(int x, int y, int z);
+
+    /**
+     * Subtract the given fine vector components from this one
+     */
+    Vec3 minus(double x, double y, double z);
+
+    /**
+     * Subtract the given vector from this one
+     */
+    Vec3 minus(Vec3 v);
+
+    /**
+     * Subtract the given value from all components of this vector
+     */
+    default Vec3 minus(int xyz) {
+        return minus(xyz, xyz, xyz);
+    }
+
+    /**
+     * Subtract the given value from all components of this vector
+     */
+    default Vec3 minus(double xyz) {
+        return minus(xyz, xyz, xyz);
+    }
+
+    default Vec3 minus(Axis axis, int delta) {
+        return minus(axis.positive().times(delta));
+    }
+
+    default Vec3 minus(Axis axis, double delta) {
+        return minus(axis.positive().times(delta));
+    }
+
+    default Vec3 west(int delta) {
+        return minus(Axis.X, delta);
+    }
+
+    default Vec3 east(int delta) {
+        return plus(Axis.X, delta);
+    }
+
+    default Vec3 down(int delta) {
+        return minus(Axis.Y, delta);
+    }
+
+    default Vec3 up(int delta) {
+        return plus(Axis.Y, delta);
+    }
+
+    default Vec3 north(int delta) {
+        return minus(Axis.Z, delta);
+    }
+
+    default Vec3 south(int delta) {
+        return plus(Axis.Z, delta);
+    }
+
+    default Vec3 west()  { return west(1); }
+    default Vec3 east()  { return east(1); }
+    default Vec3 down()  { return down(1); }
+    default Vec3 up()    { return up(1); }
+    default Vec3 north() { return north(1); }
+    default Vec3 south() { return south(1); }
+
+    /**
+     * Multiply the components of this vector by the respective given values
+     */
+    Vec3 times(int x, int y, int z);
+
+    /**
+     * Multiply the components of this vector by the respective given values
+     */
+    Vec3 times(double x, double y, double z);
+
+    /**
+     * Multiply the components of this vector by the respective components of the given vector
+     */
+    Vec3 times(Vec3 v);
+
+    /**
+     * Multiply this vector by the given scalar
+     */
+    default Vec3 times(int n) {
+        return times(n, n, n);
+    }
+
+    /**
+     * Multiply this vector by the given scalar
+     */
+    default Vec3 times(double n) {
+        return times(n, n, n);
+    }
+
+    Vec3 over(int x, int y, int z);
+
+    Vec3 over(double x, double y, double z);
+
+    Vec3 over(Vec3 v);
+
+    default Vec3 over(int n) {
+        return over(n, n, n);
+    }
+
+    default Vec3 over(double n) {
+        return over(n, n, n);
+    }
+
+    /**
+     * Negate this vector
+     */
+    Vec3 negate();
+
+    /**
+     * Return a fine vector of length 1 pointing in the same direction as this vector
+     */
+    default Vec3 unit() {
+        final double n = length();
+        return fineOf(fineX() / n, fineY() / n, fineZ() / n);
+    }
+
+    /**
+     * Return the dot product of this vector and the given vector
+     */
+    default double dot(Vec3 v) {
+        return fineX() * v.fineX() +
+               fineY() * v.fineY() +
+               fineZ() * v.fineZ();
+    }
+
+    default double lengthSquared() {
+        return dot(this);
+    }
+
+    default double length() {
+        return Math.sqrt(lengthSquared());
+    }
+
+    default double distanceSquared(Vec3 v) {
+        return v.minus(this).lengthSquared();
+    }
+
+    default double distance(Vec3 v) {
+        return Math.sqrt(distanceSquared(v));
+    }
+
+    /**
+     * Return a fine vector interpolating linearly between this vector and the given vector
+     */
+    default Vec3 interpolate(Vec3 v, double n) {
+        final double u = 1 - n;
+        return fineOf(u * fineX() + n * v.fineX(),
+                      u * fineY() + n * v.fineY(),
+                      u * fineZ() + n * v.fineZ());
+    }
+
+    /**
+     * Return a fine vector half way between this vector and the given vector
+     */
+    default Vec3 midway(Vec3 v) {
+        return fineOf((fineX() + v.fineX()) / 2D,
+                      (fineY() + v.fineY()) / 2D,
+                      (fineZ() + v.fineZ()) / 2D);
+    }
+
+    default Direction direction() {
+        return Direction.fromVector(fineX(), fineY(), fineZ());
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Vec3Coarse.java b/src/main/java/org/bukkit/geometry/Vec3Coarse.java
new file mode 100644
index 0000000..ae12726
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Vec3Coarse.java
@@ -0,0 +1,267 @@
+package org.bukkit.geometry;
+
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntUnaryOperator;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Base implementation for coarse vectors.
+ *
+ * This interface is intended to help with implementation of the API.
+ * It should NOT be used by consumers of the API.
+ *
+ * @see Vec3Fine
+ * @see MutableVec3Coarse
+ */
+public interface Vec3Coarse<V extends Vec3> extends Vec3 {
+
+    @Override
+    default boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    default boolean isFine() {
+        return false;
+    }
+
+    @Override
+    default boolean isCoarse() {
+        return true;
+    }
+
+    @Override
+    V copy();
+
+    @Override
+    default V coarseCopy() {
+        return copy();
+    }
+
+    @Override
+    V coarseOf(int x, int y, int z);
+
+    @Override
+    V coarseZero();
+
+    default V coarseOf(double x, double y, double z) {
+        return coarseOf(NumberConversions.floor(x),
+                        NumberConversions.floor(y),
+                        NumberConversions.floor(z));
+    }
+
+    @Override
+    default double fineX() {
+        return coarseX();
+    }
+
+    @Override
+    default double fineY() {
+        return coarseY();
+    }
+
+    @Override
+    default double fineZ() {
+        return coarseZ();
+    }
+
+    @Override
+    default boolean equals(Vec3 v) {
+        return v != null && v.isCoarse() && coarseEquals(v);
+    }
+
+    @Override
+    default boolean fineLess(Vec3 v) {
+        return v.isCoarse() ? coarseLess(v)
+                            : Vec3.super.fineLess(v);
+    }
+
+    @Override
+    default boolean fineLessOrEqual(Vec3 v) {
+        return v.isCoarse() ? coarseLessOrEqual(v)
+                            : Vec3.super.fineLessOrEqual(v);
+    }
+
+    @Override
+    default boolean fineGreater(Vec3 v) {
+        return v.isCoarse() ? coarseGreater(v)
+                            : Vec3.super.fineGreater(v);
+    }
+
+    @Override
+    default boolean fineGreaterOrEqual(Vec3 v) {
+        return v.isCoarse() ? coarseGreaterOrEqual(v)
+                            : Vec3.super.fineGreaterOrEqual(v);
+    }
+
+    @Override
+    default boolean anyNaN() {
+        return false;
+    }
+
+    @Override
+    default boolean allNaN() {
+        return false;
+    }
+
+    @Override
+    default boolean anyFinite() {
+        return true;
+    }
+
+    @Override
+    default boolean allFinite() {
+        return true;
+    }
+
+    @Override
+    default boolean anyInfinite() {
+        return false;
+    }
+
+    @Override
+    default boolean allInfinite() {
+        return false;
+    }
+
+    @Override
+    default V map(IntUnaryOperator op) {
+        return coarseOf(op.applyAsInt(coarseX()),
+                        op.applyAsInt(coarseY()),
+                        op.applyAsInt(coarseZ()));
+    }
+
+    @Override
+    default V map(DoubleUnaryOperator op) {
+        return coarseOf(op.applyAsDouble(fineX()),
+                        op.applyAsDouble(fineY()),
+                        op.applyAsDouble(fineZ()));
+    }
+
+    @Override
+    default V map(Vec3 v, IntBinaryOperator op) {
+        return coarseOf(op.applyAsInt(coarseX(), v.coarseX()),
+                        op.applyAsInt(coarseY(), v.coarseY()),
+                        op.applyAsInt(coarseZ(), v.coarseZ()));
+    }
+
+    @Override
+    default V map(Vec3 v, DoubleBinaryOperator op) {
+        return coarseOf(op.applyAsDouble(fineX(), v.fineX()),
+                        op.applyAsDouble(fineY(), v.fineY()),
+                        op.applyAsDouble(fineZ(), v.fineZ()));
+    }
+
+    @Override
+    default V minimum(Vec3 v) {
+        return map(v, (IntBinaryOperator) Math::min);
+    }
+
+    @Override
+    default V maximum(Vec3 v) {
+        return map(v, (IntBinaryOperator) Math::max);
+    }
+
+    @Override
+    default V clamped(Vec3 min, Vec3 max) {
+        Preconditions.checkArgument(min.coarseLessOrEqual(max));
+        return coarseOf(NumberConversions.clamp(coarseX(), min.coarseX(), max.coarseX()),
+                        NumberConversions.clamp(coarseY(), min.coarseY(), max.coarseY()),
+                        NumberConversions.clamp(coarseZ(), min.coarseZ(), max.coarseZ()));
+    }
+
+    @Override
+    default V negate() {
+        return isZero() ? copy() : coarseOf(-coarseX(), -coarseY(), -coarseZ());
+    }
+
+    @Override
+    default V plus(int x, int y, int z) {
+        return x == 0 && y == 0 && z == 0
+               ? copy()
+               : coarseOf(coarseX() + x, coarseY() + y, coarseZ() + z);
+    }
+
+    @Override
+    default V plus(double x, double y, double z) {
+        return x == 0D && y == 0D && z == 0D
+               ? copy()
+               : coarseOf(coarseX() + x, coarseY() + y, coarseZ() + z);
+    }
+
+    @Override
+    default V plus(Vec3 v) {
+        return plus(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    @Override
+    default V minus(int x, int y, int z) {
+        return plus(-x, -y, -z);
+    }
+
+    @Override
+    default V minus(double x, double y, double z) {
+        return plus(-x, -y, -z);
+    }
+
+    @Override
+    default V minus(Vec3 v) {
+        return minus(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    @Override
+    default V times(int n) {
+        if(n == 0 || isCoarseZero()) return coarseZero();
+        return coarseOf(coarseX() * n, coarseY() * n, coarseZ() * n);
+    }
+
+    @Override
+    default V times(double n) {
+        if(n == 0D || isCoarseZero()) return coarseZero();
+        return coarseOf(coarseX() * n, coarseY() * n, coarseZ() * n);
+    }
+
+    @Override
+    default V times(int x, int y, int z) {
+        if((x == 0 && y == 0 && z == 0) || isCoarseZero()) return coarseZero();
+        if(x == 1 && y == 1 && z == 1) return copy();
+        return coarseOf(coarseX() * x, coarseY() * y, coarseZ() * z);
+    }
+
+    @Override
+    default V times(double x, double y, double z) {
+        if((x == 0D && y == 0D && z == 0D) || isCoarseZero()) return coarseZero();
+        if(x == 1D && y == 1D && z == 1D) return copy();
+        return coarseOf(coarseX() * x, coarseY() * y, coarseZ() * z);
+    }
+
+    @Override
+    default V times(Vec3 v) {
+        if(v.isZero() || isCoarseZero()) return coarseZero();
+        return v.isFine() ? coarseOf(coarseX() * v.fineX(), coarseY() * v.fineY(), coarseZ() * v.fineZ())
+                          : coarseOf(coarseX() * v.coarseX(), coarseY() * v.coarseY(), coarseZ() * v.coarseZ());
+    }
+
+    @Override
+    default V over(int x, int y, int z) {
+        if(x == 1 && y == 1 && z == 1) return copy();
+        return coarseOf(coarseX() / x, coarseY() / y, coarseZ() / z);
+    }
+
+    @Override
+    default V over(double x, double y, double z) {
+        if(x == 1 && y == 1 && z == 1) return copy();
+        if(Double.isInfinite(x) && Double.isInfinite(y) && Double.isInfinite(z)) return coarseZero();
+        return coarseOf(coarseX() / x, coarseY() / y, coarseZ() / z);
+    }
+
+    @Override
+    default V over(Vec3 v) {
+        return v.isFine() ? coarseOf(coarseX() / v.fineX(), coarseY() / v.fineY(), coarseZ() / v.fineZ())
+                          : coarseOf(coarseX() / v.coarseX(), coarseY() / v.coarseY(), coarseZ() / v.coarseZ());
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/Vec3Fine.java b/src/main/java/org/bukkit/geometry/Vec3Fine.java
new file mode 100644
index 0000000..2004d4d
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/Vec3Fine.java
@@ -0,0 +1,232 @@
+package org.bukkit.geometry;
+
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoublePredicate;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntUnaryOperator;
+
+import com.google.common.base.Preconditions;
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Base implementation for fine vectors.
+ *
+ * This interface is intended to help with implementation of the API.
+ * It should NOT be used by consumers of the API.
+ *
+ * @see Vec3Coarse
+ * @see MutableVec3Fine
+ */
+public interface Vec3Fine<V extends Vec3> extends Vec3 {
+
+    @Override
+    default boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    default boolean isFine() {
+        return true;
+    }
+
+    @Override
+    default boolean isCoarse() {
+        return false;
+    }
+
+    @Override
+    V copy();
+
+    @Override
+    default V fineCopy() {
+        return copy();
+    }
+
+    @Override
+    V fineOf(double x, double y, double z);
+
+    @Override
+    V fineZero();
+
+    @Override
+    default Vec3 coarseCopy() {
+        return coarseOf(coarseX(), coarseY(), coarseZ());
+    }
+
+    @Override
+    default int coarseX() {
+        return NumberConversions.floor(fineX());
+    }
+
+    @Override
+    default int coarseY() {
+        return NumberConversions.floor(fineY());
+    }
+
+    @Override
+    default int coarseZ() {
+        return NumberConversions.floor(fineZ());
+    }
+
+    @Override
+    default boolean equals(Vec3 v) {
+        return v != null && v.isFine() && fineEquals(v);
+    }
+
+    @Override
+    default boolean anyNaN() {
+        return anyMatch((DoublePredicate) Double::isNaN);
+    }
+
+    @Override
+    default boolean allNaN() {
+        return allMatch((DoublePredicate) Double::isNaN);
+    }
+
+    @Override
+    default boolean anyFinite() {
+        return anyMatch((DoublePredicate) Double::isFinite);
+    }
+
+    @Override
+    default boolean allFinite() {
+        return allMatch((DoublePredicate) Double::isFinite);
+    }
+
+    @Override
+    default boolean anyInfinite() {
+        return anyMatch((DoublePredicate) Double::isInfinite);
+    }
+
+    @Override
+    default boolean allInfinite() {
+        return allMatch((DoublePredicate) Double::isInfinite);
+    }
+
+    @Override
+    default V map(IntUnaryOperator op) {
+        return fineOf(op.applyAsInt(coarseX()),
+                      op.applyAsInt(coarseY()),
+                      op.applyAsInt(coarseZ()));
+    }
+
+    @Override
+    default V map(DoubleUnaryOperator op) {
+        return fineOf(op.applyAsDouble(fineX()),
+                      op.applyAsDouble(fineY()),
+                      op.applyAsDouble(fineZ()));
+    }
+
+    @Override
+    default V map(Vec3 v, IntBinaryOperator op) {
+        return fineOf(op.applyAsInt(coarseX(), v.coarseX()),
+                      op.applyAsInt(coarseY(), v.coarseY()),
+                      op.applyAsInt(coarseZ(), v.coarseZ()));
+    }
+
+    @Override
+    default V map(Vec3 v, DoubleBinaryOperator op) {
+        return fineOf(op.applyAsDouble(fineX(), v.fineX()),
+                      op.applyAsDouble(fineY(), v.fineY()),
+                      op.applyAsDouble(fineZ(), v.fineZ()));
+    }
+
+    @Override
+    default V minimum(Vec3 v) {
+        return map(v, (DoubleBinaryOperator) Math::min);
+    }
+
+    @Override
+    default V maximum(Vec3 v) {
+        return map(v, (DoubleBinaryOperator) Math::max);
+    }
+
+    @Override
+    default V clamped(Vec3 min, Vec3 max) {
+        Preconditions.checkArgument(min.fineLessOrEqual(max));
+        return fineOf(NumberConversions.clamp(fineX(), min.fineX(), max.fineX()),
+                      NumberConversions.clamp(fineY(), min.fineY(), max.fineY()),
+                      NumberConversions.clamp(fineZ(), min.fineZ(), max.fineZ()));
+    }
+
+    @Override
+    default V plus(Vec3 v) {
+        return fineOf(fineX() + v.fineX(), fineY() + v.fineY(), fineZ() + v.fineZ());
+    }
+
+    @Override
+    default V plus(int x, int y, int z) {
+        return plus((double) x, (double) y, (double) z);
+    }
+
+    @Override
+    default V plus(double x, double y, double z) {
+        return fineOf(this.fineX() + x, this.fineY() + y, this.fineZ() + z);
+    }
+
+    @Override
+    default V minus(Vec3 v) {
+        return fineOf(fineX() - v.fineX(), fineY() - v.fineY(), fineZ() - v.fineZ());
+    }
+
+    @Override
+    default V minus(int x, int y, int z) {
+        return fineOf(this.fineX() - x, this.fineY() - y, this.fineZ() - z);
+    }
+
+    @Override
+    default V minus(double x, double y, double z) {
+        return fineOf(this.fineX() - x, this.fineY() - y, this.fineZ() - z);
+    }
+
+    @Override
+    default V times(double n) {
+        return fineOf(fineX() * n, fineY() * n, fineZ() * n);
+    }
+
+    @Override
+    default V times(int n) {
+        return fineOf(fineX() * n, fineY() * n, fineZ() * n);
+    }
+
+    @Override
+    default V times(int x, int y, int z) {
+        return fineOf(this.fineX() * x, this.fineY() * y, this.fineZ() * z);
+    }
+
+    @Override
+    default V times(double x, double y, double z) {
+        return fineOf(this.fineX() * x, this.fineY() * y, this.fineZ() * z);
+    }
+
+    @Override
+    default V times(Vec3 v) {
+        return fineOf(fineX() + v.fineZ(), fineY() + v.fineY(), fineZ() + v.fineZ());
+    }
+
+    @Override
+    default V over(int x, int y, int z) {
+        return fineOf(this.fineX() / x, this.fineY() / y, this.fineZ() / z);
+    }
+
+    @Override
+    default V over(double x, double y, double z) {
+        return fineOf(this.fineX() / x, this.fineY() / y, this.fineZ() / z);
+    }
+
+    @Override
+    default V over(double n) {
+        return fineOf(fineX() / n, fineY() / n, fineZ() / n);
+    }
+
+    @Override
+    default V over(Vec3 v) {
+        return fineOf(fineX() / v.fineX(), fineY() / v.fineY(), fineZ() / v.fineZ());
+    }
+
+    @Override
+    default V negate() {
+        return fineOf(-fineX(), -fineY(), -fineZ());
+    }
+}
diff --git a/src/main/java/org/bukkit/geometry/VectorFactory.java b/src/main/java/org/bukkit/geometry/VectorFactory.java
new file mode 100644
index 0000000..e18729a
--- /dev/null
+++ b/src/main/java/org/bukkit/geometry/VectorFactory.java
@@ -0,0 +1,67 @@
+package org.bukkit.geometry;
+
+/**
+ * Construct {@link Vec3} instances
+ */
+public interface VectorFactory {
+
+    Vec3 coarse(int x, int y, int z);
+
+    default Vec3 coarse(int xyz) {
+        return coarse(xyz, xyz, xyz);
+    }
+
+    Vec3 coarse(double x, double y, double z);
+
+    default Vec3 coarse(double xyz) {
+        return coarse(xyz, xyz, xyz);
+    }
+
+    Vec3 fine(int x, int y, int z);
+
+    default Vec3 fine(int xyz) {
+        return fine(xyz, xyz, xyz);
+    }
+
+    Vec3 fine(double x, double y, double z);
+
+    default Vec3 fine(double xyz) {
+        return fine(xyz, xyz, xyz);
+    }
+
+    MutableVec3 coarseMutable(int x, int y, int z);
+
+    default MutableVec3 coarseMutable(int xyz) {
+        return coarseMutable(xyz, xyz, xyz);
+    }
+
+    MutableVec3 fineMutable(double x, double y, double z);
+
+    default MutableVec3 fineMutable(double xyz) {
+        return fineMutable(xyz, xyz, xyz);
+    }
+
+    default Vec3 coarseZero() {
+        return coarse(0, 0, 0);
+    }
+
+    default Vec3 fineZero() {
+        return fine(0, 0, 0);
+    }
+
+    default MutableVec3 coarseMutableZero() {
+        return coarseMutable(0, 0, 0);
+    }
+
+    default MutableVec3 fineMutableZero() {
+        return fineMutable(0, 0, 0);
+    }
+
+    default MutableVec3 coarseMutable(Vec3 v) {
+        return coarseMutable(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    default MutableVec3 fineMutable(Vec3 v) {
+        return fineMutable(v.fineX(), v.fineY(), v.fineZ());
+    }
+}
diff --git a/src/main/java/org/bukkit/region/BakedBlockRegion.java b/src/main/java/org/bukkit/region/BakedBlockRegion.java
new file mode 100644
index 0000000..7a3041f
--- /dev/null
+++ b/src/main/java/org/bukkit/region/BakedBlockRegion.java
@@ -0,0 +1,113 @@
+package org.bukkit.region;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import com.google.common.collect.ImmutableSet;
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+
+class BakedBlockRegion implements BlockRegion {
+
+    private final ImmutableSet<Vec3> positions;
+
+    BakedBlockRegion(ImmutableSet<Vec3> positions) {
+        this.positions = positions;
+    }
+
+    static BlockRegion of(Stream<? extends Vec3> positions) {
+        final ImmutableSet.Builder<Vec3> builder = ImmutableSet.builder();
+        positions.forEach(builder::add);
+        return of(builder.build());
+    }
+
+    static BlockRegion of(Iterator<? extends Vec3> positions) {
+        final ImmutableSet<Vec3> set = ImmutableSet.copyOf(positions);
+        return new BakedBlockRegion(set);
+    }
+
+    static BlockRegion of(Iterable<? extends Vec3> positions) {
+        if(positions instanceof BlockRegion) {
+            final BlockRegion region = (BlockRegion) positions;
+            if(!region.isMutable()) return region;
+        }
+        return of(ImmutableSet.copyOf(positions));
+    }
+
+    static BlockRegion of(Collection<? extends Vec3> positions) {
+        if(positions.isEmpty()) return EmptyBlockRegion.INSTANCE;
+        if(positions instanceof BlockRegion) {
+            final BlockRegion region = (BlockRegion) positions;
+            if(!region.isMutable()) return region;
+        }
+        return new BakedBlockRegion(ImmutableSet.copyOf(positions));
+    }
+
+    static BlockRegion of(ImmutableSet<? extends Vec3> positions) {
+        if(positions.isEmpty()) return EmptyBlockRegion.INSTANCE;
+        return new BakedBlockRegion((ImmutableSet<Vec3>) positions);
+    }
+
+    @Override
+    public boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    public BlockRegion copy() {
+        return this;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return positions.isEmpty();
+    }
+
+    @Override
+    public int size() {
+        return positions.size();
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        return positions.contains(position);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return positions.containsAll(c);
+    }
+
+    @Override
+    public Iterator<Vec3> mutableIterator() {
+        return positions.iterator();
+    }
+
+    @Override
+    public Iterator<Vec3> iterator() {
+        return positions.iterator();
+    }
+
+    @Override
+    public BlockRegion transform(CoarseTransform transform) {
+        if(transform.isIdentity()) return this;
+        return new TransformedBlockRegion(this, transform);
+    }
+
+    @Override
+    public BlockRegion filter(Predicate<? super Vec3> predicate) {
+        return new FilteredBlockRegion(this, predicate);
+    }
+
+    @Override
+    public int hashCode() {
+        return positions.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return positions.equals(obj);
+    }
+}
diff --git a/src/main/java/org/bukkit/region/BlockRegion.java b/src/main/java/org/bukkit/region/BlockRegion.java
new file mode 100644
index 0000000..7c4bcef
--- /dev/null
+++ b/src/main/java/org/bukkit/region/BlockRegion.java
@@ -0,0 +1,158 @@
+package org.bukkit.region;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.Iterators;
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+import org.bukkit.util.SetBase;
+
+/**
+ * Represents a set of block coordinates, and supports iteration over them and tests for inclusion.
+ *
+ * Some region types have changing contents. This can be checked with {@link #isMutable()}, and an
+ * immutable region can always be obtained from {@link #copy()}. Other operations may return mutable
+ * regions, even when applied to immutable regions.
+ *
+ * Since regions are {@link Set}s, they must follow the equality contract for sets, and compare equal
+ * to any other {@link Set} of the same {@link Vec3} elements.
+ */
+public interface BlockRegion extends SetBase<Vec3> {
+
+    /**
+     * Can the contents of this region change?
+     *
+     * If this returns false, then the set of blocks in the region must NEVER change.
+     * If this returns true, then the set of blocks may or may not change.
+     */
+    boolean isMutable();
+
+    boolean contains(Vec3 pos);
+
+    @Override
+    default boolean contains(Object o) {
+        return o instanceof Vec3 && contains((Vec3) o);
+    }
+
+    default boolean containsAll(BlockRegion region) {
+        // Use the mutable iterator for efficiency
+        for(Vec3 pos : region.mutableIterable()) {
+            if(!contains(pos)) return false;
+        }
+        return true;
+    }
+
+    @Override
+    default boolean containsAll(Collection<?> c) {
+        return c instanceof BlockRegion ? containsAll((BlockRegion) c)
+                                        : SetBase.super.containsAll(c);
+    }
+
+    /**
+     * Return an {@link Iterator} over the blocks in this region that MAY return the same {@link Vec3}
+     * instance from multiple calls to {@link Iterator#next()}, with the vector assuming a new value
+     * for each iteration.
+     *
+     * This can be considerably more efficient, but care must be taken to not use vector instances
+     * outside of their own iteration, without copying them first. Call {@link #iterator()} for an
+     * iterator that returns an independent, immutable vector for each iteration.
+     */
+    Iterator<Vec3> mutableIterator();
+
+    default Iterable<Vec3> mutableIterable() {
+        return this::mutableIterator;
+    }
+
+    default Iterator<Vec3> iterator() {
+        return Iterators.transform(mutableIterator(), Vec3::copy);
+    }
+
+    /**
+     * Return an immutable {@link BlockRegion} containing the same positions that this
+     * region currently contains. If this region is immutable, it may return itself.
+     */
+    BlockRegion copy();
+
+    /**
+     * Return a region equal to this region with the given transform applied to all elements.
+     *
+     * The returned region is a live view of this one, and any changes to this region are
+     * immediately reflected in the transformed region. If this region is immutable, then
+     * the transformed region will also be immutable.
+     *
+     * This region may return itself if it would be unaffected by the transform.
+     */
+    BlockRegion transform(CoarseTransform transform);
+
+    /**
+     * Return a region containing the elements of this region that pass the given predicate.
+     *
+     * The returned region is a live view of this one, and any changes to this region are
+     * immediately reflected in the filtered region.
+     *
+     * This region may return itself if it would be unaffected by the filter.
+     */
+    BlockRegion filter(Predicate<? super Vec3> predicate);
+
+    default int standardHashCode() {
+        int h = 0;
+        for(Vec3 p : mutableIterable()) {
+            h += p.hashCode();
+        }
+        return h;
+    }
+
+    default boolean standardEquals(Object that) {
+        return that instanceof Set &&
+               size() == ((Set) that).size() &&
+               containsAll((Set) that);
+    }
+
+    /**
+     * Return the empty region
+     */
+    static BlockRegion empty() {
+        return EmptyBlockRegion.INSTANCE;
+    }
+
+    /**
+     * Return a live view of the given {@link Set} as a {@link BlockRegion}.
+     *
+     * Changes to the underlying set are instantly reflected in the region.
+     */
+    static BlockRegion of(Set<Vec3> positions) {
+        if(positions instanceof BlockRegion) {
+            return (BlockRegion) positions;
+        }
+        if(positions instanceof ImmutableCollection) {
+            return BakedBlockRegion.of(positions);
+        }
+        return new BlockRegionAdapter(positions);
+    }
+
+    /**
+     * Return an immutable region containing exactly the given set of block positions.
+     */
+    static BlockRegion copyOf(Stream<Vec3> positions) {
+        return BakedBlockRegion.of(positions);
+    }
+
+    /**
+     * Return an immutable region containing exactly the given set of block positions.
+     */
+    static BlockRegion copyOf(Iterator<Vec3> positions) {
+        return BakedBlockRegion.of(positions);
+    }
+
+    /**
+     * Return an immutable region containing exactly the given set of block positions.
+     */
+    static BlockRegion copyOf(Iterable<Vec3> positions) {
+        return BakedBlockRegion.of(positions);
+    }
+}
diff --git a/src/main/java/org/bukkit/region/BlockRegionAdapter.java b/src/main/java/org/bukkit/region/BlockRegionAdapter.java
new file mode 100644
index 0000000..34353b7
--- /dev/null
+++ b/src/main/java/org/bukkit/region/BlockRegionAdapter.java
@@ -0,0 +1,151 @@
+package org.bukkit.region;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+
+class BlockRegionAdapter implements BlockRegion {
+
+    private final Set<Vec3> positions;
+
+    BlockRegionAdapter(Set<Vec3> positions) {
+        this.positions = positions;
+    }
+
+    @Override
+    public boolean isMutable() {
+        return true;
+    }
+
+    @Override
+    public BlockRegion copy() {
+        return BakedBlockRegion.of(positions);
+    }
+
+    @Override
+    public BlockRegion transform(CoarseTransform transform) {
+        return new TransformedBlockRegion(this, transform);
+    }
+
+    @Override
+    public BlockRegion filter(Predicate<? super Vec3> predicate) {
+        return new FilteredBlockRegion(this, predicate);
+    }
+
+    @Override
+    public int hashCode() {
+        return positions.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return positions.equals(obj);
+    }
+
+    @Override
+    public boolean contains(Vec3 pos) {
+        return positions.contains(pos);
+    }
+
+    @Override
+    public Iterator<Vec3> mutableIterator() {
+        return positions.iterator();
+    }
+
+    @Override
+    public int size() {
+        return positions.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return positions.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return positions.contains(o);
+    }
+
+    @Override
+    public Iterator<Vec3> iterator() {
+        return positions.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return positions.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        return positions.toArray(a);
+    }
+
+    @Override
+    public boolean add(Vec3 vec3) {
+        return positions.add(vec3);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return positions.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return positions.containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Vec3> c) {
+        return positions.addAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return positions.retainAll(c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        return positions.removeAll(c);
+    }
+
+    @Override
+    public void clear() {
+        positions.clear();
+    }
+
+    @Override
+    public Spliterator<Vec3> spliterator() {
+        return positions.spliterator();
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super Vec3> filter) {
+        return positions.removeIf(filter);
+    }
+
+    @Override
+    public Stream<Vec3> stream() {
+        return positions.stream();
+    }
+
+    @Override
+    public Stream<Vec3> parallelStream() {
+        return positions.parallelStream();
+    }
+
+    @Override
+    public void forEach(Consumer<? super Vec3> action) {
+        positions.forEach(action);
+    }
+}
diff --git a/src/main/java/org/bukkit/region/CuboidBlockIterator.java b/src/main/java/org/bukkit/region/CuboidBlockIterator.java
new file mode 100644
index 0000000..5648660
--- /dev/null
+++ b/src/main/java/org/bukkit/region/CuboidBlockIterator.java
@@ -0,0 +1,51 @@
+package org.bukkit.region;
+
+import java.util.NoSuchElementException;
+
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.geometry.Vec3;
+
+public class CuboidBlockIterator extends MutableBlockIterator {
+
+    private final int xMin, yMin;
+    private final int xMax, yMax, zMax;
+
+    private int x, y, z;
+    private boolean hasNext;
+
+    public CuboidBlockIterator(Vec3 min, Vec3 max) {
+        x = this.xMin = min.coarseX();
+        y = this.yMin = min.coarseY();
+        z = min.coarseZ();
+
+        this.xMax = max.coarseX();
+        this.yMax = max.coarseY();
+        this.zMax = max.coarseZ();
+
+        this.hasNext = x < xMax && y < yMax && z < zMax;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return hasNext;
+    }
+
+    @Override
+    protected void advance(MutableVec3 value) {
+        if(!hasNext) {
+            throw new NoSuchElementException();
+        }
+
+        value.set(x, y, z);
+
+        if(++x >= xMax) {
+            x = xMin;
+            if(++y >= yMax) {
+                y = yMin;
+                if(++z >= zMax) {
+                    hasNext = false;
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/region/CuboidBlockRegion.java b/src/main/java/org/bukkit/region/CuboidBlockRegion.java
new file mode 100644
index 0000000..690caa0
--- /dev/null
+++ b/src/main/java/org/bukkit/region/CuboidBlockRegion.java
@@ -0,0 +1,104 @@
+package org.bukkit.region;
+
+import java.util.Iterator;
+import java.util.function.Predicate;
+
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+
+public class CuboidBlockRegion implements BlockRegion {
+
+    private final Vec3 min;
+    private final Vec3 max; // Upper bound is exclusive
+
+    public static BlockRegion between(Vec3 a, Vec3 b) {
+        a = a.coarseCopy();
+        b = b.coarseCopy();
+
+        if(a.coarseX() == b.coarseX() ||
+           a.coarseY() == b.coarseY() ||
+           a.coarseZ() == b.coarseZ()) {
+            return EmptyBlockRegion.INSTANCE;
+        }
+
+        return new CuboidBlockRegion(a.minimum(b), a.maximum(b));
+    }
+
+    public static BlockRegion fromMinAndSize(Vec3 min, Vec3 size) {
+        size = size.coarseCopy();
+        if(size.coarseX() == 0 || size.coarseY() == 0 || size.coarseZ() == 0) {
+            return EmptyBlockRegion.INSTANCE;
+        }
+        min = min.coarseCopy();
+        return new CuboidBlockRegion(min, min.plus(size));
+    }
+
+    private CuboidBlockRegion(Vec3 min, Vec3 max) {
+        this.min = min;
+        this.max = max;
+    }
+
+    @Override
+    public boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    public int size() {
+        final Vec3 d = max.minus(min);
+        return d.coarseX() * d.coarseY() * d.coarseZ();
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        position = position.coarseCopy();
+        return min.coarseLessOrEqual(position) && max.coarseGreater(position);
+    }
+
+    @Override
+    public Iterator<Vec3> mutableIterator() {
+        return new CuboidBlockIterator(min, max);
+    }
+
+    @Override
+    public BlockRegion copy() {
+        return this;
+    }
+
+    @Override
+    public BlockRegion transform(CoarseTransform transform) {
+        return new CuboidBlockRegion(transform.apply(min), transform.apply(max));
+    }
+
+    @Override
+    public BlockRegion filter(Predicate<? super Vec3> predicate) {
+        return new FilteredBlockRegion(this, predicate);
+    }
+
+    @Override
+    public int hashCode() {
+        final int x0 = min.coarseX(), y0 = min.coarseY(), z0 = min.coarseZ();
+        final int x1 = max.coarseX(), y1 = max.coarseY(), z1 = max.coarseZ();
+
+        // There is probably some crazy formula for this
+        int hash = 0;
+        for(int x = x0; x < x1; x++) {
+            for(int y = y0; y < y1; y++) {
+                for(int z = z0; z < z1; z++) {
+                    hash += Vec3.combineHashCodes(x, y, z);
+                }
+            }
+        }
+        return hash;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+        if(obj instanceof CuboidBlockRegion) {
+            return min.equals(((CuboidBlockRegion) obj).min) &&
+                   max.equals(((CuboidBlockRegion) obj).max);
+        }
+        return standardEquals(obj);
+    }
+}
diff --git a/src/main/java/org/bukkit/region/EmptyBlockRegion.java b/src/main/java/org/bukkit/region/EmptyBlockRegion.java
new file mode 100644
index 0000000..f03e35b
--- /dev/null
+++ b/src/main/java/org/bukkit/region/EmptyBlockRegion.java
@@ -0,0 +1,82 @@
+package org.bukkit.region;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.function.Predicate;
+
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+
+class EmptyBlockRegion implements BlockRegion {
+
+    static final EmptyBlockRegion INSTANCE = new EmptyBlockRegion();
+
+    private EmptyBlockRegion() {}
+
+    @Override
+    public boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return true;
+    }
+
+    @Override
+    public int size() {
+        return 0;
+    }
+
+    @Override
+    public boolean contains(Vec3 pos) {
+        return false;
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return false;
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return c.isEmpty();
+    }
+
+    @Override
+    public Iterator<Vec3> mutableIterator() {
+        return Collections.emptyIterator();
+    }
+
+    @Override
+    public Iterator<Vec3> iterator() {
+        return Collections.emptyIterator();
+    }
+
+    @Override
+    public BlockRegion copy() {
+        return this;
+    }
+
+    @Override
+    public BlockRegion transform(CoarseTransform transform) {
+        return this;
+    }
+
+    @Override
+    public BlockRegion filter(Predicate<? super Vec3> predicate) {
+        return this;
+    }
+
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return obj instanceof Set && ((Set) obj).isEmpty();
+    }
+}
diff --git a/src/main/java/org/bukkit/region/FilteredBlockIterator.java b/src/main/java/org/bukkit/region/FilteredBlockIterator.java
new file mode 100644
index 0000000..4f82147
--- /dev/null
+++ b/src/main/java/org/bukkit/region/FilteredBlockIterator.java
@@ -0,0 +1,55 @@
+package org.bukkit.region;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.function.Predicate;
+
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.geometry.Vec3;
+
+public class FilteredBlockIterator extends MutableBlockIterator {
+
+    public static Iterator<Vec3> of(Iterator<Vec3> iterator, Predicate<? super Vec3> filter) {
+        if(iterator instanceof FilteredBlockIterator) {
+            final FilteredBlockIterator filtered = (FilteredBlockIterator) iterator;
+            return new FilteredBlockIterator(filtered.iterator, v -> filtered.filter.test(v) && filter.test(v));
+        }
+        return new FilteredBlockIterator(iterator, filter);
+    }
+
+    private final Iterator<Vec3> iterator;
+    private final Predicate<? super Vec3> filter;
+
+    private Vec3 next = null;
+
+    private FilteredBlockIterator(Iterator<Vec3> iterator, Predicate<? super Vec3> filter) {
+        this.iterator = iterator;
+        this.filter = filter;
+    }
+
+    @Override
+    public boolean hasNext() {
+        if(next != null) return true;
+
+        while(iterator.hasNext()) {
+            Vec3 v = iterator.next();
+
+            if(filter.test(v)) {
+                next = v;
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    protected void advance(MutableVec3 value) {
+        if(!hasNext()) {
+            throw new NoSuchElementException();
+        }
+
+        value.set(next);
+        next = null;
+    }
+}
diff --git a/src/main/java/org/bukkit/region/FilteredBlockRegion.java b/src/main/java/org/bukkit/region/FilteredBlockRegion.java
new file mode 100644
index 0000000..c568e17
--- /dev/null
+++ b/src/main/java/org/bukkit/region/FilteredBlockRegion.java
@@ -0,0 +1,79 @@
+package org.bukkit.region;
+
+import java.util.Iterator;
+import java.util.function.Predicate;
+
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+class FilteredBlockRegion implements BlockRegion {
+
+    protected final BlockRegion unfiltered;
+    protected final Predicate<? super Vec3> filter;
+
+    FilteredBlockRegion(BlockRegion unfiltered, Predicate<? super Vec3> filter) {
+        this.unfiltered = checkNotNull(unfiltered);
+        this.filter = checkNotNull(filter);
+    }
+
+    @Override
+    public boolean isMutable() {
+        return true; // Cannot be sure the predicate is constant
+    }
+
+    @Override
+    public boolean isEmpty() {
+        for(Vec3 p : unfiltered) {
+            if(filter.test(p)) return false;
+        }
+        return true;
+    }
+
+    @Override
+    public int size() {
+        int count = 0;
+        for(Vec3 p : unfiltered) {
+            if(filter.test(p)) count++;
+        }
+        return count;
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        return unfiltered.contains(position) && filter.test(position);
+    }
+
+    @Override
+    public Iterator<Vec3> mutableIterator() {
+        return FilteredBlockIterator.of(unfiltered.mutableIterator(), filter);
+    }
+
+    @Override
+    public int hashCode() {
+        return standardHashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return standardEquals(obj);
+    }
+
+    @Override
+    public BlockRegion copy() {
+        return BakedBlockRegion.of(this);
+    }
+
+    @Override
+    public BlockRegion transform(CoarseTransform transform) {
+        if(transform.isIdentity()) return this;
+        return new TransformedBlockRegion(this, transform);
+    }
+
+    @Override
+    public BlockRegion filter(Predicate<? super Vec3> predicate) {
+        if(filter.equals(predicate)) return this;
+        return new FilteredBlockRegion(unfiltered, filter.and((Predicate) predicate));
+    }
+}
diff --git a/src/main/java/org/bukkit/region/MutableBlockIterator.java b/src/main/java/org/bukkit/region/MutableBlockIterator.java
new file mode 100644
index 0000000..ce5ed1c
--- /dev/null
+++ b/src/main/java/org/bukkit/region/MutableBlockIterator.java
@@ -0,0 +1,22 @@
+package org.bukkit.region;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import org.bukkit.Bukkit;
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.geometry.Vec3;
+
+public abstract class MutableBlockIterator implements Iterator<Vec3> {
+
+    private final MutableVec3 value = Bukkit.vectors().coarseMutableZero();
+    private final Vec3 view = value.unmodifiable();
+
+    protected abstract void advance(MutableVec3 value) throws NoSuchElementException;
+
+    @Override
+    public final Vec3 next() {
+        advance(value);
+        return view;
+    }
+}
diff --git a/src/main/java/org/bukkit/region/TransformedBlockIterator.java b/src/main/java/org/bukkit/region/TransformedBlockIterator.java
new file mode 100644
index 0000000..2fa9325
--- /dev/null
+++ b/src/main/java/org/bukkit/region/TransformedBlockIterator.java
@@ -0,0 +1,37 @@
+package org.bukkit.region;
+
+import java.util.Iterator;
+
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.MutableVec3;
+import org.bukkit.geometry.Vec3;
+
+public class TransformedBlockIterator extends MutableBlockIterator {
+
+    public static Iterator<Vec3> of(Iterator<Vec3> iterator, CoarseTransform transform) {
+        if(iterator instanceof TransformedBlockIterator) {
+            final TransformedBlockIterator transformed = (TransformedBlockIterator) iterator;
+            return new TransformedBlockIterator(transformed.iterator, transformed.transform.andThen(transform));
+        }
+        return new TransformedBlockIterator(iterator, transform);
+    }
+
+    private final Iterator<Vec3> iterator;
+    private final CoarseTransform transform;
+
+    private TransformedBlockIterator(Iterator<Vec3> iterator, CoarseTransform transform) {
+        this.iterator = iterator;
+        this.transform = transform;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return iterator.hasNext();
+    }
+
+    @Override
+    protected void advance(MutableVec3 value) {
+        value.set(iterator.next());
+        transform.applyInPlace(value);
+    }
+}
diff --git a/src/main/java/org/bukkit/region/TransformedBlockRegion.java b/src/main/java/org/bukkit/region/TransformedBlockRegion.java
new file mode 100644
index 0000000..93f613e
--- /dev/null
+++ b/src/main/java/org/bukkit/region/TransformedBlockRegion.java
@@ -0,0 +1,73 @@
+package org.bukkit.region;
+
+import java.util.Iterator;
+import java.util.function.Predicate;
+
+import org.bukkit.geometry.CoarseTransform;
+import org.bukkit.geometry.Vec3;
+
+class TransformedBlockRegion implements BlockRegion {
+
+    private final BlockRegion original;
+    private final CoarseTransform transform, inverse;
+
+    TransformedBlockRegion(BlockRegion original, CoarseTransform transform) {
+        this.original = original;
+        this.transform = transform;
+        this.inverse = transform.inverse();
+    }
+
+    @Override
+    public boolean isMutable() {
+        return original.isMutable();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return original.isEmpty();
+    }
+
+    @Override
+    public int size() {
+        return original.size();
+    }
+
+    @Override
+    public boolean contains(Vec3 pos) {
+        return original.contains(inverse.apply(pos));
+    }
+
+    @Override
+    public Iterator<Vec3> mutableIterator() {
+        return TransformedBlockIterator.of(original.mutableIterator(), transform);
+    }
+
+    @Override
+    public BlockRegion copy() {
+        if(!original.isMutable()) return this;
+        return BakedBlockRegion.of(this);
+    }
+
+    @Override
+    public BlockRegion transform(CoarseTransform transform) {
+        if(transform.isIdentity()) return this;
+        transform = this.transform.andThen(transform);
+        if(transform.isIdentity()) return original;
+        return new TransformedBlockRegion(original, transform);
+    }
+
+    @Override
+    public BlockRegion filter(Predicate<? super Vec3> predicate) {
+        return new FilteredBlockRegion(this, predicate);
+    }
+
+    @Override
+    public int hashCode() {
+        return standardHashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return standardEquals(obj);
+    }
+}
diff --git a/src/main/java/org/bukkit/util/BlockVector.java b/src/main/java/org/bukkit/util/BlockVector.java
--- a/src/main/java/org/bukkit/util/BlockVector.java
+++ b/src/main/java/org/bukkit/util/BlockVector.java
@@ -2,6 +2,7 @@ package org.bukkit.util;
 
 import java.util.Map;
 import org.bukkit.configuration.serialization.SerializableAs;
+import org.bukkit.geometry.Vec3;
 
 /**
  * A vector with a hash function that floors the X, Y, Z components, a la
@@ -16,9 +17,7 @@ public class BlockVector extends Vector {
      * Construct the vector with all components as 0.
      */
     public BlockVector() {
-        this.x = 0;
-        this.y = 0;
-        this.z = 0;
+        super();
     }
 
     /**
@@ -27,9 +26,7 @@ public class BlockVector extends Vector {
      * @param vec The other vector.
      */
     public BlockVector(Vector vec) {
-        this.x = vec.getX();
-        this.y = vec.getY();
-        this.z = vec.getZ();
+        super(vec);
     }
 
     /**
@@ -40,9 +37,7 @@ public class BlockVector extends Vector {
      * @param z Z component
      */
     public BlockVector(int x, int y, int z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        super(x, y, z);
     }
 
     /**
@@ -53,9 +48,7 @@ public class BlockVector extends Vector {
      * @param z Z component
      */
     public BlockVector(double x, double y, double z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        super(x, y, z);
     }
 
     /**
@@ -66,9 +59,26 @@ public class BlockVector extends Vector {
      * @param z Z component
      */
     public BlockVector(float x, float y, float z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        super(x, y, z);
+    }
+
+    public BlockVector(Vec3 v) {
+        super(v);
+    }
+
+    @Override
+    public boolean isFine() {
+        return false;
+    }
+
+    @Override
+    public boolean isCoarse() {
+        return true;
+    }
+
+    @Override
+    public boolean equals(Vec3 v) {
+        return v != null && v.isCoarse() && coarseEquals(v);
     }
 
     /**
@@ -79,13 +89,7 @@ public class BlockVector extends Vector {
      */
     @Override
     public boolean equals(Object obj) {
-        if (!(obj instanceof BlockVector)) {
-            return false;
-        }
-        BlockVector other = (BlockVector) obj;
-
-        return (int) other.getX() == (int) this.x && (int) other.getY() == (int) this.y && (int) other.getZ() == (int) this.z;
-
+        return this == obj || (obj instanceof Vec3 && equals((Vec3) obj));
     }
 
     /**
@@ -95,7 +99,7 @@ public class BlockVector extends Vector {
      */
     @Override
     public int hashCode() {
-        return (Integer.valueOf((int) x).hashCode() >> 13) ^ (Integer.valueOf((int) y).hashCode() >> 7) ^ Integer.valueOf((int) z).hashCode();
+        return coarseHashCode();
     }
 
     /**
diff --git a/src/main/java/org/bukkit/util/ImVector.java b/src/main/java/org/bukkit/util/ImVector.java
new file mode 100644
index 0000000..0c53b96
--- /dev/null
+++ b/src/main/java/org/bukkit/util/ImVector.java
@@ -0,0 +1,190 @@
+package org.bukkit.util;
+
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.geometry.Vec3;
+
+/**
+ * An immutable {@link Vector}
+ *
+ * All the mutating methods inherited from {@link Vector}
+ * will throw an exception.
+ */
+public class ImVector extends Vector {
+
+    private static final ImVector ZERO = new ImVector(0, 0, 0);
+    private static final ImVector NaN = new ImVector(Double.NaN, Double.NaN, Double.NaN);
+
+    ImVector(double x, double y, double z) {
+        super(x, y, z);
+    }
+
+    public static ImVector of(double x, double y, double z) {
+        return x == 0 && y == 0 && z == 0 ? ZERO : new ImVector(x, y, z);
+    }
+
+    public static ImVector of(double n) {
+        return n == 0 ? ZERO : new ImVector(n, n, n);
+    }
+
+    public static ImVector ofZero() {
+        return ZERO;
+    }
+
+    public static ImVector ofNaN() {
+        return NaN;
+    }
+
+    public static ImVector copyOf(Vec3 v) {
+        return v instanceof ImVector ? (ImVector) v
+                                     : new ImVector(v.fineX(), v.fineY(), v.fineZ());
+    }
+
+    private static class Corner extends ImVector {
+        public Corner(int x, int y, int z) {
+            super((double) x, (double) y, (double) z);
+        }
+
+        @Override public boolean isBlockCorner() { return true; }
+        @Override public boolean isBlockCenter() { return false; }
+    }
+
+    private static class Center extends ImVector {
+        Center(int x, int y, int z) {
+            super(x + 0.5, y + 0.5, z + 0.5);
+        }
+
+        @Override public boolean isBlockCorner() { return false; }
+        @Override public boolean isBlockCenter() { return true; }
+    }
+
+    public static ImVector cornerOf(int x, int y, int z) {
+        return new Corner(x, y, z);
+    }
+
+    public static ImVector cornerOf(Vec3 v) {
+        return v instanceof Corner ? (Corner) v : new Corner(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    public static ImVector cornerOf(Block block) {
+        return new Corner(block.getX(), block.getY(), block.getZ());
+    }
+
+    public static ImVector cornerOf(BlockState block) {
+        return new Corner(block.getX(), block.getY(), block.getZ());
+    }
+
+    public static ImVector centerOf(int x, int y, int z) {
+        return new Center(x, y, z);
+    }
+
+    public static ImVector centerOf(Vec3 v) {
+        return v instanceof Center ? (Center) v : new Center(v.coarseX(), v.coarseY(), v.coarseZ());
+    }
+
+    public static ImVector centerOf(Block block) {
+        return new Center(block.getX(), block.getY(), block.getZ());
+    }
+
+    public static ImVector centerOf(BlockState block) {
+        return new Center(block.getX(), block.getY(), block.getZ());
+    }
+
+    public static ImVector minimum(Vec3 a, Vec3 b) {
+        return of(Math.min(a.fineX(), b.fineX()),
+                  Math.min(a.fineY(), b.fineY()),
+                  Math.min(a.fineZ(), b.fineZ()));
+    }
+
+    public static ImVector maximum(Vec3 a, Vec3 b) {
+        return of(Math.max(a.fineX(), b.fineX()),
+                  Math.max(a.fineY(), b.fineY()),
+                  Math.max(a.fineZ(), b.fineZ()));
+    }
+
+    public static ImVector min(Vec3... a) {
+        double x, y, z;
+        x = y = z = Double.POSITIVE_INFINITY;
+        for(Vec3 v : a) {
+            x = Math.min(x, v.fineX());
+            y = Math.min(y, v.fineY());
+            z = Math.min(z, v.fineZ());
+        }
+        return of(x, y, z);
+    }
+
+    public static ImVector max(Vec3... a) {
+        double x, y, z;
+        x = y = z = Double.NEGATIVE_INFINITY;
+        for(Vec3 v : a) {
+            x = Math.max(x, v.fineX());
+            y = Math.max(y, v.fineY());
+            z = Math.max(z, v.fineZ());
+        }
+        return of(x, y, z);
+    }
+
+    public static ImVector interpolate(Vec3 a, Vec3 b, double n) {
+        return of(NumberConversions.interpolate(a.fineX(), b.fineX(), n),
+                  NumberConversions.interpolate(a.fineY(), b.fineY(), n),
+                  NumberConversions.interpolate(a.fineZ(), b.fineZ(), n));
+    }
+
+    @Override
+    public boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    public ImVector copy() {
+        return this;
+    }
+
+    @Override
+    public ImVector times(int n) {
+        if(n == 0) return ZERO;
+        if(n == 1) return this;
+        return super.times(n);
+    }
+
+    @Override
+    public ImVector times(double n) {
+        if(n == 0) return ZERO;
+        if(n == 1) return this;
+        return super.times(n);
+    }
+
+    @Override
+    public ImVector over(double n) {
+        if(Double.isInfinite(n)) {
+            return ZERO;
+        } else if(n == 1) {
+            return this;
+        } else {
+            return super.over(n);
+        }
+    }
+
+    @Override
+    public ImVector getCrossProduct(Vector v) {
+        return of(this.fineY() * v.fineZ() - v.fineY() * this.fineZ(),
+                  this.fineZ() * v.fineX() - v.fineZ() * this.fineX(),
+                  this.fineX() * v.fineY() - v.fineX() * this.fineY());
+    }
+
+    @Override
+    public ImVector getMidpoint(Vector v) {
+        return of((fineX() + v.getX()) / 2,
+                  (fineY() + v.getY()) / 2,
+                  (fineZ() + v.getZ()) / 2);
+    }
+
+    private UnsupportedOperationException ex() {
+        return new UnsupportedOperationException("object is immutable");
+    }
+
+    @Override public Vector setX(double x) { throw ex(); }
+    @Override public Vector setY(double y) { throw ex(); }
+    @Override public Vector setZ(double z) { throw ex(); }
+    @Override public Vector set(double x, double y, double z) { throw ex(); }
+}
diff --git a/src/main/java/org/bukkit/util/NumberConversions.java b/src/main/java/org/bukkit/util/NumberConversions.java
--- a/src/main/java/org/bukkit/util/NumberConversions.java
+++ b/src/main/java/org/bukkit/util/NumberConversions.java
@@ -121,4 +121,45 @@ public final class NumberConversions {
             throw new IllegalArgumentException(message);
         }
     }
+
+    public static double interpolate(double a, double b, double n) {
+        return (1D - n) * a + n * b;
+    }
+
+    public static double min(double... a) {
+        double n = Double.POSITIVE_INFINITY;
+        for(int i = 0; i < a.length; i++) {
+            n = Math.min(n, a[i]);
+        }
+        return n;
+    }
+
+    public static double max(double... a) {
+        double n = Double.NEGATIVE_INFINITY;
+        for(int i = 0; i < a.length; i++) {
+            n = Math.max(n, a[i]);
+        }
+        return n;
+    }
+
+    public static int mod(int n, int m) {
+        if(m <= 0) {
+            throw new ArithmeticException("Modulus " + m + " must be > 0");
+        }
+        int result = n % m;
+        return (result >= 0) ? result : result + m;
+    }
+
+    public static int hashCode(double n) {
+        final long bits = Double.doubleToLongBits(n);
+        return (int) (bits ^ (bits >>> 32));
+    }
+
+    public static int clamp(int n, int min, int max) {
+        return n < min ? min : n > max ? max : n;
+    }
+
+    public static double clamp(double n, double min, double max) {
+        return n < min ? min : n > max ? max : n;
+    }
 }
diff --git a/src/main/java/org/bukkit/util/RayBlockIntersection.java b/src/main/java/org/bukkit/util/RayBlockIntersection.java
--- a/src/main/java/org/bukkit/util/RayBlockIntersection.java
+++ b/src/main/java/org/bukkit/util/RayBlockIntersection.java
@@ -2,6 +2,7 @@ package org.bukkit.util;
 
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockFace;
+import org.bukkit.geometry.Vec3;
 
 /**
  * Result of a ray-block intersection test
@@ -9,12 +10,12 @@ import org.bukkit.block.BlockFace;
 public class RayBlockIntersection {
     private final Block block;
     private final BlockFace face;
-    private final Vector position;
+    private final ImVector position;
 
-    public RayBlockIntersection(Block block, BlockFace face, Vector position) {
+    public RayBlockIntersection(Block block, BlockFace face, Vec3 position) {
         this.block = block;
         this.face = face;
-        this.position = position;
+        this.position = ImVector.copyOf(position);
     }
 
     /**
diff --git a/src/main/java/org/bukkit/util/SetBase.java b/src/main/java/org/bukkit/util/SetBase.java
new file mode 100644
index 0000000..036df35
--- /dev/null
+++ b/src/main/java/org/bukkit/util/SetBase.java
@@ -0,0 +1,60 @@
+package org.bukkit.util;
+
+import java.util.Collection;
+import java.util.Set;
+
+public interface SetBase<E> extends Set<E> {
+
+    @Override
+    default boolean isEmpty() {
+        return size() <= 0;
+    }
+
+    @Override
+    default boolean containsAll(Collection<?> c) {
+        for(Object o : c) {
+            if(contains(o)) return true;
+        }
+        return false;
+    }
+
+    @Override
+    default Object[] toArray() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default <T> T[] toArray(T[] a) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default boolean add(E vec3) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default boolean remove(Object o) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default boolean addAll(Collection<? extends E> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default boolean retainAll(Collection<?> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default boolean removeAll(Collection<?> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    default void clear() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/org/bukkit/util/Vector.java b/src/main/java/org/bukkit/util/Vector.java
--- a/src/main/java/org/bukkit/util/Vector.java
+++ b/src/main/java/org/bukkit/util/Vector.java
@@ -3,11 +3,14 @@ package org.bukkit.util;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Random;
+
+import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.World;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
 import org.bukkit.configuration.serialization.SerializableAs;
-import static org.bukkit.util.NumberConversions.checkFinite;
+import org.bukkit.geometry.Cuboid;
+import org.bukkit.geometry.Vec3;
 
 /**
  * Represents a mutable vector. Because the components of Vectors are mutable,
@@ -16,7 +19,7 @@ import static org.bukkit.util.NumberConversions.checkFinite;
  * <code>clone()</code> in order to get a copy.
  */
 @SerializableAs("Vector")
-public class Vector implements Cloneable, ConfigurationSerializable {
+public class Vector extends VectorBase<Vector> implements Cloneable, ConfigurationSerializable {
     private static final long serialVersionUID = -2657651106777219169L;
 
     private static Random random = new Random();
@@ -26,17 +29,11 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      */
     private static final double epsilon = 0.000001;
 
-    protected double x;
-    protected double y;
-    protected double z;
-
     /**
      * Construct the vector with all components as 0.
      */
     public Vector() {
-        this.x = 0;
-        this.y = 0;
-        this.z = 0;
+        super(0, 0, 0);
     }
 
     /**
@@ -47,9 +44,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param z Z component
      */
     public Vector(int x, int y, int z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        super(x, y, z);
     }
 
     /**
@@ -60,9 +55,14 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param z Z component
      */
     public Vector(double x, double y, double z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        super(x, y, z);
+    }
+
+    /**
+     * Construct the vector with all components set to the given value
+     */
+    public Vector(double n) {
+        super(n, n, n);
     }
 
     /**
@@ -73,9 +73,63 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param z Z component
      */
     public Vector(float x, float y, float z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
+        super(x, y, z);
+    }
+
+    /**
+     * Construct a copy of the given Vector
+     */
+    public Vector(Vec3 that) {
+        super(that.fineX(), that.fineY(), that.fineZ());
+    }
+
+    @Override
+    public Vector mutableCopy() {
+        return new Vector(this);
+    }
+
+    @Override
+    public Vec3 coarseOf(int x, int y, int z) {
+        return Bukkit.vectors().coarse(x, y, z);
+    }
+
+    @Override
+    public Vec3 coarseZero() {
+        return Bukkit.vectors().coarseZero();
+    }
+
+    @Override
+    public ImVector fineOf(double x, double y, double z) {
+        return ImVector.of(x, y, z);
+    }
+
+    @Override
+    public ImVector fineZero() {
+        return ImVector.ofZero();
+    }
+
+    public Vector clamp(Cuboid bounds) {
+        return clamp(bounds.minimum(), bounds.maximum());
+    }
+
+    @Override
+    public Vec3 unmodifiable() {
+        return new ImVector(0, 0, 0) {
+            @Override
+            public double fineX() {
+                return Vector.this.fineX();
+            }
+
+            @Override
+            public double fineY() {
+                return Vector.this.fineY();
+            }
+
+            @Override
+            public double fineZ() {
+                return Vector.this.fineZ();
+            }
+        };
     }
 
     /**
@@ -85,10 +139,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector add(Vector vec) {
-        x += vec.x;
-        y += vec.y;
-        z += vec.z;
-        return this;
+        return add((Vec3) vec);
     }
 
     /**
@@ -98,10 +149,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector subtract(Vector vec) {
-        x -= vec.x;
-        y -= vec.y;
-        z -= vec.z;
-        return this;
+        return subtract((Vec3) vec);
     }
 
     /**
@@ -111,10 +159,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector multiply(Vector vec) {
-        x *= vec.x;
-        y *= vec.y;
-        z *= vec.z;
-        return this;
+        return set(this.fineX() * vec.fineX(), this.fineY() * vec.fineY(), this.fineZ() * vec.fineZ());
     }
 
     /**
@@ -124,10 +169,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector divide(Vector vec) {
-        x /= vec.x;
-        y /= vec.y;
-        z /= vec.z;
-        return this;
+        return set(this.fineX() / vec.fineX(), this.fineY() / vec.fineY(), this.fineZ() / vec.fineZ());
     }
 
     /**
@@ -137,10 +179,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector copy(Vector vec) {
-        x = vec.x;
-        y = vec.y;
-        z = vec.z;
-        return this;
+        return set(vec);
     }
 
     /**
@@ -153,7 +192,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the magnitude
      */
     public double length() {
-        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
+        return super.length();
     }
 
     /**
@@ -162,7 +201,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the magnitude
      */
     public double lengthSquared() {
-        return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
+        return super.lengthSquared();
     }
 
     /**
@@ -176,7 +215,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the distance
      */
     public double distance(Vector o) {
-        return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));
+        return distance((Vec3) o);
     }
 
     /**
@@ -186,7 +225,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the distance
      */
     public double distanceSquared(Vector o) {
-        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
+        return distanceSquared((Vec3) o);
     }
 
     /**
@@ -208,10 +247,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return this same vector (now a midpoint)
      */
     public Vector midpoint(Vector other) {
-        x = (x + other.x) / 2;
-        y = (y + other.y) / 2;
-        z = (z + other.z) / 2;
-        return this;
+        return set((fineX() + other.fineX()) / 2,
+                   (fineY() + other.fineY()) / 2,
+                   (fineZ() + other.fineZ()) / 2);
     }
 
     /**
@@ -221,9 +259,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return a new midpoint vector
      */
     public Vector getMidpoint(Vector other) {
-        double x = (this.x + other.x) / 2;
-        double y = (this.y + other.y) / 2;
-        double z = (this.z + other.z) / 2;
+        double x = (this.fineX() + other.fineX()) / 2;
+        double y = (this.fineY() + other.fineY()) / 2;
+        double z = (this.fineZ() + other.fineZ()) / 2;
         return new Vector(x, y, z);
     }
 
@@ -235,10 +273,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector multiply(int m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
+        return set(fineX() * m, fineY() * m, fineZ() * m);
     }
 
     /**
@@ -249,10 +284,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector multiply(double m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
+        return set(fineX() * m, fineY() * m, fineZ() * m);
     }
 
     /**
@@ -263,10 +295,11 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector multiply(float m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
+        return set(fineX() * m, fineY() * m, fineZ() * m);
+    }
+
+    public Vector divide(double m) {
+        return set(fineX() / m, fineY() / m, fineZ() / m);
     }
 
     /**
@@ -277,7 +310,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return dot product
      */
     public double dot(Vector other) {
-        return x * other.x + y * other.y + z * other.z;
+        return dot((Vec3) other);
     }
 
     /**
@@ -293,14 +326,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector crossProduct(Vector o) {
-        double newX = y * o.z - o.y * z;
-        double newY = z * o.x - o.z * x;
-        double newZ = x * o.y - o.x * y;
-
-        x = newX;
-        y = newY;
-        z = newZ;
-        return this;
+        return set(fineY() * o.fineZ() - o.fineY() * fineZ(),
+                   fineZ() * o.fineX() - o.fineZ() * fineX(),
+                   fineX() * o.fineY() - o.fineX() * fineY());
     }
 
     /**
@@ -316,9 +344,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return a new vector
      */
     public Vector getCrossProduct(Vector o) {
-        double x = this.y * o.z - o.y * this.z;
-        double y = this.z * o.x - o.z * this.x;
-        double z = this.x * o.y - o.x * this.y;
+        double x = this.fineY() * o.fineZ() - o.fineY() * this.fineZ();
+        double y = this.fineZ() * o.fineX() - o.fineZ() * this.fineX();
+        double z = this.fineX() * o.fineY() - o.fineX() * this.fineY();
         return new Vector(x, y, z);
     }
 
@@ -328,13 +356,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector normalize() {
-        double length = length();
-
-        x /= length;
-        y /= length;
-        z /= length;
-
-        return this;
+        return divide(length());
     }
 
     /**
@@ -343,10 +365,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the same vector
      */
     public Vector zero() {
-        x = 0;
-        y = 0;
-        z = 0;
-        return this;
+        return setZero();
     }
 
     /**
@@ -360,7 +379,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return whether this vector is in the AABB
      */
     public boolean isInAABB(Vector min, Vector max) {
-        return x >= min.x && x <= max.x && y >= min.y && y <= max.y && z >= min.z && z <= max.z;
+        return fineX() >= min.fineX() && fineX() <= max.fineX() && fineY() >= min.fineY() && fineY() <= max.fineY() && fineZ() >= min.fineZ() && fineZ() <= max.fineZ();
     }
 
     /**
@@ -371,7 +390,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return whether this vector is in the sphere
      */
     public boolean isInSphere(Vector origin, double radius) {
-        return (NumberConversions.square(origin.x - x) + NumberConversions.square(origin.y - y) + NumberConversions.square(origin.z - z)) <= NumberConversions.square(radius);
+        return (NumberConversions.square(origin.fineX() - fineX()) + NumberConversions.square(origin.fineY() - fineY()) + NumberConversions.square(origin.fineZ() - fineZ())) <= NumberConversions.square(radius);
     }
 
     /**
@@ -380,7 +399,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return The X component.
      */
     public double getX() {
-        return x;
+        return fineX();
     }
 
     /**
@@ -390,7 +409,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return block X
      */
     public int getBlockX() {
-        return NumberConversions.floor(x);
+        return coarseX();
     }
 
     /**
@@ -399,7 +418,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return The Y component.
      */
     public double getY() {
-        return y;
+        return fineY();
     }
 
     /**
@@ -409,7 +428,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return block y
      */
     public int getBlockY() {
-        return NumberConversions.floor(y);
+        return coarseY();
     }
 
     /**
@@ -418,7 +437,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return The Z component.
      */
     public double getZ() {
-        return z;
+        return fineZ();
     }
 
     /**
@@ -428,7 +447,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return block z
      */
     public int getBlockZ() {
-        return NumberConversions.floor(z);
+        return coarseZ();
     }
 
     /**
@@ -437,8 +456,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param x The new X component.
      * @return This vector.
      */
+    @Override
     public Vector setX(int x) {
-        this.x = x;
+        setX((double) x);
         return this;
     }
 
@@ -448,8 +468,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param x The new X component.
      * @return This vector.
      */
+    @Override
     public Vector setX(double x) {
-        this.x = x;
+        super.setX(x);
         return this;
     }
 
@@ -460,7 +481,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return This vector.
      */
     public Vector setX(float x) {
-        this.x = x;
+        setX((double) x);
         return this;
     }
 
@@ -470,8 +491,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param y The new Y component.
      * @return This vector.
      */
+    @Override
     public Vector setY(int y) {
-        this.y = y;
+        setY((double) y);
         return this;
     }
 
@@ -481,8 +503,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param y The new Y component.
      * @return This vector.
      */
+    @Override
     public Vector setY(double y) {
-        this.y = y;
+        super.setY(y);
         return this;
     }
 
@@ -493,7 +516,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return This vector.
      */
     public Vector setY(float y) {
-        this.y = y;
+        setY((double) y);
         return this;
     }
 
@@ -503,8 +526,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param z The new Z component.
      * @return This vector.
      */
+    @Override
     public Vector setZ(int z) {
-        this.z = z;
+        setZ((double) z);
         return this;
     }
 
@@ -514,8 +538,9 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @param z The new Z component.
      * @return This vector.
      */
+    @Override
     public Vector setZ(double z) {
-        this.z = z;
+        super.setZ(z);
         return this;
     }
 
@@ -526,26 +551,13 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return This vector.
      */
     public Vector setZ(float z) {
-        this.z = z;
+        setZ((double) z);
         return this;
     }
 
-    /**
-     * Checks to see if two objects are equal.
-     * <p>
-     * Only two Vectors can ever return true. This method uses a fuzzy match
-     * to account for floating point errors. The epsilon can be retrieved
-     * with epsilon.
-     */
     @Override
     public boolean equals(Object obj) {
-        if (!(obj instanceof Vector)) {
-            return false;
-        }
-
-        Vector other = (Vector) obj;
-
-        return Math.abs(x - other.x) < epsilon && Math.abs(y - other.y) < epsilon && Math.abs(z - other.z) < epsilon && (this.getClass().equals(obj.getClass()));
+        return this == obj || (obj instanceof Vec3 && equals((Vec3) obj));
     }
 
     /**
@@ -555,12 +567,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      */
     @Override
     public int hashCode() {
-        int hash = 7;
-
-        hash = 79 * hash + (int) (Double.doubleToLongBits(this.x) ^ (Double.doubleToLongBits(this.x) >>> 32));
-        hash = 79 * hash + (int) (Double.doubleToLongBits(this.y) ^ (Double.doubleToLongBits(this.y) >>> 32));
-        hash = 79 * hash + (int) (Double.doubleToLongBits(this.z) ^ (Double.doubleToLongBits(this.z) >>> 32));
-        return hash;
+        return fineHashCode();
     }
 
     /**
@@ -582,7 +589,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      */
     @Override
     public String toString() {
-        return x + "," + y + "," + z;
+        return fineX() + "," + fineY() + "," + fineZ();
     }
 
     /**
@@ -592,7 +599,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the location
      */
     public Location toLocation(World world) {
-        return new Location(world, x, y, z);
+        return new Location(world, fineX(), fineY(), fineZ());
     }
 
     /**
@@ -604,7 +611,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return the location
      */
     public Location toLocation(World world, float yaw, float pitch) {
-        return new Location(world, x, y, z, yaw, pitch);
+        return new Location(world, fineX(), fineY(), fineZ(), yaw, pitch);
     }
 
     /**
@@ -613,7 +620,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return A block vector.
      */
     public BlockVector toBlockVector() {
-        return new BlockVector(x, y, z);
+        return new BlockVector(fineX(), fineY(), fineZ());
     }
 
     /**
@@ -633,7 +640,7 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return minimum
      */
     public static Vector getMinimum(Vector v1, Vector v2) {
-        return new Vector(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y), Math.min(v1.z, v2.z));
+        return new Vector(Math.min(v1.fineX(), v2.fineX()), Math.min(v1.fineY(), v2.fineY()), Math.min(v1.fineZ(), v2.fineZ()));
     }
 
     /**
@@ -644,7 +651,19 @@ public class Vector implements Cloneable, ConfigurationSerializable {
      * @return maximum
      */
     public static Vector getMaximum(Vector v1, Vector v2) {
-        return new Vector(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y), Math.max(v1.z, v2.z));
+        return new Vector(Math.max(v1.fineX(), v2.fineX()), Math.max(v1.fineY(), v2.fineY()), Math.max(v1.fineZ(), v2.fineZ()));
+    }
+
+    public static Vector minimum(Vec3 a, Vec3 b) {
+        return new Vector(Math.min(a.fineX(), b.fineX()),
+                          Math.min(a.fineY(), b.fineY()),
+                          Math.min(a.fineZ(), b.fineZ()));
+    }
+
+    public static Vector maximum(Vec3 a, Vec3 b) {
+        return new Vector(Math.max(a.fineX(), b.fineX()),
+                          Math.max(a.fineY(), b.fineY()),
+                          Math.max(a.fineZ(), b.fineZ()));
     }
 
     /**
diff --git a/src/main/java/org/bukkit/util/VectorBase.java b/src/main/java/org/bukkit/util/VectorBase.java
new file mode 100644
index 0000000..ab193d3
--- /dev/null
+++ b/src/main/java/org/bukkit/util/VectorBase.java
@@ -0,0 +1,57 @@
+package org.bukkit.util;
+
+import org.bukkit.geometry.MutableVec3Fine;
+
+abstract class VectorBase<M extends VectorBase<M>> implements MutableVec3Fine<ImVector, M> {
+
+    private double x;
+    private double y;
+    private double z;
+
+    protected VectorBase(double x, double y, double z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    @Override
+    public double fineX() {
+        return x;
+    }
+
+    @Override
+    public double fineY() {
+        return y;
+    }
+
+    @Override
+    public double fineZ() {
+        return z;
+    }
+
+    @Override
+    public M setX(double x) {
+        this.x = x;
+        return (M) this;
+    }
+
+    @Override
+    public M setY(double y) {
+        this.y = y;
+        return (M) this;
+    }
+
+    @Override
+    public M setZ(double z) {
+        this.z = z;
+        return (M) this;
+    }
+
+    @Override
+    public M set(double x, double y, double z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        return (M) this;
+    }
+}
diff --git a/src/test/java/org/bukkit/LocationTest.java b/src/test/java/org/bukkit/LocationTest.java
--- a/src/test/java/org/bukkit/LocationTest.java
+++ b/src/test/java/org/bukkit/LocationTest.java
@@ -5,6 +5,7 @@ import static org.junit.Assert.*;
 
 import java.util.List;
 import java.util.Random;
+import java.util.UUID;
 
 import org.bukkit.util.Vector;
 import org.junit.Test;
@@ -184,7 +185,7 @@ public class LocationTest {
     }
 
     private static Location getEmptyLocation() {
-        return new Location(null, 0, 0, 0);
+        return new Location(new UUID(0, 0), 0, 0, 0);
     }
 
     private Location getLocation() {
