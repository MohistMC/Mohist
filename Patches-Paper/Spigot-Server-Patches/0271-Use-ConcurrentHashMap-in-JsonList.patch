From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: egg82 <phantom_zero@ymail.com>
Date: Tue, 7 Aug 2018 01:24:23 -0600
Subject: [PATCH] Use ConcurrentHashMap in JsonList

This is specifically aimed at fixing #471

Using a ConcurrentHashMap because thread safety
The performance benefit of Map over ConcurrentMap is negligabe at best in this scenaio, as most operations will be get and not add or remove
Even without considering the use-case the benefits are still negligable

Original ideas for the system included an expiration policy and/or handler
The simpler solution was to use a computeIfPresent in the get method
This will simultaneously have an O(1) lookup time and automatically expire any values
Since the get method (nor other similar methods) don't seem to have a critical need to flush the map to disk at any of these points further processing is simply wasteful
Meaning the original function expired values unrelated to the current value without actually having any explicit need to

The h method was heavily modified to be much more efficient in its processing
Also instead of being called on every get, it's now called just before a save
This will eliminate stale values being flushed to disk

Modified isEmpty to use the isEmpty() method instead of the slightly confusing size() < 1
The point of this is readability, but does have a side-benefit of a small microptimization

Finally, added a couple obfhelpers for the modified code

diff --git a/src/main/java/net/minecraft/server/JsonList.java b/src/main/java/net/minecraft/server/JsonList.java
index 734e7ecf630aa13a30d72ff96e57e5d0faf35013..8570e38f42e2f489e2899ac2f0c4a7b8dda3bb75 100644
--- a/src/main/java/net/minecraft/server/JsonList.java
+++ b/src/main/java/net/minecraft/server/JsonList.java
@@ -35,7 +35,8 @@ public class JsonList<K, V extends JsonListEntry<K>> {
     protected static final Logger LOGGER = LogManager.getLogger();
     protected final Gson b;
     private final File c;
-    private final Map<String, V> d = Maps.newHashMap();
+    // Paper - replace HashMap is ConcurrentHashMap
+    private final Map<String, V> d = Maps.newConcurrentMap(); private final Map<String, V> getBackingMap() { return this.d; } // Paper - OBFHELPER
     private boolean e = true;
     private static final ParameterizedType f = new ParameterizedType() {
         public Type[] getActualTypeArguments() {
@@ -84,8 +85,13 @@ public class JsonList<K, V extends JsonListEntry<K>> {
 
     @Nullable
     public V get(K k0) {
-        this.h();
-        return (V) this.d.get(this.a(k0)); // CraftBukkit - fix decompile error
+        // Paper start
+        // this.h();
+        // return (V) this.d.get(this.a(k0)); // CraftBukkit - fix decompile error
+        return (V) this.getBackingMap().computeIfPresent(this.getMappingKey(k0), (k, v) -> {
+            return v.hasExpired() ? null : v;
+        });
+        // Paper end
     }
 
     public void remove(K k0) {
@@ -114,9 +120,11 @@ public class JsonList<K, V extends JsonListEntry<K>> {
     // CraftBukkit end
 
     public boolean isEmpty() {
-        return this.d.size() < 1;
+        // return this.d.size() < 1; // Paper
+        return this.getBackingMap().isEmpty(); // Paper - readability is the goal. As an aside, isEmpty() uses only sumCount() and a comparison. size() uses sumCount(), casts, and boolean logic
     }
 
+    protected final String getMappingKey(K k0) { return a(k0); } // Paper - OBFHELPER
     protected String a(K k0) {
         return k0.toString();
     }
@@ -125,8 +133,9 @@ public class JsonList<K, V extends JsonListEntry<K>> {
         return this.d.containsKey(this.a(k0));
     }
 
+    private void removeStaleEntries() { h(); } // Paper - OBFHELPER
     private void h() {
-        List<K> list = Lists.newArrayList();
+        /*List<K> list = Lists.newArrayList();
         Iterator iterator = this.d.values().iterator();
 
         while (iterator.hasNext()) {
@@ -143,8 +152,10 @@ public class JsonList<K, V extends JsonListEntry<K>> {
             K k0 = (K) iterator.next(); // CraftBukkit - decompile error
 
             this.d.remove(this.a(k0));
-        }
+        }*/
 
+        this.getBackingMap().values().removeIf(JsonListEntry::hasExpired);
+        // Paper end
     }
 
     protected JsonListEntry<K> a(JsonObject jsonobject) {
@@ -156,6 +167,7 @@ public class JsonList<K, V extends JsonListEntry<K>> {
     }
 
     public void save() throws IOException {
+        this.removeStaleEntries(); // Paper - remove expired values before saving
         Collection<V> collection = this.d.values();
         String s = this.b.toJson(collection);
         BufferedWriter bufferedwriter = null;
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index b69cff40922ba2d1a44c11bcae86f9439130ad96..22f18be4627fefe500239f7a35eee3b019bcffcc 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -512,7 +512,7 @@ public abstract class PlayerList {
         } else if (!this.isWhitelisted(gameprofile, event)) { // Paper
             chatmessage = new ChatMessage("multiplayer.disconnect.not_whitelisted", new Object[0]);
             //event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot // Paper - moved to isWhitelisted
-        } else if (getIPBans().isBanned(socketaddress) && !getIPBans().get(socketaddress).hasExpired()) {
+        } else if (getIPBans().isBanned(socketaddress) && getIPBans().get(socketaddress) != null && !getIPBans().get(socketaddress).hasExpired()) { // Paper - fix NPE with temp ip bans
             IpBanEntry ipbanentry = this.l.get(socketaddress);
 
             chatmessage = new ChatMessage("multiplayer.disconnect.banned_ip.reason", new Object[]{ipbanentry.getReason()});
