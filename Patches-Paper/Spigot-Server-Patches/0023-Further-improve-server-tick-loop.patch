From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Tue, 1 Mar 2016 23:09:29 -0600
Subject: [PATCH] Further improve server tick loop

Improves how the catchup buffer is handled, allowing it to roll both ways
increasing the effeciency of the thread sleep so it only will sleep once.

Also increases the buffer of the catchup to ensure server stays at 20 TPS unless extreme conditions

Previous implementation did not calculate TPS correctly.
Switch to a realistic rolling average and factor in std deviation as an extra reporting variable

diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b6912f97c2240b0524735e0f8d1937f2e76dba5b..c61037c837e29544e3afeb0b23f422073d3f5166 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -160,7 +160,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     public org.bukkit.command.ConsoleCommandSender console;
     public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
     public ConsoleReader reader;
-    public static int currentTick = (int) (System.currentTimeMillis() / 50);
+    public static int currentTick = 0; // Paper - Further improve tick loop
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     public File bukkitDataPackFolder;
@@ -170,7 +170,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     // Spigot start
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / TPS;
-    private static final int SAMPLE_INTERVAL = 100;
+    private static final int SAMPLE_INTERVAL = 20; // Paper
     public final double[] recentTps = new double[ 3 ];
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     // Spigot end
@@ -781,6 +781,57 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     {
         return ( avg * exp ) + ( tps * ( 1 - exp ) );
     }
+
+    // Paper start - Further improve server tick loop
+    private static final long SEC_IN_NANO = 1000000000;
+    private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
+    private long lastTick = 0;
+    private long catchupTime = 0;
+    public final RollingAverage tps1 = new RollingAverage(60);
+    public final RollingAverage tps5 = new RollingAverage(60 * 5);
+    public final RollingAverage tps15 = new RollingAverage(60 * 15);
+
+    public static class RollingAverage {
+        private final int size;
+        private long time;
+        private java.math.BigDecimal total;
+        private int index = 0;
+        private final java.math.BigDecimal[] samples;
+        private final long[] times;
+
+        RollingAverage(int size) {
+            this.size = size;
+            this.time = size * SEC_IN_NANO;
+            this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
+            this.samples = new java.math.BigDecimal[size];
+            this.times = new long[size];
+            for (int i = 0; i < size; i++) {
+                this.samples[i] = dec(TPS);
+                this.times[i] = SEC_IN_NANO;
+            }
+        }
+
+        private static java.math.BigDecimal dec(long t) {
+            return new java.math.BigDecimal(t);
+        }
+        public void add(java.math.BigDecimal x, long t) {
+            time -= times[index];
+            total = total.subtract(samples[index].multiply(dec(times[index])));
+            samples[index] = x;
+            times[index] = t;
+            time += t;
+            total = total.add(x.multiply(dec(t)));
+            if (++index == size) {
+                index = 0;
+            }
+        }
+
+        public double getAverage() {
+            return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
+        }
+    }
+    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
+    // Paper End
     // Spigot End
 
     public void run() {
@@ -793,30 +844,38 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
 
                 // Spigot start
                 Arrays.fill( recentTps, 20 );
-                long curTime, tickSection = SystemUtils.getMonotonicMillis(), tickCount = 1;
+                long start = System.nanoTime(), curTime, tickSection = start; // Paper - Further improve server tick loop
+                lastTick = start - TICK_TIME; // Paper
                 while (this.isRunning) {
-                    long i = (curTime = SystemUtils.getMonotonicMillis()) - this.nextTick;
+                    long i = ((curTime = System.nanoTime()) / (1000L * 1000L)) - this.nextTick; // Paper
 
                     if (i > 5000L && this.nextTick - this.lastOverloadTime >= 30000L) { // CraftBukkit
                         long j = i / 50L;
 
                         if (server.getWarnOnOverload()) // CraftBukkit
-                        MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
+                            MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
                         this.nextTick += j * 50L;
                         this.lastOverloadTime = this.nextTick;
                     }
 
-                    if ( tickCount++ % SAMPLE_INTERVAL == 0 )
+                    if ( ++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0 )
                     {
-                        double currentTps = 1E3 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
-                        recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
-                        recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
-                        recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
+                        final long diff = curTime - tickSection;
+                        java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                        tps1.add(currentTps, diff);
+                        tps5.add(currentTps, diff);
+                        tps15.add(currentTps, diff);
+                        // Backwards compat with bad plugins
+                        recentTps[0] = tps1.getAverage();
+                        recentTps[1] = tps5.getAverage();
+                        recentTps[2] = tps15.getAverage();
+                        // Paper end
                         tickSection = curTime;
                     }
                     // Spigot end
 
-                    MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit
+                    //MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit // Paper - don't overwrite current tick time
+                    lastTick = curTime;
                     this.nextTick += 50L;
                     if (this.T) {
                         this.T = false;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index ee749863730cb2228712ceddd4e405a798f73c5e..99083a1f36f95a4fb3d67f903d02b84d6ebae3d2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1970,6 +1970,17 @@ public final class CraftServer implements Server {
         return CraftMagicNumbers.INSTANCE;
     }
 
+    // Paper - Add getTPS API - Further improve tick loop
+    @Override
+    public double[] getTPS() {
+        return new double[] {
+                net.minecraft.server.MinecraftServer.getServer().tps1.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps5.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps15.getAverage()
+        };
+    }
+    // Paper end
+
     private final Spigot spigot = new Spigot()
     {
 
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index be2e31deae605fbf5a3d8bfc235161804f7bdb43..387af9d5c01701eafdb416204e5e2f94116d366f 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -1,8 +1,5 @@
 package org.spigotmc;
 
-import com.google.common.base.Joiner;
-import net.minecraft.server.MinecraftServer;
-import com.google.common.collect.Iterables;
 import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
@@ -26,20 +23,22 @@ public class TicksPerSecondCommand extends Command
             return true;
         }
 
-        StringBuilder sb = new StringBuilder( ChatColor.GOLD + "TPS from last 1m, 5m, 15m: " );
-        for ( double tps : MinecraftServer.getServer().recentTps )
-        {
-            sb.append( format( tps ) );
-            sb.append( ", " );
+        // Paper start - Further improve tick handling
+        double[] tps = org.bukkit.Bukkit.getTPS();
+        String[] tpsAvg = new String[tps.length];
+
+        for ( int i = 0; i < tps.length; i++) {
+            tpsAvg[i] = format( tps[i] );
         }
-        sender.sendMessage( sb.substring( 0, sb.length() - 2 ) );
+        sender.sendMessage( ChatColor.GOLD + "TPS from last 1m, 5m, 15m: " + org.apache.commons.lang.StringUtils.join(tpsAvg, ", "));
+        // Paper end
 
         return true;
     }
 
-    private String format(double tps)
+    private static String format(double tps) // Paper - Made static
     {
         return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED ).toString()
-                + ( ( tps > 20.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 );
+                + ( ( tps > 21.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 ); // Paper - only print * at 21, we commonly peak to 20.02 as the tick sleep is not accurate enough, stop the noise
     }
 }
